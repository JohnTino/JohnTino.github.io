<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>智能指针</title>
    <link href="/2025/05/27/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <url>/2025/05/27/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>智能指针是一种类模板，用于管理动态分配的内存，能在对象生命周期结束时自动释放内存，避免内存泄漏。在传统的C++中，使用 new 分配内存后，必须手动使用delete释放，若忘记或在异常情况下未执行delete，就会导致内存泄漏。而智能指针在对象构造时获取资源，在析构时释放资源，大大提高了代码的安全性。</p><h3 id="C-中智能指针和指针的区别是什么？"><a href="#C-中智能指针和指针的区别是什么？" class="headerlink" title="C++ 中智能指针和指针的区别是什么？"></a>C++ 中智能指针和指针的区别是什么？</h3><p>智能指针是类模板，指针是C&#x2F;C++中一个变量类型，存放的是内存地址。<br>在使用上，智能指针和裸指针都支持解引用*，-&gt;等操作，但智能指针提供包含许多额外的函数。<br>C++共有4种智能指针，包括：<br>unique_ptr：拥有独有对象所有权的智能指针，对于独有对象同一时间只有一个智能指针拥有它。<br>shared_ptr：拥有共享对象所有权的智能指针，通过引用计数跟踪引用特定对象。当引用计数为0时，释放拥有的对象。<br>weak_ptr：对shared_ptr的弱引用，访问时需要转换为shared_ptr；不控制对象的生命周期，配合shared_ptr用于解决shared_ptr循环引用问题。<br>auto_ptr：C++11前的智能指针，在C++17时已废弃，无需了解</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UseRawPointer</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Song* pSong = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Song</span>(<span class="hljs-string">L&quot;Nothing on you&quot;</span>);<br>    <span class="hljs-comment">//Use pSong...</span><br>    <span class="hljs-keyword">delete</span> pSong;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UseSmartPointer</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">unique_ptr&lt;Song&gt; <span class="hljs-title">song2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Song(<span class="hljs-string">L&quot;Nothing on You&quot;</span>))</span></span>;<br>    <span class="hljs-comment">// Use song2...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>智能指针使用指向堆分配对象的原始指针进行初始化，初始化后，智能指针拥有原始指针。智能指针负责对原始指针的释放。<br>智能指针使用RAII机制，管理堆内存中的数据。当智能指针超过其作用域，或者抛出异常时，就会调用智能指针的析构函数，自动释放堆上的内存数据。</p><h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p>unique_ptr通过指针占用并独占一个对象，即对于同一块内存只能有一个持有者，不能放在等号的右边，在unique_ptr离开作用域时释放该对象。Unique_ptr会在栈上分配。<br>有两个场景会使用关联的删除器释放对象：<br>1、销毁了管理的unique_ptr对象<br>2、通过operator&#x3D;或者reset()赋值给另一个unique_ptrs对象<br>unique_ptr只可移动，不支持复制。<br>unique_ptr与裸指针大小一致，在内存上无任何额外的消耗，和裸指针性能相当。</p><h3 id="shared-ptr是什么"><a href="#shared-ptr是什么" class="headerlink" title="shared_ptr是什么"></a>shared_ptr是什么</h3><p>std::shared_ptr 是一种共享式智能指针，多个 std::shared_ptr 可以指向同一个对象。它使用引用计数来管理对象的生命周期，每增加一个指向该对象的 std::shared_ptr，引用计数加 1；每减少一个指向该对象的 std::shared_ptr，引用计数减 1。当引用计数变为 0 时，对象被自动释放。<br>实现原理和规则可以简单的描述为：<br>1、当进行构造函数操作时，创建一个智能指针的新的对象的时候，指针被初始化，内部的引用计数的值设置为1。<br>2、当进行拷贝构造操作时，指针会指向被赋值的指针，并且会对它们指向的资源的引用计数加1。<br>3、当进行赋值构造操作时，会先使赋值前资源的引用计数减1，如果减1后计数为0了，那么就要去释放这个资源。然后进行指针的赋值操作，然后对赋值后的新的资源的引用计数加1。<br>4、当进行析构操作时，会先使引用计数的值减1，如果计数等于0了，那么就去释放资源。<br>支持复制、移动等操作。<br>内存占用上为裸指针的两倍，共有两个指针：<br>1、element_type* _M_ptr：指向所管理的资源。<br>2、__shared_count&lt;_Lp&gt; _M_refcount：指向维护的引用计数，包括引用计数和弱引用计数。<br>shared_ptr可以将unique_ptr移动过来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyShared_ptr</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyShared_ptr</span>(T* ptr = <span class="hljs-literal">nullptr</span>) &#123;<br>        cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; endl;<br>        _ptr = ptr;<br>        _count = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">1</span>);<br>        _weakcount = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-built_in">MyShared_ptr</span>(<span class="hljs-type">const</span> MyShared_ptr&amp; sharedPtr) &#123;<br>        cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; endl;<br>        _count = sharedPtr._count;<br>        _ptr = sharedPtr._ptr;<br>        ++*_count;<br>        _weakcount = sharedPtr._weakcount;<br>    &#125;<br>    MyShared_ptr&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MyShared_ptr&amp; sharedPtr) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;sharedPtr) &#123;<span class="hljs-comment">//处理自赋值的情况</span><br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br>        --*_count;<br>        <span class="hljs-keyword">if</span> (*_count == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">release</span>();<br>        &#125;<br>        _count = sharedPtr._count;<br>        _ptr = sharedPtr._ptr;<br>        ++*_count;<br>        _weakcount = sharedPtr._weakcount;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <span class="hljs-function">T* <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> _ptr;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">use_count</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> *_count;<br>    &#125;<br>    T&amp; <span class="hljs-keyword">operator</span>*() &#123;<br>        <span class="hljs-keyword">return</span> *_ptr;<br>    &#125;<br>    T* <span class="hljs-keyword">operator</span>-&gt;() &#123;<br>        <span class="hljs-keyword">return</span> _ptr;<br>    &#125;<br>    ~<span class="hljs-built_in">MyShared_ptr</span>() &#123;<br>        cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; endl;<br>        --*_count;<br>        cout &lt;&lt; <span class="hljs-string">&quot;_count: &quot;</span> &lt;&lt; *_count &lt;&lt; endl;<br>        <span class="hljs-keyword">if</span> (*_count == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">release</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">release</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">delete</span> _count;<br>        <span class="hljs-keyword">delete</span> _ptr;<br>        <span class="hljs-keyword">delete</span> _weakcount<br>        _count = <span class="hljs-literal">nullptr</span>;<br>        _ptr = <span class="hljs-literal">nullptr</span>;<br>        _weakcount = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><span class="hljs-comment">//注意，在STL的正规实现中，引用计数和弱引用计数在一个结构体中，shared_ptr保存一个指向该结构体的指针，这里这么写是为了描述简单</span><br>    <span class="hljs-type">int</span> *_count;<span class="hljs-comment">//引用计数</span><br>    <span class="hljs-type">int</span> *_weakcount;<span class="hljs-comment">//弱引用计数</span><br>    T *_ptr;<span class="hljs-comment">//智能指针维护的控制块</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="shared-ptr底层原理"><a href="#shared-ptr底层原理" class="headerlink" title="shared_ptr底层原理"></a>shared_ptr底层原理</h3><p>首先是定义了一个基类，shared和unique都继承这个基类，但shared还继承了一个引用计数的基类，这个引用计数基类提供了一个引用计数机制，类里面有一个成员变量，这个成员变量记录资源的引用计数，或者叫强引用计数。表示有多少个指针指向该资源，（还有一个是弱引用计数）。当引用计数减少到0时，销毁资源（并减少弱引用计数，弱引用计数到0时，就会删除计数的基类）</p><h4 id="shared-ptr是线程安全的吗？"><a href="#shared-ptr是线程安全的吗？" class="headerlink" title="shared_ptr是线程安全的吗？"></a>shared_ptr是线程安全的吗？</h4><p>1、同一个shared_ptr被多个线程“读”是安全的.<br>2、同一个shared_ptr被多个线程“写”是不安全的<br>假如说有两个线程同时访问一个shared_ptr对象，一个进行释放（reset），另一个读取裸指针的值，那么最后的结果就不确定了，很可能会因为访问野指针的问题导致crash。<br>3、共享引用计数的不同的shared_ptr被多个线程“写”是安全的；<br>c++ 11官方文档有说，share_ptr的计数操作具有原子性。也就是说多个线程通过多个shaped_ptr（虽然这多个shared_ptr指向的是同一个对象）进行操作，是线程安全的。</p><h4 id="std-weak-ptr有什么作用，它和-std-shared-ptr-有什么关系？-shared-ptr指针的循环引用及解决方法"><a href="#std-weak-ptr有什么作用，它和-std-shared-ptr-有什么关系？-shared-ptr指针的循环引用及解决方法" class="headerlink" title="std::weak_ptr有什么作用，它和 std::shared_ptr 有什么关系？&#x2F; shared_ptr指针的循环引用及解决方法"></a>std::weak_ptr有什么作用，它和 std::shared_ptr 有什么关系？&#x2F; shared_ptr指针的循环引用及解决方法</h4><p>std::weak_ptr 是一种弱引用智能指针，它不拥有对象的所有权，不会增加对象的引用计数。它主要用于解决 std::shared_ptr 可能出现的循环引用问题。当 std::shared_ptr 之间存在循环引用时，引用计数永远不会变为 0，导致内存泄漏。shared_ptr指针的循环引用问题指，两个或多个shared_ptr互相引用，导致shared_ptr的引用计数无法到0，而出现内存泄露的情况。<br>weak_ptr的简易实现：首先下面给出简易的weak_ptr实现，用于和MyShared_ptr进行配合使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* weak_ptr的典型实现为存储两个指针：</span><br><span class="hljs-comment">* 指向控制块的指针，即这里的_ptr；</span><br><span class="hljs-comment">* 指向来源shared_ptr的存储指针；</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyWeak_ptr</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    T* _ptr;<br>    MyShared_ptr&lt;T&gt; *_shared;<br>    <span class="hljs-built_in">MyWeak_ptr</span>() &#123;<br>        _ptr = <span class="hljs-literal">nullptr</span>;<br>        _shared = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <span class="hljs-built_in">MyWeak_ptr</span>(MyShared_ptr&lt;T&gt;&amp; shared): _ptr(shared.<span class="hljs-built_in">get</span>()), _shared(&amp;shared) &#123;<br>        cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; endl;<br>        ++*shared._weakcount;       <span class="hljs-comment">//只增加shared_ptr对象中的弱引用计数</span><br>    &#125;<br>    MyWeak_ptr&lt;T&gt;&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MyShared_ptr&lt;T&gt;&amp; shared) &#123;<br>        cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; endl;<br>        _ptr = shared._ptr;<br>        _shared = <span class="hljs-keyword">const_cast</span>&lt;MyShared_ptr&lt;T&gt; *&gt;(&amp;shared);<br>        ++*_shared-&gt;_weakcount;     <span class="hljs-comment">//只增加shared_ptr对象中的弱引用计数</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">expired</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (_shared == <span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> _shared-&gt;<span class="hljs-built_in">use_count</span>() &gt; <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-function">MyShared_ptr&lt;T&gt; <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (_shared == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">MyShared_ptr</span>&lt;T&gt;(<span class="hljs-literal">nullptr</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> *_shared;<br>    &#125;<br>    ~<span class="hljs-built_in">MyWeak_ptr</span>() &#123;<br>        cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; endl;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>shared_ptr的循环引用问题:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//引用循环问题</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son1</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father1</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    MyShared_ptr&lt;Son1&gt; _son;        <br>    <span class="hljs-built_in">Father1</span>() &#123;<br>        cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Father1</span>() &#123;<br>        cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son1</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    MyShared_ptr&lt;Father1&gt; _father;       <span class="hljs-comment">//注意：此处为shared_ptr</span><br>    <span class="hljs-built_in">Son1</span>() &#123;<br>        cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Son1</span>() &#123;<br>        cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Father1 *fa = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Father1</span>();<br>    Son1 *so = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Son1</span>();<br>    <span class="hljs-function">MyShared_ptr&lt;Father1&gt; <span class="hljs-title">father</span><span class="hljs-params">(fa)</span></span>;<br>    <span class="hljs-function">MyShared_ptr&lt;Son1&gt; <span class="hljs-title">son</span><span class="hljs-params">(so)</span></span>;<br>    father-&gt;_son = son;<br>    son-&gt;_father = father;<br>    cout &lt;&lt; <span class="hljs-string">&quot;father count: &quot;</span> &lt;&lt; father.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;son count: &quot;</span> &lt;&lt; son.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp">$ ./test_shared_ptr.exe <br>MyShared_ptr&lt;T&gt;::<span class="hljs-built_in">MyShared_ptr</span>(T*) [with T = Son1]<br>Father1::<span class="hljs-built_in">Father1</span>()<br>MyShared_ptr&lt;T&gt;::<span class="hljs-built_in">MyShared_ptr</span>(T*) [with T = Father1]<br>Son1::<span class="hljs-built_in">Son1</span>()<br>MyShared_ptr&lt;T&gt;::<span class="hljs-built_in">MyShared_ptr</span>(T*) [with T = Father1]<br>MyShared_ptr&lt;T&gt;::<span class="hljs-built_in">MyShared_ptr</span>(T*) [with T = Son1]<br>father count: <span class="hljs-number">2</span><br>son count: <span class="hljs-number">2</span><br>MyShared_ptr&lt;T&gt;::~<span class="hljs-built_in">MyShared_ptr</span>() [with T = Son1]<br>_count: <span class="hljs-number">1</span>           <span class="hljs-comment">//程序结束后，Son1的引用还为1，无法被释放</span><br>MyShared_ptr&lt;T&gt;::~<span class="hljs-built_in">MyShared_ptr</span>() [with T = Father1]<br>_count: <span class="hljs-number">1</span>           <span class="hljs-comment">//程序结束后，Father1的引用还为1，无法被释放</span><br></code></pre></td></tr></table></figure><p>在程序结束之后，并没有调用Father1和Son1的析构函数，这就是由于Father1和Son1中的shared_ptr循环引用导致的内存泄露问题。如何解决这个问题？  —借助weak_ptr解决循环引用问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son2</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father2</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    MyShared_ptr&lt;Son2&gt; _son;<br>    <span class="hljs-built_in">Father2</span>() &#123;<br>        cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Father2</span>() &#123;<br>        cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son2</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    MyWeak_ptr&lt;Father2&gt; _father;         <span class="hljs-comment">//注意：此处为weak_ptr</span><br>    <span class="hljs-built_in">Son2</span>() &#123;<br>        cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Son2</span>() &#123;<br>        cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Father2 *fa = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Father2</span>();<br>    Son2 *so = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Son2</span>();<br>    <span class="hljs-function">MyShared_ptr&lt;Father2&gt; <span class="hljs-title">father</span><span class="hljs-params">(fa)</span></span>;<br>    <span class="hljs-function">MyShared_ptr&lt;Son2&gt; <span class="hljs-title">son</span><span class="hljs-params">(so)</span></span>;<br>    father-&gt;_son = son;<br>    son-&gt;_father = father;<br>    cout &lt;&lt; <span class="hljs-string">&quot;father count: &quot;</span> &lt;&lt; father.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;son count: &quot;</span> &lt;&lt; son.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="智能指针怎么知道自己的生命周期结束的"><a href="#智能指针怎么知道自己的生命周期结束的" class="headerlink" title="智能指针怎么知道自己的生命周期结束的"></a>智能指针怎么知道自己的生命周期结束的</h3><p>不同的智能指针原理不一样，以STL中引入的智能指针shared_ptr和unique_ptr为例。<br>对于Unique_ptr，它对于资源是独占的，对于同一块内存只能有一个持有者，也就是不能放在等号的右边。Unique_ptr会在栈上分配，当离开作用域后，删除里面持有的资源对象，从而达到自动管理内存的的功能。<br>对于shared_ptr来说，它是一种共享式的智能指针:多个shared_ptr可以共享同一个对象的所有权。在shared_ptr的内部有一个辅助类，辅助类采用引用计数的方式来持有资源（这也就是为何shared_ptr所占用的内存更多的原因）。每次指针指向某一个资源时，内部的引用计数会加1，当每次指针不再指向对象时，内部的引用计数会减1。当内部的引用计数减到0的时候，就会释放指向对象的堆内存空间。</p><h3 id="智能指针一定不会造成内存泄漏吗？使用的时候要注意什么？"><a href="#智能指针一定不会造成内存泄漏吗？使用的时候要注意什么？" class="headerlink" title="智能指针一定不会造成内存泄漏吗？使用的时候要注意什么？"></a>智能指针一定不会造成内存泄漏吗？使用的时候要注意什么？</h3><p>不是，使用智能指针也会造成内存泄漏。举一个例子就是使用了shared_ptr，然后导致了资源的循环引用：A中引用B,B中引用A。这样即使在程序结束后，两个资源的引用计数仍然大于等于1，导致无法释放资源，还是会产生内存泄漏。<br>使用的时候我们需要注意每一个智能指针的特性，适用场景和用法。我们需要遵循它们的使用规则，正确使用它们，比如unique_ptr更适用于资源独占的场景，而在共享资源的时候，我们要用shared_ptr。比如使用unique_ptr结合STL的时候，要避免使用STL容器中具有复制和赋值操作的算法，只有我们正确的使用它们，才能够有效使用智能指针从而防止内存泄漏。</p><h3 id="如果我返回智能指针，有什么优缺点？"><a href="#如果我返回智能指针，有什么优缺点？" class="headerlink" title="如果我返回智能指针，有什么优缺点？"></a>如果我返回智能指针，有什么优缺点？</h3><p>好处的话，是可以让提供给用户一个智能指针，而让他无需关心在函数内部如何处理和管理这个指针。<br>坏处的话是：如果通过引用返回智能指针，可能的存在的风险是返回了这个指针，可能没有对这个指针的引用计数增加，那么就有可能这个指针指向的对象已经销毁了，但是它的引用计数还不为1，通过指针使用访问这个资源就会造成野指针访问crash的问题。<br>如果通过值返回智能指针，那么问题就是通过值传递的开销较大。不过现在编译器有return value optimization（RVO）机制，这个成本开销会较低，并且最少是安全的。如果要进行智能指针的返回，也建议用值传递的方式进行返回。</p><h3 id="weak解决空悬指针问题"><a href="#weak解决空悬指针问题" class="headerlink" title="weak解决空悬指针问题"></a>weak解决空悬指针问题</h3><p>有两个指针p1和p2，指向堆上的同一个对象Object，p1和p2位于不同的线程中。假设线程A通过p1指针将对象销毁了（尽管把p1置为了NULL），那p2就成了空悬指针。<br>weak不控制对象的生命期，但是它知道对象是否还活着。如果对象还活着，那么它可以提升为有效的shared（提升操作通过lock()函数获取所管理对象的强引用指针）；如果对象已经死了，提升会失败，返回一个空的shared。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>FreeRtos</title>
    <link href="/2025/05/11/rtos/"/>
    <url>/2025/05/11/rtos/</url>
    
    <content type="html"><![CDATA[<h2 id="FreeRtos八股"><a href="#FreeRtos八股" class="headerlink" title="FreeRtos八股"></a>FreeRtos八股</h2><h3 id="什么是任务？"><a href="#什么是任务？" class="headerlink" title="什么是任务？"></a>什么是任务？</h3><p>在实时操作系统（RTOS）或通用操作系统中，任务（Task）是指一个独立的执行单元，通常对应一个线程或进程。任务具有以下特点：<br>1、每个任务有自己的堆栈、程序计数器和状态。<br>2、任务可以处于运行、就绪、阻塞等状态。<br>3、任务之间可以通过优先级、时间片等方式竞争 CPU 资源。</p><h3 id="任务调度的基本原理"><a href="#任务调度的基本原理" class="headerlink" title="任务调度的基本原理"></a>任务调度的基本原理</h3><p>任务调度的核心是从就绪队列中选择一个任务并分配 CPU 资源。调度过程包括以下步骤：<br>1、任务创建：初始化任务的控制块（TCB），分配堆栈，设置初始状态为就绪。<br>2、任务选择：根据调度算法从就绪队列中选择一个任务。<br>3、上下文切换：保存当前任务的上下文（如寄存器、程序计数器等），恢复下一个任务的上下文。<br>4、任务执行：将 CPU 分配给选中的任务，任务进入运行状态。<br>5、任务切换：当任务因阻塞、时间片用完或更高优先级任务就绪时，重新调度。</p><h3 id="任务调度算法"><a href="#任务调度算法" class="headerlink" title="任务调度算法"></a>任务调度算法</h3><p>FreeRTOS主要支持两种调度策略：抢占式调度和协同调度。抢占式调度是最常见的调度策略，它允许高优先级任务中断低优先级任务的执行。协同调度则是一种简单的调度策略，所有任务轮流执行，没有优先级的概念。   此外，FreeRTOS还支持时间分片调度，即每个任务分配一个固定的时间片，轮流执行。<br>实时系统的调度是指给定一组实时任务和系统资源，确定每个任务何时何地执行的整个过程。调度算法决定了任务的选择规则，常见的调度算法包括：<br>(1) 优先级调度（Priority Scheduling）。<br>每个任务有一个优先级，优先级高的任务优先执行。分为抢占式（Preemptive）和非抢占式（Non-Preemptive）。抢占式指高优先级任务就绪时，立即抢占低优先级任务的CPU。非抢占式指任务运行完后才检查是否有更高优先级任务就绪。<br>(2) 时间片轮转（Round Robin） 。<br>每个任务分配固定的时间片（Time Slice），时间片用完后切换下一个任务。保证公平性，适合分时系统。<br>(3) 多级反馈队列（Multilevel Feedback Queue）<br>将任务分为多个优先级队列，每个队列采用不同的调度策略。任务根据执行情况动态调整优先级。<br>(4) 实时调度算法<br>Rate-Monotonic Scheduling（RMS）固定优先级调度，周期短的任务优先级高。<br>Earliest Deadline First（EDF）：动态优先级调度，截止时间最早的任务优先级高。</p><h3 id="任务在执行过程中的不同状态"><a href="#任务在执行过程中的不同状态" class="headerlink" title="任务在执行过程中的不同状态"></a>任务在执行过程中的不同状态</h3><p>就绪（Ready）：任务已经准备好运行，等待 CPU 分配资源。<br>运行（Running）：任务正在占用 CPU 执行。<br>阻塞（Blocked）：任务因等待资源（如信号量、事件、I&#x2F;O 等）而被挂起。<br>挂起（Suspended）：任务被显式挂起，暂时不参与调度。<br>终止（Terminated）：任务执行完成或被删除。</p><h3 id="不可剥夺型内核-和-可剥夺型内核-的区别？"><a href="#不可剥夺型内核-和-可剥夺型内核-的区别？" class="headerlink" title="不可剥夺型内核 和 可剥夺型内核 的区别？"></a>不可剥夺型内核 和 可剥夺型内核 的区别？</h3><p>不可剥夺型内核：各个任务彼此合作共享一个CPU，内核要求每个任务自我放弃CPU的所有权，即在执行任务过程中，一个任务可以一直运行，只有当前运行的任务主动放弃CPU控制权才会进行任务切换。不可剥夺型调度法也称作合作型多任务，各个任务彼此合作共享一个CPU。<br>可剥夺型内核：根据优先级可占用当前CPU的使用权，系统可以强制中断正在执行的任务，并将控制权交给其他高优先级的任务。FreeRtos就是剥夺型内核。</p><h3 id="上下文切换（Context-Switching）涉及哪些步骤："><a href="#上下文切换（Context-Switching）涉及哪些步骤：" class="headerlink" title="上下文切换（Context Switching）涉及哪些步骤："></a>上下文切换（Context Switching）涉及哪些步骤：</h3><p>FreeRTOS内核是系统的核心部分，主要由任务控制块（TCB）、任务调度器、上下文切换机制三部分组成，介绍如下：<br>任务控制块（TCB）：每个任务都有一个任务控制块，用于保存任务的状态、优先级、堆栈指针等信息；<br>任务调度器：调度器根据任务优先级调度算法决定要运行的任务；<br>上下文切换机制：负责任务间切换上下文，也就是保存当前任务的寄存器状态和恢复下一个任务的寄存器状态。<br>上下文切换需要进行工作：<br>1、保存当前任务上下文：将 CPU 寄存器、程序计数器等保存到当前任务的控制块（TCB）中。<br>2、加载下一个任务上下文：从下一个任务的 TCB 中恢复寄存器、程序计数器等。<br>3、切换到下一个任务：更新 CPU 状态，开始执行下一个任务。<br>上下文切换的开销较大，因此调度算法的设计需要尽量减少切换频率。</p><h3 id="什么是临界区和临界资源，原理是什么"><a href="#什么是临界区和临界资源，原理是什么" class="headerlink" title="什么是临界区和临界资源，原理是什么"></a>什么是临界区和临界资源，原理是什么</h3><p>临界区：进程中访问临界资源的代码段。该区域需要被互斥执行，确保同一时间只有一个进程进入。例如，多个进程修改同一个全局变量时，访问该变量的代码段即为临界区。<br>临界资源就是临界区中的共享资源，比如消息队列、共享内存等。FreeRTOS在进出临界区时通过关闭和打开受FreeRTOS管理的中断来保护临界区中的代码，注意，FreeRTOS的临界区是可以嵌套的，也就是程序可以重复进入临界区，后续也需要重复退出相同次数的临界区。</p><h3 id="什么是任务死锁？"><a href="#什么是任务死锁？" class="headerlink" title="什么是任务死锁？"></a>什么是任务死锁？</h3><p>任务死锁是FreeRTOS中比较常见的问题，表现为多个任务互相等待对方释放资源，任务死锁的现象如下：<br>比如现在有两个任务：任务A和任务B，这两个任务要访问两个共享资源：资源M和资源N。此时，任务A获取到了资源M，任务B获取到了资源N，当任务A接着尝试获取资源N时会进入阻塞，等待任务B释放资源，若此时任务B尝试获取资源M，同样会进入阻塞，等待任务A释放资源，这就造成了任务死锁，两个任务互相等待对方释放资源。 </p><h3 id="FreeRTOS内存分配机制："><a href="#FreeRTOS内存分配机制：" class="headerlink" title="FreeRTOS内存分配机制："></a>FreeRTOS内存分配机制：</h3><p>1、动态内存分配（默认）：动态内存分配是指在任务运行时从堆（Heap）中分配内存；FreeRTOS 提供了多种堆管理方案，用户可以根据需求选择合适的方案；使用动态内存分配时，需要通过 FreeRTOS 提供的 API（如 pvPortMalloc 和 vPortFree）来分配和释放内存。<br>2、静态内存分配：静态内存分配是指允许用户在编译时为任务和内核对象（如队列、信号量等）分配静态内存；使用静态内存分配时，任务、队列、信号量等对象的内存由开发者显式定义，无需运行时分配。；这种方式适合内存受限的系统，可以避免堆内存碎片问题。</p><h3 id="FreeRTOS如何实现任务的优先级反转避免？"><a href="#FreeRTOS如何实现任务的优先级反转避免？" class="headerlink" title="FreeRTOS如何实现任务的优先级反转避免？"></a>FreeRTOS如何实现任务的优先级反转避免？</h3><p>任务优先级反转是指一个低优先级任务持有一个高优先级任务需要的资源，导致高优先级任务无法执行的情况。<br>FreeRTOS通过优先级继承和优先级天花板两种机制来避免优先级反转。优先级继承允许低优先级任务临时提升到高优先级任务的优先级，而优先级天花板是在访问共享资源时设置一个最高的优先级，以确保不会发生优先级反转。</p><h3 id="中断嵌套和抢占混乱问题"><a href="#中断嵌套和抢占混乱问题" class="headerlink" title="中断嵌套和抢占混乱问题"></a>中断嵌套和抢占混乱问题</h3><p>1、使用中断禁用和使能控制<br>在关键的代码段（如中断处理程序的某些部分或者任务调度相关的代码段）禁止中断。例如，在中断处理程序更新与任务调度相关的数据结构时，禁止其他中断的进入。这样可以保证当前操作的原子性，避免被其他中断打断。在任务调度方面，也可以在任务切换的关键时刻禁止抢占，确保任务切换的正确性。<br>2、使用优先级屏蔽<br>为系统中的任务和中断设置优先级屏蔽。当一个任务或中断正在执行关键操作时，它可以设置一个优先级屏蔽值，这个屏蔽值会阻止优先级低于该屏蔽值的任务或中断的抢占或中断。例如，一个中断处理程序在更新关键数据结构时，设置一个较高的优先级屏蔽值，这样只有优先级高于该屏蔽值的中断才能打断它。</p><h3 id="FreeRTOS中的信号量有哪些类型？"><a href="#FreeRTOS中的信号量有哪些类型？" class="headerlink" title="FreeRTOS中的信号量有哪些类型？"></a>FreeRTOS中的信号量有哪些类型？</h3><p>信号量常常用于控制对共享资源的访问和任务同步。FreeRTOS中有三种主要类型的信号量：二值信号量、计数信号量和递归信号量。<br>二值信号量用于锁定资源，类似于互斥锁，它们只能有两个状态：获取或释放。通常用于互斥访问或同步<br>计数信号量可以用于管理多个相同的资源，或者用来同步多个任务。<br>递归信号量是计数信号量的一种特殊形式，允许同一个任务多次获取同一个资源。</p><h4 id="互斥信号量和二值信号量的区别"><a href="#互斥信号量和二值信号量的区别" class="headerlink" title="互斥信号量和二值信号量的区别"></a>互斥信号量和二值信号量的区别</h4><p>互斥信号量拥有优先级继承机制，所以只能用在任务中，不能用于中断服务函数。<br>二值信号量没有优先级继承，二值信号量其实就是一个只有一个队列项的队列，这个特殊的队列要么是满的，要么是空的。<br>因此二值信号另更适合用于同步(任务与任务或任务与中断的同步)，而互斥信号量适合用于简单的互斥访问。</p><h3 id="请描述一下FreeRTOS中的优先级继承机制。"><a href="#请描述一下FreeRTOS中的优先级继承机制。" class="headerlink" title="请描述一下FreeRTOS中的优先级继承机制。"></a>请描述一下FreeRTOS中的优先级继承机制。</h3><p>优先级继承是一种避免优先级反转问题的机制。当一个低优先级任务持有一个高优先级任务需要的资源时，高优先级任务可能会被延迟执行。优先级继承机制允许低优先级任务临时继承高优先级任务的优先级，以避免高优先级任务长时间等待资源，从而减少优先级反转的影响。<br>reeRTOS中的tickless模式是什么？</p><h3 id="你能解释一下FreeRTOS的tickless模式吗？"><a href="#你能解释一下FreeRTOS的tickless模式吗？" class="headerlink" title="你能解释一下FreeRTOS的tickless模式吗？"></a>你能解释一下FreeRTOS的tickless模式吗？</h3><p>tickless模式是FreeRTOS中的一种节能机制，它减少了系统时钟滴答的频率。在tickless模式下，时钟滴答的产生依赖于任务的时间需求，而不是固定频率。这意味着，如果系统中的所有任务都处于阻塞状态，或者没有任何时间敏感的操作需要执行，时钟滴答可以停止，从而减少CPU的功耗。</p><h3 id="请解释任务栈的作用以及它在FreeRTOS中是如何初始化的。"><a href="#请解释任务栈的作用以及它在FreeRTOS中是如何初始化的。" class="headerlink" title="请解释任务栈的作用以及它在FreeRTOS中是如何初始化的。"></a>请解释任务栈的作用以及它在FreeRTOS中是如何初始化的。</h3><p>任务栈是为任务提供内存空间的一种机制，用于存储局部变量、函数参数、返回地址以及可能的中断上下文。在FreeRTOS中，任务栈在创建任务时通过xTaskCreate()宏进行初始化。栈的大小必须在创建任务时指定，并且通常根据任务的复杂性和需要的栈空间大小来决定。</p><h4 id="如何合理地设定任务栈的大小？"><a href="#如何合理地设定任务栈的大小？" class="headerlink" title="如何合理地设定任务栈的大小？"></a>如何合理地设定任务栈的大小？</h4><p>可以先给任务设置比较大的任务栈，确保不会出现栈溢出的情况，然后让系统运行一段比较长的时间，同时尽量触发各种可能的情况。<br>可通过uxTaskGetStackHighWaterMark() 函数来查看任务最多使用了多少栈空间，一般将最终的栈大小设置为该值的1.5~2倍是比较合适的。</p><h3 id="中断和任务区别"><a href="#中断和任务区别" class="headerlink" title="中断和任务区别"></a>中断和任务区别</h3><p>中断是硬件或软件触发的事件，用于快速响应外部或内部事件，通常具有固定的优先级，并且执行时间非常短。任务则是操作系统调度的基本单位，具有特定的优先级，可以执行更复杂的操作，并且可以被挂起和恢复。中断处理程序应尽可能简短，以避免影响其他任务的执行。</p><h3 id="能否阐述一下轮询和事件驱动在FreeRTOS中的不同之处？"><a href="#能否阐述一下轮询和事件驱动在FreeRTOS中的不同之处？" class="headerlink" title="能否阐述一下轮询和事件驱动在FreeRTOS中的不同之处？"></a>能否阐述一下轮询和事件驱动在FreeRTOS中的不同之处？</h3><p>轮询是一种不断检查某个条件是否为真的方法，例如，检查一个变量是否有变化。而事件驱动是一种基于事件来触发动作的机制。在FreeRTOS中，通常推荐使用事件驱动的方法，因为它可以更有效地使用CPU资源，并且可以避免忙等待。事件驱动允许任务在事件发生时被唤醒，而不是不断地检查某个条件。</p><h3 id="在FreeRTOS中，静态内存分配和动态内存分配有何不同？"><a href="#在FreeRTOS中，静态内存分配和动态内存分配有何不同？" class="headerlink" title="在FreeRTOS中，静态内存分配和动态内存分配有何不同？"></a>在FreeRTOS中，静态内存分配和动态内存分配有何不同？</h3><p>静态内存分配是在编译时确定的，通常用于创建固定大小的内存块，如任务栈和队列。动态内存分配则是在运行时进行的，允许根据需要分配和释放内存。FreeRTOS提供了多种动态内存管理方案，包括使用可变大小的内存块和使用固定大小的内存池。动态内存分配更加灵活，但可能会增加运行时的开销。</p><h3 id="在使用FreeRTOS处理中断时，中断优先级有哪些需要特别注意的地方？"><a href="#在使用FreeRTOS处理中断时，中断优先级有哪些需要特别注意的地方？" class="headerlink" title="在使用FreeRTOS处理中断时，中断优先级有哪些需要特别注意的地方？"></a>在使用FreeRTOS处理中断时，中断优先级有哪些需要特别注意的地方？</h3><p>在配置中断优先级时，需要确保不会与任务优先级发生冲突。中断优先级应该设置得足够高，以确保能够及时响应外部事件，但也不能太高，以免影响任务的调度。此外，还需要注意中断服务例程中执行的操作应该尽可能简短，避免长时间的中断处理影响系统的响应性和稳定性。</p><h3 id="前后台程序与实时操作系统的区别是什么？"><a href="#前后台程序与实时操作系统的区别是什么？" class="headerlink" title="前后台程序与实时操作系统的区别是什么？"></a>前后台程序与实时操作系统的区别是什么？</h3><p>前后台程序：在前后台系统中，通常只有一个后台任务和一个前台任务。前台任务响应中断或事件，而后台任务则在没有事件时运行。整个系统结构简单，但对时间敏感的任务响应较差。<br>实时操作系统：在实时操作系统（RTOS）中，多个任务可以被调度，系统通过任务调度器管理任务的执行顺序。RTOS可以保证高优先级任务得到及时的处理，更适合复杂系统中的实时响应需求。</p><h3 id="一个参数可以同时是const和volatile吗？为什么？"><a href="#一个参数可以同时是const和volatile吗？为什么？" class="headerlink" title="一个参数可以同时是const和volatile吗？为什么？"></a>一个参数可以同时是const和volatile吗？为什么？</h3><p>可以。<br>const强调的是程序代码层面的常量性，即程序员承诺不会在代码里对该变量的值进行修改。编译器会对这种承诺进行检查，若代码尝试修改const修饰的变量，就会报错。<br>volatile关注的是变量值改变的不可预测性，它告诉编译器该变量的值可能会以编译器无法预知的方式被改变，例如来自硬件设备的修改、多线程中其他线程的修改等。所以编译器不会对volatile修饰的变量进行优化，保证每次访问的都是变量的最新值。<br>例如：在嵌入式系统里，一个指向硬件只读寄存器的指针，就可将其指向的内容声明为const volatile，既表明代码不会修改该寄存器值，又能确保每次读取到的是硬件实时状态。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux八股笔记</title>
    <link href="/2025/05/10/Linux%E5%85%AB%E8%82%A1/"/>
    <url>/2025/05/10/Linux%E5%85%AB%E8%82%A1/</url>
    
    <content type="html"><![CDATA[<p>一个记录Linux系统学习的博客。</p><h2 id="Linux秋招八股"><a href="#Linux秋招八股" class="headerlink" title="Linux秋招八股"></a>Linux秋招八股</h2><h3 id="linux“三巨头”"><a href="#linux“三巨头”" class="headerlink" title="linux“三巨头”"></a>linux“三巨头”</h3><h4 id="1-Bootloader（引导加载程序）"><a href="#1-Bootloader（引导加载程序）" class="headerlink" title="1.Bootloader（引导加载程序）"></a>1.Bootloader（引导加载程序）</h4><p>Bootloader是Linux系统启动过程中第一个被执行的程序。它主要负责硬件自检、初始化硬件设备、加载内核映像到内存中，并设置必要的启动参数。常见的Bootloader包括GRUB（GRand Unified Bootloader）、LILO（LInux LOader）和SYSLINUX等。Bootloader的工作是在系统启动时进行的，它为Linux内核的加载和运行提供了一个启动环境。 </p><h4 id="2-Kernel（内核）"><a href="#2-Kernel（内核）" class="headerlink" title="2.Kernel（内核）"></a>2.Kernel（内核）</h4><p>Kernel（内核）：Kernel是Linux操作系统的核心，负责管理和控制计算机的所有硬件和软件资源。它提供了系统调用接口，为上层应用程序提供了一个稳定、安全、高效的运行环境。Kernel的任务包括进程管理、内存管理、设备驱动程序、文件系统管理等。Linux内核由Linus Torvalds创造并维护，具有高度的可配置性和可扩展性。 </p><h4 id="3-RootFS（根文件系统）"><a href="#3-RootFS（根文件系统）" class="headerlink" title="3.RootFS（根文件系统）"></a>3.RootFS（根文件系统）</h4><p>RootFS是Linux系统的根目录，包含了系统运行所需的各种文件和目录，如系统二进制文件、库文件、设备文件、配置文件等。在内核启动后，它会挂载RootFS作为系统的根目录，从中读取系统启动时需要的配置文件和启动脚本等。RootFS对于Linux系统的正常运行至关重要，它提供了系统运行时所需的所有基本资源。根文件系统首先是内核启动时所 mount(挂载)的第一个文件系统，内核代码映像文件保存在根文件系统中，而系统引导启动程序会在根文件系统挂载之后从中把一些基本的初始化脚本和服务等加载到内存中去运行。</p><h4 id="烧录的系统镜像有哪些内容？"><a href="#烧录的系统镜像有哪些内容？" class="headerlink" title="烧录的系统镜像有哪些内容？"></a>烧录的系统镜像有哪些内容？</h4><p>内核镜像、根文件系统镜像、引导程序（Bootloader）、固件（Fireware）、预装的APP以及一些配置文件</p><h4 id="Linux-开机启动过程？"><a href="#Linux-开机启动过程？" class="headerlink" title="Linux 开机启动过程？"></a>Linux 开机启动过程？</h4><p>主机加电自检，加载 BIOS 硬件信息； 读取 MBR 的引导文件(GRUB、LILO)；引导 Linux 内核；运行第一个进程 init (进程号永远为 1 )；进入相应的运行级别；运行终端，输入用户名和密码。      </p><h4 id="内核和文件系统的关系"><a href="#内核和文件系统的关系" class="headerlink" title="内核和文件系统的关系"></a>内核和文件系统的关系</h4><p>根文件系统首先是内核启动时所 mount(挂载)的第一个文件系统，内核代码映像文件保存在根文件系统中，而系统引导启动程序会在根文件系统挂载之后从中把一些基本的初始化脚本和服务等加载到内存中去运行。根文件系统是 Linux 内核启动以后挂载(mount)的第一个文件系统，然后从根文件系统中读取初始化脚本，比如 rcS，inittab 等。根文件系统和 Linux 内核是分开的，单独的 Linux 内核是没法正常工作的，必须要搭配根文件系统。如果不提供根文件系统，Linux 内核在启动的时候就会提示内核崩溃(Kernel panic)的提示。<br>内核的作用：Linux 内核是操作系统的核心部分，负责管理硬件资源（如 CPU、内存、设备驱动等）。它在启动时初始化硬件，加载必要的驱动程序，并启动用户空间的第一个进程（如 init 或 systemd），该进程负责启动其他服务和程序，init和systemd位于根文件系统。<br>文件系统的作用：<br>1.根文件系统包含系统启动时所必须的目录和关键性的文件，以及使其他文件系统得以挂载（mount）所必要的文件，是操作系统用来管理存储设备（如硬盘、SD 卡、eMMC 等）上的文件和目录的方式。<br>2.操作系统的大部分功能（如网络服务、文件管理、用户登录等）都依赖于用户空间的程序和服务，这些程序都存储在根文件系统中。它提供了对文件的操作接口（如读写、创建、删除等），并存储了操作系统的核心文件（如可执行程序、配置文件、库文件等）。<br>3.挂载其他文件系统， 操作系统通常会将其他分区（如 &#x2F;home、&#x2F;var、&#x2F;tmp 等）挂载到根文件系统上。<br>4、用户的命令行终端（如 bash）和图形界面都依赖于根文件系统上的程序，如果没有文件系统，用户无法与系统交互。</p><h4 id="根文件系统-rootfs-为什么这么重要？"><a href="#根文件系统-rootfs-为什么这么重要？" class="headerlink" title="根文件系统(rootfs)为什么这么重要？"></a>根文件系统(rootfs)为什么这么重要？</h4><p>1、init进程的应用程序必须运行在根文件系统上；<br>2、根文件系统提供了根目录“&#x2F;”<br>3、linux挂载分区时所依赖的信息存放于根文件系统&#x2F;etc&#x2F;fstab这个文件中；<br>4、shell命令程序必须运行在根文件系统上，譬如ls、cd等命令。一套linux体系，只有内核本身是不能工作的，必须要rootfs的（etc目录下的配置文件、&#x2F;bin和&#x2F;sbin等目录下的shell命令，还有&#x2F;lib目录下的库文件等）相配合才能工作。</p><h4 id="Linux的根文件系统"><a href="#Linux的根文件系统" class="headerlink" title="Linux的根文件系统"></a>Linux的根文件系统</h4><p>Linux的根文件系统实际上是一个文件夹或者叫目录，该目录下会有许多子目录，这些目录中存放许多Linux运行所必须的文件，比如库、常用的软件和命令、设备文件、配置文件等等<br>&#x2F;bin目录 此目录下存放系统需要的可执行文件，一般都是一些命令，比如ls、mv等命令<br>&#x2F;sbin目录 此目录同bin，也是存放一些可执行文件，不过只有管理员才能使用，通常是超级用户(root)使用的命令，例如 ifconfig、reboot、fdisk等<br>&#x2F;dev目录 存放设备文件。Linux将硬件设备抽象为文件，设备文件用于与硬件交互，例如&#x2F;dev&#x2F;ttymxc0就表示IMX6ULL的串口0。&#x2F;dev&#x2F;sda:表示第一个SATA硬盘<br>&#x2F;etc目录 此目录下存放着各种配置文件，包括网络配置、用户账户信息、启动脚本等，例如:&#x2F;etc&#x2F;passwd:用户账户信息。&#x2F;etc&#x2F;network&#x2F;interfaces:网络配置。<br>&#x2F;lib目录 此目录下存放着Linux所必须的库文件。这些库文件是共享库，命令和用户编写的应用程序要使用这些库文件，包括c标准库(如libc.so)和其他系统库。<br>&#x2F;mnt目录 临时挂载点，通常用于手动挂载外部设备(如U盘、网络文件系统等)。<br>&#x2F;proc目录 此目录一般是空的，当 linux 系统启动以后会将此目录作为 proc 文件系统的挂载点，proc是个虚拟文件系统，没有实际的存储设备。proc 里面的文件都是临&#x2F;proc目录时存在的，一般用来存储系统运行信息文件，包含内核和进程的运行时信息。例如:&#x2F;proc&#x2F;cpuinfo:CPU信息。 &#x2F;proc&#x2F;meminfo:内存信息<br>&#x2F;usr目录 usr不是user的缩写，而是 unix sotware Resource 的缩写，也就是unix操作系统软件资源目录，存放用户程序和库文件。例如:&#x2F;usr&#x2F;bin:用户命令。&#x2F;usr&#x2F;lib:用户程序库。&#x2F;usr&#x2F;share:共享数据(如文档、字体等)<br>&#x2F;var目录 存放可变数据(如日志、缓存、邮件等)。包括&#x2F;var&#x2F;log(系统日志)、&#x2F;var&#x2F;cache(缓存文件)、&#x2F;var&#x2F;spool(邮件队列)等，这些数据会随着系统运行而动态变化。<br>&#x2F;tmp目录 存放临时文件。应用程序运行时生成的临时文件。系统重启后，&#x2F;tmp目录中的文件通常会被清除<br>&#x2F;opt目录 可选的应用软件包的安装位置，通常用于安装第三方软件。<br>&#x2F;home目录 用户的主目录，通常以用户的账户名命名。<br>&#x2F;boot目录 包含启动Linux时所需的核心文件，如内核文件和引导加载器。<br>&#x2F;root目录 系统管理员(超级用户)的主目录,</p><h3 id="Uboot相关"><a href="#Uboot相关" class="headerlink" title="Uboot相关"></a>Uboot相关</h3><h4 id="什么是uboot"><a href="#什么是uboot" class="headerlink" title="什么是uboot?"></a>什么是uboot?</h4><p>1.uboot是一个裸机程序。<br>2.uboot就是一个bootloader，作用就是用于启动Linux或其他系统。Uboot最主要的工作就是初始化 DDR。因为Linux是运行在DDR里面的。一般Linux镜像zlmage(ulmage)+设备树(.dtb)存放在 SD、EMMC、NAND、SPIFLASH等等外置存储区域。这里就牵扯到一个问题，需要将Linux镜像从外置flash拷贝到DDR中，再去启动。Uboot的主要目的就是为系统的启动做准备。Uboot不仅仅能启动Linux，也可以启动其他系统，比如vxworks。Linux 不仅仅能通过 uboot 启动。Uboot是个通用的 bootloader，支持多种架构。</p><h4 id="什么是bootloader？bootloader有什么作用？"><a href="#什么是bootloader？bootloader有什么作用？" class="headerlink" title="什么是bootloader？bootloader有什么作用？"></a>什么是bootloader？bootloader有什么作用？</h4><p>Bootloader（引导加载程序）是计算机系统启动时运行的一段程序，位于硬件和操作系统之间，负责初始化硬件和加载操作系统。它是系统启动的关键步骤，确保操作系统能够正确加载并运行。bootloader和 Linux内核的关系就跟PC上的BIOS和 Windows的关系一样，bootloader就相当于BIOS。<br>Bootloader 的作用：<br>1、硬件初始化，初始化 CPU、内存、存储设备（如硬盘、SSD）等硬件。设置必要的硬件环境，为操作系统的运行做准备；<br>2、加载操作系统，从存储设备（如硬盘、U 盘、网络）中读取操作系统的内核文件。将控制权交给操作系统内核，启动操作系统；<br>3、多系统引导，如果系统中安装了多个操作系统，Bootloader 可以让用户选择启动哪个系统；<br>4、故障恢复，提供恢复模式或紧急启动选项，帮助修复系统问题。</p><h4 id="Bootloader的启动过程分为那两个阶段："><a href="#Bootloader的启动过程分为那两个阶段：" class="headerlink" title="Bootloader的启动过程分为那两个阶段："></a>Bootloader的启动过程分为那两个阶段：</h4><p>Bootloader的启动过程可以分为两个阶段：引导加载程序阶段和内核引导阶段。<br>1、引导加载程序阶段：在计算机启动时，固件（如BIOS或UEFI）将控制权交给引导加载程序。引导加载程序位于固件和操作系统之间，负责初始化硬件、加载并执行操作系统的内核。在这个阶段，引导加载程序会进行以下步骤：<br>初始化硬件设备：包括处理器、内存等硬件的设置和检测。<br>选择操作系统：如果存在多个操作系统，引导加载程序可能提供一个菜单供用户选择。<br>加载内核映像：从磁盘上读取Linux内核镜像文件，并将其加载到内存中。<br>设置内核参数：为了正确启动内核，引导加载程序可能需要设置一些参数，例如根文件系统的位置。<br>2、内核引导阶段：一旦引导加载程序将内核加载到内存中，它会跳转到内核的入口点并将控制权交给内核。在这个阶段，Linux内核开始执行，并完成以下任务：<br>初始化系统资源：Linux内核会初始化各种设备驱动程序、建立进程调度器等。<br>挂载根文件系统：Linux内核会查找并挂载根文件系统作为整个操作系统的起点。<br>启动init进程：一旦根文件系统被挂载，内核会启动init进程，它是用户空间的第一个进程。<br>通过这两个阶段，Bootloader负责从计算机的启动到Linux内核的加载和执行，并将控制权逐渐移交给操作系统。</p><h4 id="uboot和内核如何完成参数传递？"><a href="#uboot和内核如何完成参数传递？" class="headerlink" title="uboot和内核如何完成参数传递？"></a>uboot和内核如何完成参数传递？</h4><p>1.U-Boot 加载设备树和内核     U-Boot 从存储设备（如 eMMC、SD 卡、网络）中加载 Linux 内核镜像（zImage 或 uImage）和设备树文件（*.dtb）；<br>2.设置 Bootargs         U-Boot 将 命令行参数（Bootargs） 传递给内核，这些参数包括根文件系统位置、控制台设置、内核调试选项等；<br>3.启动内核         U-Boot 将控制权交给 Linux 内核，并将设备树和 Bootargs 传递给内核；<br>4.内核解析参数         Linux 内核启动后，读取设备树文件和 Bootargs，完成硬件初始化和系统配置。</p><h3 id="应用程序和驱动程序、单片机程序有何不同"><a href="#应用程序和驱动程序、单片机程序有何不同" class="headerlink" title="应用程序和驱动程序、单片机程序有何不同?"></a>应用程序和驱动程序、单片机程序有何不同?</h3><p>裸机编程：把没有操作系统支持的编程环境称为裸机编程环境，譬如单片机上的编程开发，编写直接在硬件上运行的程序，没有操作系统支持。<br>驱动编程：指的是基于内核驱动框架开发驱动程序（底层硬件操作逻辑编译方式），驱动开发工程师通过调用 Linux 内核提供的接口完成设备驱动的注册，可编译成模块或内置到内核。<br>应用编程（系统编程）：指的是基于 Linux 操作系统的应用编程，在应用程序中通过调用系统调用 API 完成应用程序的功能和逻辑（业务逻辑实现），应用程序运行于操作系统之上。<br>通常在操作系统下有两种不同的状态：内核态和用户态，应用程序运行在用户态、而内核则运行在内核态。<br>系统调用（system call）：是 Linux 内核提供给应用层的应用编程接口（API），是 Linux 应用层进入内核的入口。不止 Linux 系统，所有的操作系统都会向应用层提供系统调用，应用程序通过系统调用来使用操作系统提供的各种服务。</p><h4 id="库函数和系统调用的区别"><a href="#库函数和系统调用的区别" class="headerlink" title="库函数和系统调用的区别"></a>库函数和系统调用的区别</h4><p>1、库函数是属于应用层，而系统调用是内核提供给应用层的编程接口，属于系统内核的一部分。<br>2、库函数运行在用户空间，调用系统调用会由用户空间（用户态）陷入到内核空间（内核态）。<br>3、库函数通常是有缓存的，而系统调用是无缓存的，所以在性能、效率上，库函数通常要优于系统调用。<br>4、可移植性：库函数相比于系统调用具有更好的可移植性，通常对于不同的操作系统，其内核向应用层提供的系统调用往往都是不同，譬如系统调用的定义、功能、参数列表、返回值等往往都是不一样的；而对于 C 语言库函数来说，由于很多操作系统都实现了 C 语言库，C 语言库在不同的操作系统之间其接口定义几乎是一样的，所以库函数在不同操作系统之间相比于系统调用具有更好的可移植性。  </p><h3 id="Linux内存管理模块MMU的作用是？"><a href="#Linux内存管理模块MMU的作用是？" class="headerlink" title="Linux内存管理模块MMU的作用是？"></a>Linux内存管理模块MMU的作用是？</h3><p>1、地址映射。<br>2、内存分配和回收。<br>3、内存保护。<br>4、内存扩充。</p><h3 id="说一下用户态和内核态区别"><a href="#说一下用户态和内核态区别" class="headerlink" title="说一下用户态和内核态区别"></a>说一下用户态和内核态区别</h3><p>Linux秉承“一切皆文件”的规则。用户态和内核态是操作系统的两种运行级别，两者最大的区别就是特权级不同。用户态拥有最低的特权级，内核态拥有最高的特权级。运行在用户态的程序不能直接访问操作系统内核数据结构和程序。内核态和用户态之间的转换方式主要包括：系统调用，异常和中断。<br><img src="https://raw.githubusercontent.com/JohnTino/blogImage/main/img/kernel-APP.png"></p><h3 id="用户空间与内核通信方式？"><a href="#用户空间与内核通信方式？" class="headerlink" title="用户空间与内核通信方式？"></a>用户空间与内核通信方式？</h3><p>1、系统调用（System Call）：用户空间程序可以通过系统调用请求内核提供服务或执行特权操作。系统调用是一种将控制权从用户空间切换到内核空间，并传递参数进行处理的机制。例如，打开文件、读写文件等操作都可以通过系统调用来实现。<br>2、进程间通信（Inter-Process Communication, IPC）：IPC 是一种在不同进程之间进行数据交换和通信的机制，在用户空间和内核空间之间也可以进行通信。常见的 IPC 方式包括管道（pipe）、消息队列（message queue）、共享内存（shared memory）、信号量（semaphore）等。<br>3、内存映射（Memory Mapping）：通过内存映射技术，可以将一个文件或者设备映射到用户空间的虚拟地址空间中，使得用户程序可以直接对该内存区域进行读写操作。这样就实现了用户空间与内核缓冲区之间的数据传输。<br>4、读取&#x2F;写入特殊设备文件：某些情况下，用户程序需要直接与硬件设备进行交互，可以通过读取或写入特殊设备文件来与内核进行通信。例如，打开&#x2F;dev&#x2F;ttyS0这样的设备文件进行串口通信。</p><h3 id="Cmake-、make、cmakelist、makefile的关系"><a href="#Cmake-、make、cmakelist、makefile的关系" class="headerlink" title="Cmake 、make、cmakelist、makefile的关系"></a>Cmake 、make、cmakelist、makefile的关系</h3><p>1、make 是一个经典的构建工具，用于自动化构建软件项目。它的主要功能是解析 Makefile 文件中的规则（Makefile告知make），并根据这些规则执行构建任务，如编译源代码、链接生成可执行文件等。<br>2、CMake 是一个跨平台的构建系统生成器，使用一个CMakeLists.txt 的配置文件来描述项目的构建过程和依赖关系。通过 CMakeLists.txt（配置文件）定义构建规则，生成 Makefile 或其他构建系统文件（如 Visual Studio 项目文件、Xcode 项目文件等）。它的主要目的是简化构建过程，使项目在不同平台上更容易构建。</p><h3 id="nfs和tftp是什么，他们有什么区别？"><a href="#nfs和tftp是什么，他们有什么区别？" class="headerlink" title="nfs和tftp是什么，他们有什么区别？"></a>nfs和tftp是什么，他们有什么区别？</h3><p>NFS 是一种分布式文件系统协议，基于TCP，允许用户通过网络访问其他计算机上的文件，就像访问本地文件系统一样，支持完整的文件系统操作（读、写、删除、目录管理等），资源占用多，常用于企业文件共享、分布式计算、备份恢复。<br>TFTP 是一种简单的文件传输协议，基于UDP，主要用于嵌入式设备、网络设备固件更新、小型网络文件传输，资源占用少。</p><h4 id="什么是sftp？"><a href="#什么是sftp？" class="headerlink" title="什么是sftp？"></a>什么是sftp？</h4><p>SFTP（Secure File Transfer Protocol，安全文件传输协议）是一种用于在计算机网络中进行安全文件传输的网络协议。它基于SSH（Secure Shell）协议，提供了文件传输过程中的加密和认证功能，确保数据传输的安全性和完整性。与FTP的区别：FTP使用明文传输数据，用户名、密码和文件内容都可能被窃取，安全性低。SFTP数据都加密传输，安全性高，对服务器的计算资源要求稍高。</p><h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p>对于文件IO来说，一切都是围绕文件描述符来进行的。在Linux系统中，所有打开的文件都有一个对应的文件描述符。<br>文件描述符的本质是一个非负整数，当我们打开一个文件时，系统会给我们分配一个文件描述符。当我们对一个文件做读写操作的时候，我们使用open函数返回的这个文件描述符会标识该文件，并将其作为参数传递给read或者write函数在posix.1应用程序里面。<br>文件描述符0,1.2分别对应着标准输入，标准输出，标准出错。</p><h3 id="请你讲一下platform驱动框架"><a href="#请你讲一下platform驱动框架" class="headerlink" title="请你讲一下platform驱动框架"></a>请你讲一下platform驱动框架</h3><p>Linux 中的总线(bus)、驱动(driver)和设备(device)模型，也就是常说的驱动分离。将设备信息从设备驱动中剥离开来，驱动使用标准方法去获取到设备信息(比如从设备树中获取到设备信息)，然后根据获取到的设备信息来初始化设备。 这样就相当于驱动只负责驱动，设备只负责设备。当我们向系统注册一个驱动的时候，总线就会在右侧的设备中查找，看看有没有与之匹配的设备，如果有的话就将两者联系起来。同样的，当向系统中注册一个设备的时候，总线就会在左侧的驱动中查找看有没有与之匹配的设备，有的话也联系起来。</p><h3 id="请你讲一下linux子系统"><a href="#请你讲一下linux子系统" class="headerlink" title="请你讲一下linux子系统"></a>请你讲一下linux子系统</h3><p>Linux 系统为了统一管理这些输入设备，实现了一套能够兼容所有输入设备的框架。驱动开发人员基于 input 子系统开发输入设备的驱动程序，input 子系统可以屏蔽硬件的差异，向应用层提供一套统一的接口。基于 input 子系统注册成功的输入设备，都会在&#x2F;dev&#x2F;input 目录下生成对应的设备节点（设备文件），设备节点名称通常为 eventX（X 表示一个数字编号 0、1、2、3 等），譬如&#x2F;dev&#x2F;input&#x2F;event0、&#x2F;dev&#x2F;input&#x2F;event1、&#x2F;dev&#x2F;input&#x2F;event2 等，通过读取这些设备节点可以获取输入设备上报的数据。<br>input 子系统分为 input 驱动层、input 核心层、input 事件处理层，最终给用户空间提供可访问的设备节点，图中左边就是最底层的具体设备，比如按键、USB 键盘&#x2F;鼠标等，中间部分属于Linux 内核空间，分为驱动层、核心层和事件层，最右边的就是用户空间，所有的输入设备以文件的形式供用户应用程序使用。 input 子系统用到了驱动分层模型，编写驱动程序的时候只需要关注中间的驱动层、核心层和事件层，这三个层的分工如下：驱动层：输入设备的具体驱动程序，比如按键驱动程序，向内核层报告输入内容。核心层：承上启下，为驱动层提供输入设备注册和操作接口。通知事件层对输入事件进行处理。事件层：主要和用户空间进行交互。</p><h3 id="请你讲一下linux字符设备驱动流程？"><a href="#请你讲一下linux字符设备驱动流程？" class="headerlink" title="请你讲一下linux字符设备驱动流程？"></a>请你讲一下linux字符设备驱动流程？</h3><p>设备初始化：在系统启动时初始化硬件设备，配置设备的寄存器、中断等。设备注册：将设备注册到内核的设备管理框架中，使其能够被用户空间程序访问。数据传输：处理用户空间程序对设备的读写操作，将数据从用户空间传输到硬件设备，或从硬件设备传输到用户空间。中断处理：处理设备产生的中断信号，响应设备的事件（如键盘按键、鼠标移动等）。设备关闭：在设备不再使用时，释放资源并关闭设备。<br>请简述主设备号和次设备号的用途？<br>主设备号用途   标识设备类型：用于区分不同种类的设备驱动程序，同一类设备具有相同的主设备号。例如，所有的硬盘设备可能共享一个特定的主设备号，而所有的串口设备有另一个主设备号，系统通过主设备号能快速定位到对应的设备驱动程序。建立驱动关联：内核利用主设备号来查找和调用相应的设备驱动程序，当设备进行读写等操作时，内核依据主设备号找到对应的驱动入口点，从而实现对设备的控制和操作。<br>次设备号用途   区分同类设备：在同一类设备中，用于区分不同的具体设备实例。比如系统中有多个硬盘，每个硬盘通过不同的次设备号来标识，以便系统对它们进行单独的管理和操作，如分别对不同硬盘进行分区、格式化等。实现设备定制：可以用于指定设备的特定属性或功能变体。例如，某些设备可能有不同的工作模式或配置选项，次设备号可以用来区分这些不同的情况，使驱动程序能够根据次设备号执行不同的操作或提供不同的功能。<br>示例：假设我们有一个字符设备驱动程序，用于管理多个串行端口设备。这些设备的主设备号为 4，次设备号从 64 开始，每个串行端口分配一个次设备号：&#x2F;dev&#x2F;ttyS0：主设备号为 4，次设备号为 64 ，&#x2F;dev&#x2F;ttyS1：主设备号为 4，次设备号为 65，&#x2F;dev&#x2F;ttyS2：主设备号为 4，次设备号为 66</p><h3 id="假设触摸屏设备对应的设备节点为-dev-input-event0，如何读取屏幕设备数据？"><a href="#假设触摸屏设备对应的设备节点为-dev-input-event0，如何读取屏幕设备数据？" class="headerlink" title="假设触摸屏设备对应的设备节点为&#x2F;dev&#x2F;input&#x2F;event0，如何读取屏幕设备数据？"></a>假设触摸屏设备对应的设备节点为&#x2F;dev&#x2F;input&#x2F;event0，如何读取屏幕设备数据？</h3><p>1、应用程序打开&#x2F;dev&#x2F;input&#x2F;event0 设备文件；<br>2、应用程序发起读操作（譬如调用 read），如果没有数据可读则会进入休眠（阻塞 I&#x2F;O 情况下）；<br>3、当有数据可读时，应用程序会被唤醒，读操作获取到数据返回；<br>4、应用程序对读取到的数据进行解析。当无数据可读时，程序会进入休眠状态（也就是阻塞），譬如应用程序读触摸屏数据，如果当前并没有去触碰触摸屏，自然是无数据可读；当我们用手指触摸触摸屏或者在屏上滑动时，此时就会产生触摸数据、应用程序就有数据可读了，应用程序会被唤醒，成功读取到数据。那么对于其它输入设备亦是如此，无数据可读时应用程序会进入休眠状态（阻塞式 I&#x2F;O 方式下），当有数据可读时才会被唤醒。</p><h3 id="什么是原子操作？原子操作的特点？"><a href="#什么是原子操作？原子操作的特点？" class="headerlink" title="什么是原子操作？原子操作的特点？"></a>什么是原子操作？原子操作的特点？</h3><p>原子操作（Atomic Operation）是指一个不可分割的操作，它在执行过程中不会被其他操作中断。换句话说，原子操作要么完全执行，要么完全不执行，中间状态不会被其他线程或进程观察到。特点  不可分割性：原子操作在执行过程中不会被中断。这意味着在操作开始之前和操作完成之后，系统状态是稳定的，但在操作执行过程中，系统状态对其他线程或进程是不可见的。  线程安全：由于原子操作的不可分割性，它通常用于实现线程安全的操作，避免多线程环境下的竞态条件（Race Condition）和数据不一致问题。</p><h3 id="驱动设备节点保存在哪个目录"><a href="#驱动设备节点保存在哪个目录" class="headerlink" title="驱动设备节点保存在哪个目录"></a>驱动设备节点保存在哪个目录</h3><p>驱动设备节点保存在&#x2F;dev目录下。在Linux系统中，所有的设备节点都保存在&#x2F;dev目录下，设备节点的文件名通常以字母“dev”开头，其余部分用于标识设备类型和设备号等信息。设备节点可以被用于读取和写入设备数据，同时也可以用于与设备进行交互。在驱动程序中，通过打开设备节点文件可以获得设备的文件描述符，从而进行对设备的操作。</p><h3 id="linux中怎么查看系统性能"><a href="#linux中怎么查看系统性能" class="headerlink" title="linux中怎么查看系统性能"></a>linux中怎么查看系统性能</h3><p>Linux下常用的查看系统性能的命令有以下几个： top：查看系统运行进程及其资源占用情况，可以实时更新显示。 vmstat：查看系统的内存、磁盘、CPU 等资源的使用情况和进程信息。 iostat：查看磁盘 I&#x2F;O 活动情况，显示磁盘读写速度、磁盘利用率等信息。 sar：系统活动报告，可以查看 CPU、内存、磁盘、网络等性能指标历史记录。 netstat：查看网络连接状态、网络接口的状态和统计信息。 ifconfig：查看网络接口的配置信息，包括 IP 地址、MAC 地址等。 free：查看内存使用情况，包括内存总量、空闲内存、已用内存等。 这些命令在排查系统性能问题、优化系统性能方面非常有用，嵌入式开发中同样可以使用。</p><h3 id="什么是-CLI？GUI？"><a href="#什么是-CLI？GUI？" class="headerlink" title="什么是 CLI？GUI？"></a>什么是 CLI？GUI？</h3><p>CLI：命令行界面（command-line interface，简称 CLI）是在图形用户界面得到普及之前使用最为广泛的用户界面。     GUI：图形用户界面（Graphical User Interface，简称 GUI，又称图形用户接口）是指采用图形方式显示的计算机操作用户界面。</p><h3 id="什么是硬链接和软链接？"><a href="#什么是硬链接和软链接？" class="headerlink" title="什么是硬链接和软链接？"></a>什么是硬链接和软链接？</h3><p>硬链接：由于 Linux 下的文件是通过索引节点(inode)来识别文件，硬链接可以认为是一个指针，指向文件索引节点的指针，系统并不为它重新分配 inode 。每添加一个一个硬链接，文件的链接数就加 1 。<br>不足：1）不可以在不同文件系统的文件间建立链接；2）只有超级用户才可以为目录创建硬链接。<br>软链接：软链接克服了硬链接的不足，没有任何文件系统的限制，任何用户可以创建指向目录的符号链接。因而现在更为广泛使用，它具有更大的灵活性，甚至可以跨越不同机器、不同网络对文件进行链接。<br>不足：因为链接文件包含有原文件的路径信息，所以当原文件从一个目录下移到其他目录中，再访问链接文件，系统就找不到了，而硬链接就没有这个缺陷，你想怎么移就怎么移；还有它要系统分配额外的空间用于建立新的索引节点和保存原文件的路径。<br>实际场景下，基本是使用软链接。总结区别如下：</p><ol><li>硬链接不可以跨分区，软件链可以跨分区； </li><li>硬链接指向一个 inode 节点，而软链接则是创建一个新的 inode 节点；  </li><li>删除硬链接文件，不会删除原文件，删除软链接文件，会把原文件删除。</li></ol><h3 id="echo-CC-的CC是什么？"><a href="#echo-CC-的CC是什么？" class="headerlink" title="echo ${CC} 的CC是什么？"></a>echo ${CC} 的CC是什么？</h3><p>echo ${CC} 中的CC 是个环境变量，一个大交叉编译工具    所以一般     ${CC} -o test test.c   可以编译出ARM文件，类似于gcc</p><h3 id="argc和argv参数"><a href="#argc和argv参数" class="headerlink" title="argc和argv参数"></a>argc和argv参数</h3><p>argc 表示的是命令行中参数的个数，argv 表示的是命令行中的参数</p><h3 id="文件IO和标准IO的区别"><a href="#文件IO和标准IO的区别" class="headerlink" title="文件IO和标准IO的区别"></a>文件IO和标准IO的区别</h3><p>文件IO就是直接调用内核提供的系统调用函数。标准IO就是间接调用系统调用函数，是C库函数。<br>文件IO是直接调用内核提供的系统调用函数，头文件是unistd.h，标准IO是间接调用系统调用函数，头文件是stdio.h。<br>文件IO是依赖于Linux操作系统的，标准IO是不依赖操作系统的，所以在任何的操作系统下，使用标准IO，也就是C库函数操作文件的方法都是相同的。<br>标准IO围绕流操作   文件IO围绕文件描述符。</p><h3 id="存储映射这种高级I-O和普通I-O的区别？"><a href="#存储映射这种高级I-O和普通I-O的区别？" class="headerlink" title="存储映射这种高级I&#x2F;O和普通I&#x2F;O的区别？"></a>存储映射这种高级I&#x2F;O和普通I&#x2F;O的区别？</h3><p>当数据量比较大时，普通 I&#x2F;O 方式效率较低。此时可以通过 mmap()将显示器的显示缓冲区（显存）映射到进程的地址空间中，这样应用程序便可直接对显示缓冲区进行读写操作，经典应用像LCD屏幕的Framebuffer编程当中。</p><h3 id="什么是库？"><a href="#什么是库？" class="headerlink" title="什么是库？"></a>什么是库？</h3><p>库是一种可执行的二进制文件，是编译好的代码，使用库可以提高开发效率。Linux库种类：静态库、动态库。静态库。<br>静态库在程序编译的时候会被链接到目标代码里面，所以程序运行时就不再需要该静态库了，因此编译出来的体积比较大，静态库以lib开头，以.a结尾。<br>静态库制作步骤：<br>1、编写或准备库的源代码<br>2、将源码 .c文件编译生成 .o 文件（ gcc -c  文件.c）<br>3、使用ar命令创建静态库 ar cr libmylib.a  mylib.o  其中cr：c为创建  r为覆盖，指定.o文件<br>4、测试库文件。静态库使用： gcc test.c -lmylib -L .   其中 ： -l 指定静态库的库名  -L 指定在哪个目录下去查找  -L  .  表示在当前目录下去查找<br>动态库（共享库）在程序编译的时候不会被链接到目标代码里面，而是在程序运行时被载入，所以程序运行时就需要该静态库了，因此编译出来体积比较小，动态库以lib开头，以 .so结尾。<br>动态库制作步骤：<br>1、编写或准备库的源代码<br>2、将源码 .c文件编译生成 .o 文件（ gcc -c -fpic  文件.c）<br>3、使用gcc命令创建动态库  gcc -shared -o libmylib.so mylib.o<br>4、测试库文件。动态库使用：gcc  test.c  -lmylib  -L .  系统默认会在&#x2F;lib 和  &#x2F;usr&#x2F;lib中去找库文件，没有则会报错。<br>报错解决方案：<br>1、将生成的动态库拷贝到&#x2F;lib或者&#x2F;usr&#x2F;lib中去 （不建议）<br>2、pwd查看当前路径。环境变量中添加动态库所在路径  export LD_LIBRARY_PATH&#x3D;$LD_LIBARARY_PATH：路径<br>3、修改ubuntu下的配置文件&#x2F;etc&#x2F;ld.so.conf ，在其中加入动态库所在位置，然后使用 ldconfig 更新目录</p><h3 id="操作系统调度策略有哪些？"><a href="#操作系统调度策略有哪些？" class="headerlink" title="操作系统调度策略有哪些？"></a>操作系统调度策略有哪些？</h3><p>1、先来先服务（First-Come, First-Served，FCFS）：按照进程到达的顺序进行调度，先到达的进程先执行。<br>2、短作业优先（Shortest Job Next，SJN）：选择估计执行时间最短的进程优先执行，以减少平均等待时间。<br>3、优先级调度：为每个进程分配一个优先级，根据优先级决定下一个要执行的进程。可以是静态优先级，在创建时指定；也可以是动态优先级，在运行过程中动态改变。<br>4、时间片轮转（Round Robin，RR）：将CPU时间划分为固定大小的时间片，每个进程按照时间片轮流使用CPU。当时间片用完后，当前正在执行的进程会被挂起，并放回就绪队列末尾。<br>5、多级反馈队列调度：将就绪队列划分为多个队列，每个队列具有不同的优先级。新到达的进程首先被放入高优先级队列，如果没有其他可运行的高优先级任务，则低优先级队列中的任务得到执行机会。任务在同一队列中按照时间片轮转方式执行。<br>6、最短剩余时间（Shortest Remaining Time Next，SRTN）：在短作业优先的基础上，根据当前剩余执行时间来动态调整执行顺序，以进一步减少等待时间。</p><h3 id="逻辑地址、线性地址、物理地址、总线地址、虚拟地址有什么区别？"><a href="#逻辑地址、线性地址、物理地址、总线地址、虚拟地址有什么区别？" class="headerlink" title="逻辑地址、线性地址、物理地址、总线地址、虚拟地址有什么区别？"></a>逻辑地址、线性地址、物理地址、总线地址、虚拟地址有什么区别？</h3><p>1、逻辑地址：与内存段相关的偏移地址部分。例如，在C语言获取指针变量的值，就是逻辑地址，不和绝对的物理地址相关。<br>2、线性地址：线性地址 &#x3D; 逻辑地址 + 基地址。<br>3、物理地址：如果启用了分页机制，那么线性地址使用页表项变换后就是物理地址。如果没有启用分页机制，那么线性地址就是物理地址。<br>4、总线地址：x86下的I&#x2F;O地址，ARM下的物理地址。（在x86下，外设的I&#x2F;O地址是独立的，即有专门的指令访问外设I&#x2F;O，I&#x2F;O地址就是&amp;quot;总线地址&amp;quot;，而RAM地址就是&amp;quot;物理地址&amp;quot;。在ARM下，I&#x2F;O和RAM统一编址，但linux为了统一各个平台，仍然保留这个概念，总线地址其实就是物理地址。）<br>5、虚拟地址：MMU虚拟出来的地址。</p><h3 id="你了解操作系统的内存分配方式吗？"><a href="#你了解操作系统的内存分配方式吗？" class="headerlink" title="你了解操作系统的内存分配方式吗？"></a>你了解操作系统的内存分配方式吗？</h3><p>1、分页存储管理：优点是不需要连续的内存空间，且内存利用率高（只有很小的页内碎片）；缺点是不易于实现内存共享与保护。<br>2、分段存储管理：优点是易于实现段内存共享和保护；缺点是每段都需要连续的内存空间，且内存利用率较低（会产生外部碎片）。<br>3、段页式存储管理：优点是不需要连续的内存空间，内存利用率高（只有很小的页内碎片），且易于实现段内存共享和保护；缺点是管理软件复杂性较高，需要的硬件以及占用的内存也有所增加，使得执行速度下降。</p><h3 id="解释一下Linux中的apt-get命令和yum命令的区别是什么？"><a href="#解释一下Linux中的apt-get命令和yum命令的区别是什么？" class="headerlink" title="解释一下Linux中的apt-get命令和yum命令的区别是什么？"></a>解释一下Linux中的apt-get命令和yum命令的区别是什么？</h3><p>apt-get是Debian系列Linux发行版的包管理工具。apt-get基于Debian的包管理机制，适用于Debian和Ubuntu系统，这些系统使用.deb的软件包。软件源配置文件位于&#x2F;etc&#x2F;apt&#x2F;sources.list。<br>yum则基于RPM包管理机制，主要用于基于Red Hat的系统，如 CentOS、Fedora、RHEL等，这些系统使用.rpm格式的软件包。软件源配置文件位于&#x2F;etc&#x2F;yum.repos.d&#x2F;目录中的.repo 文件。</p><h3 id="请你说一下进程与线程的概念，以及它们的区别"><a href="#请你说一下进程与线程的概念，以及它们的区别" class="headerlink" title="请你说一下进程与线程的概念，以及它们的区别"></a>请你说一下进程与线程的概念，以及它们的区别</h3><p>进程是对运行时程序的封装，是操作系统进行资源分配的的基本单位，实现了操作系统的并发；一个进程最多可以打开1024个文件（ulimit -n默认最多打开的文件数量，ulimit -s 最大栈尺寸，ulimit -u用户最大启动进程数）。每个进程都有一个唯一的标识符 ，pid。<br>线程是进程的子任务，是CPU 调度和分派的基本单位，用于保证程序的实时性，实现进程内部的并发；每个线程都独自占用一个虚拟处理器： 独自的寄存器组，指令计数器和处理器状态。每个线程完成不同的任务，但是共享同一地址空间（也就是同样的动态内存，映射文件，目标代码等等），打开的文件队列和其他内核资源。<br>区别：<br>1、一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。<br>2、进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。（资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量）， 数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。）<br>3、进程是资源分配的最小单位，线程是CPU 调度的最小单位；<br>4、系统开销：由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I&#x2F;O设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。类似地，在进行进程切换时，涉及到整个当前进程CPU 环境的保存以及新被调度运行的进程的CPU 环境的设置。而线程切换只须保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作。进程与线程最大的区别在于上下文切换过程中，线程不用切换虚拟内存，因为同一个进程内的线程都是共享虚拟内存空间的，线程就单这一点不用切换，就相比进程上下文切换的性能开销减少了。<br>5、进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快， 但是编程调试相对复杂。<br>6、进程间不会相互影响 ；线程一个线程挂掉将导致整个进程挂掉<br>7、进程适应于多核、多机分布；线程适用于多核</p><h3 id="进程间通信有哪些方式？"><a href="#进程间通信有哪些方式？" class="headerlink" title="进程间通信有哪些方式？"></a>进程间通信有哪些方式？</h3><p>1、管道（Pipe）<br>管道是一种在父子进程或者兄弟进程之间进行通信的简单而有效的方式。管道分为无名管道（Pipe）和有名管道（FIFO）。<br>无名管道只能用于具有亲缘关系的进程之间通信（只能通过 fork 来复制父进程 fd 文件描述符，来达到通信的目的），而有名管道可以用于任意进程之间的通信。<br>无名管道通过 pipe() 系统调用创建，有两个文件描述符，分别代表管道的读端和写端。有名管道则通过 mkfifo() 函数创建，可以在文件系统中持久存在。<br>2、消息队列（Message Queue）<br>消息队列允许不同进程之间通过消息进行通信。它基于内核对象，是保存在内核中的消息链表，并按照一定的规则被发送和接收。发送消息时，指定消息队列标识符和消息类型，接收消息时，可以根据消息类型进行选择性接收。消息队列提供了一种异步的通信机制，适用于实现高效、可靠的进程间通信。消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销，不适合比较大数据的传输。<br>3、信号量（Semaphore）<br>信号量是一种用于进程间同步和互斥的机制，而不是用于缓存进程间通信的数据。可以通过控制对临界资源的访问来实现进程之间的协调。信号量可以是计数器或者二进制（互斥）信号量，通过 sem_init()、sem_wait() 和 sem_post() 等函数来进行操作。计数器信号量用于控制资源的数量，而二进制信号量用于实现互斥访问共享资源。<br>4、信号<br>信号是一种比较复杂的通信方式，是进程间通信机制中唯一的异步通信机制，用于通知接收进程某个事件已经发生，对于异常情况下的工作模式，就需要用「信号」的方式来通知进程。<br>信号的处理：系统默认、忽略、捕获。 kill -l 用于查看所有的信号。<br>5、共享内存（Shared Memory）<br>共享内存是一种高效的进程间通信方式，允许多个进程共享同一块内存区域。通过将内存区域映射到多个进程的地址空间，不同进程可以直接读写共享内存中的数据，而无需进行复制。共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中。共享内存通常配合信号量或其他同步机制一起使用，以确保多个进程之间的数据一致性和安全性。<br>6、套接字（Socket）<br>套接字是一种通用的进程间通信机制，不仅可以用于网络通信，还可以用于本地进程间通信。套接字通信基于网络协议，提供了可靠、灵活的数据传输方式。在本地通信中，套接字可以用于不同进程之间的通信，实现进程间数据交换和协作。</p><h3 id="线程间通信有哪些方式？"><a href="#线程间通信有哪些方式？" class="headerlink" title="线程间通信有哪些方式？"></a>线程间通信有哪些方式？</h3><p>线程间通信有四种方式，分别为邮箱、消息队列、信号、全局变量。<br>1、邮箱：<br>开销比较低，效率比较高，邮箱中的每一封邮件只能容纳固定的4字节内容、指针地址；<br>一个线程能够从任意一个邮箱接收和发送邮件；<br>多个线程能够向同一个邮箱发送邮件和从中接收邮件<br>2、消息队列<br>是邮箱的扩展，比邮箱更方便，可传输不定长消息<br>3、信号<br>软中断信号-&gt;是对硬件中断机制的一种模拟，用来通知线程发生了异步事件，用作线程之间的异常通知、应急处理<br>4、全局变量<br>多个线程使用同一个全局变量，如果不互斥，那么存在抢占；<br>全局变量太多，代码很难维护，可读性变差，有可能存在未知问题；<br>代码之间耦合度过高，不分层。</p><h3 id="线程同步机制的实现方式有哪些？"><a href="#线程同步机制的实现方式有哪些？" class="headerlink" title="线程同步机制的实现方式有哪些？"></a>线程同步机制的实现方式有哪些？</h3><p>1、锁机制<br>互斥锁（Mutex）：互斥锁是一种用于保护临界区的同步机制，它确保同一时刻只有一个线程能够进入临界区执行代码，从而避免多个线程同时访问共享资源而导致的数据竞争和错误。<br>读写锁（Reader-Writer Lock）： 读写锁允许多个线程同时读取共享资源，但只允许一个线程写入共享资源。这种机制适用于读操作频繁而写操作较少的场景，可以提高程序的并发性能。<br>2、条件变量（Condition Variable）：一种用于线程间等待和通知的机制，允许线程等待某个条件达成后再继续执行。条件变量通常与互斥锁配合使用，以确保线程在等待和通知的过程中能够安全地访问共享资源。<br>3、信号量（Semaphore）：类似于进程间通信中的信号量，信号量允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。线程间信号量可以用于实现互斥和同步，确保多个线程之间的协同工作。<br>4、事件：允许线程等待某个事件的发生后再继续执行。事件通常分为自动重置事件和手动重置事件两种类型。自动重置事件在被等待线程被唤醒后会自动重置为未触发状态，而手动重置事件需要显式地调用重置函数来重置为未触发状态。</p><h3 id="进程的三种基本状态及转换"><a href="#进程的三种基本状态及转换" class="headerlink" title="进程的三种基本状态及转换?"></a>进程的三种基本状态及转换?</h3><p>在一个进程的活动期间至少具备三种基本状态，即运行状态、就绪状态、阻塞状态。<br>运行状态：(Running):该时刻进程占用CPU；<br>就绪状态(Ready)：可运行，由于其他进程处于运行状态而暂时停止运行；<br>阻塞状态(Blocked)：该进程正在等待某一事件发生(如等待输入&#x2F;输出操作的完成)而暂时停止运行，这时，即使给它CPU控制权，它也无法运行。<br>进程还有另外两个基本状态：创建状态(new)进程正在被创建时的状态。  结束状态(Exit):进程正在从系统中消失时的状态。</p><h3 id="线程的实现？"><a href="#线程的实现？" class="headerlink" title="线程的实现？"></a>线程的实现？</h3><p>用户线程(User Thread)：在用户空间实现的线程，不是由内核管理的线程，是由用户态的线程库来完成线程的管理；<br>内核线程(Kernel Thread):在内核中实现的线程，是由内核管理的线程；轻量级进程(LightWeight Process):在内核中来支持用户线程。</p><h3 id="线程的上下文切换的是什么"><a href="#线程的上下文切换的是什么" class="headerlink" title="线程的上下文切换的是什么?"></a>线程的上下文切换的是什么?</h3><p>当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据。如果锁住的代码执行时间比较短，那可能上下文切换的时间都比你锁住的代码执行时间还要长。所以，如果被锁住的代码执行时间很短，就应该选用自旋锁，否则使用互斥锁。自旋锁是通过 CPU 提供的 cAs 函数(Compare And swap)，在「用户态」完成加锁和解锁操作，不会主动产生线程上下文切换，所以相比互斥锁来说，会快一些，开销也小一些。</p><h3 id="线程崩溃，进程一定会崩溃吗？"><a href="#线程崩溃，进程一定会崩溃吗？" class="headerlink" title="线程崩溃，进程一定会崩溃吗？"></a>线程崩溃，进程一定会崩溃吗？</h3><p>一般来说如果线程是因为非法访问内存引起的崩溃，那么进程肯定会崩溃，因为在进程中，各个线程的地址空间是共享的，既然是共享，那么某个线程对地址的非法访问就会导致内存的不确定性，进而可能会影响到其他线程，这种操作是危险的，操作系统会认为这很可能导致一系列严重的后果，于是干脆让整个进程崩溃。</p><h3 id="用户线程如何理解？存在什么优势和缺陷？"><a href="#用户线程如何理解？存在什么优势和缺陷？" class="headerlink" title="用户线程如何理解？存在什么优势和缺陷？"></a>用户线程如何理解？存在什么优势和缺陷？</h3><p>用户线程是基于用户态的线程管理库来实现的，那么线程控制块(Thread control Block,TCB)也是在库里面来实现的，对于操作系统而言是看不到这个 TCB 的，它只能看到整个进程的 PCB（进程控制块）。所以，用户线程的整个线程管理和调度，操作系统是不直接参与的，而是由用户级线程库函数来完成线程的管理，包括线程的创建、终止、同步和调度等。</p><h3 id="死锁的四个必要条件是什么？如何预防死锁的发生？"><a href="#死锁的四个必要条件是什么？如何预防死锁的发生？" class="headerlink" title="死锁的四个必要条件是什么？如何预防死锁的发生？"></a>死锁的四个必要条件是什么？如何预防死锁的发生？</h3><p>1、互斥条件（Mutual Exclusion）：至少有一个资源被排他性地分配给一个进程或线程，即在一段时间内只能由一个进程或线程使用。其他进程或线程需要等待该资源释放。<br>2、请求与保持条件（Hold and Wait）：一个进程或线程在持有某些资源的同时又请求其他资源，而这些请求的资源已被其他进程或线程占用。当多个进程互相持有一些资源并且正在等待其他进程所拥有的资源时，就可能发生死锁。<br>3、不可剥夺条件（No Preemption）：已经分配给一个进程或线程的资源不能强制性地被收回，只能由持有者自愿释放。换句话说，任何一个已经获取到的资源无法被强制性地抢占。<br>4、循环等待条件（Circular Wait）：存在一组进程或线程，每个进程都在等待下一个进程所拥有的资源，形成了循环依赖关系。例如，P1等待P2的资源，P2等待P3的资源，而P3又等待P1的资源。<br>如果以上四个条件同时满足，并且没有外部干预来打破其中之一，则会导致死锁状态发生。因此，在设计并发系统时，需要避免死锁的发生或者采取相应策略来解除死锁状态，即破坏上述条件之一。</p><h3 id="虚拟内存有什么作用？"><a href="#虚拟内存有什么作用？" class="headerlink" title="虚拟内存有什么作用？"></a>虚拟内存有什么作用？</h3><p>1、大大扩展了电脑内存容量。通过利用硬盘空间，创建比物理内存更大的虚拟地址空间。这使得系统在物理内存资源有限的情况下，仍能保持高效运行。<br>2、提高多任务处理速度。将不常用的数据存储在硬盘上，从而释放出更多内存，分配至其他任务。即使在高负载环境下，系统也能保持良好的响应速度和稳定性。<br>3、增强系统稳定性。它隔离每个进程的内存空间，防止其中一个或多个进程的错误对其他进程产生影响，在一定程度上避免了程序崩溃或系统卡顿。</p><h3 id="乐观锁与悲观锁？"><a href="#乐观锁与悲观锁？" class="headerlink" title="乐观锁与悲观锁？"></a>乐观锁与悲观锁？</h3><p>互斥锁、自旋锁、读写锁，都是属于悲观锁。悲观锁做事比较悲观，它认为多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁。         乐观锁做事比较乐观，它假定冲突的概率很低，它的工作方式是：先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作。放弃后如何重试，这跟业务场景息息相关，虽然重试的成本很高，但是冲突的概率足够低的话，还是可以接受的。乐观锁全程并没有加锁，所以它也叫无锁编程。</p><h3 id="Linux-中断处理？"><a href="#Linux-中断处理？" class="headerlink" title="Linux 中断处理？"></a>Linux 中断处理？</h3><p>为了避免由于中断处理程序执行时间过长，而影响正常进程的调度，Linux 将中断处理程序分为上半部和下半部：<br>上半部，对应硬中断，由硬件触发中断，打断 CPU 正在执行的任务，然后立即执行中断处理程序;<br>下半部，对应软中断，由内核以线程方式触发中断，每一个 CPU 都对应一个软中断内核线程，名字通常为[ksoftirgd&#x2F;CPU 编号]，比如0号 CPU 对应的软中断内核线程的名字是 ksoftirgd&#x2F;0，用来异步处理上半部未完成的工作;<br>Linux中的软中断包括网络收发、定时、调度、RCU 锁等各种类型，可以通过cat &#x2F;proc&#x2F;softirqs 来观察软中断的累计中断次数情况。<br>如果要实时査看中断次数的变化率，可以使用watch -d cat &#x2F;proc&#x2F;softirgs命令。每一个CPU都有各自的软中断内核线程，可以用 ps 命令来查看内核线程，一般名字在中括号里面到，都认为是内核线程。<br>如果在top命令发现，CPU 在软中断上的使用率比较高，而且CPU使用率最高的进程也是软中断ksoftirgd 的时候，这种一般可以认为系统的开销被软中断占据了。此时可以分析是哪种软中断类型导致的，一般来说是因为网络接收软中断导致的，如果是的话可以用sar命令査看是哪个网卡的有大量的网络包接收，再用tcpdump抓网络包，做进一步分析该网络包的源头是不是非法地址，如果是就要考虑防火墙增加规则，如果不是，则考虑硬件升级等。</p><h3 id="硬盘比内存慢很多是为什么？"><a href="#硬盘比内存慢很多是为什么？" class="headerlink" title="硬盘比内存慢很多是为什么？"></a>硬盘比内存慢很多是为什么？</h3><p>CPU Cache (CPU高速缓存)用的是一种叫 SRAM(Static Random-Access Memory，静态随机存储器)的芯片，通常会分为 L1、L2、L3 三层，其中 L1 Cache 通常分成「数据缓存」和「指令缓存」，L1 是距离 CPU 最近的，因此它比 L2、L3 的读写速度都快、存储空间都小。我们大脑中短期记忆，就好比 L1Cache，而长期记忆就好比 L2&#x2F;L3 Cache。SRAM之所以叫【静态】存储器，因为它只要有电，数据就可以保持存在，而一旦断电，数据就会丢失在 SRAM 里面，一个 bit 的数据，通常需要6个品体管，所以 SRAM 的存储密度不高，同样的物理空间下，能存储的数据是有限的，不过也因为 SRAM 的电路简单，所以访问速度非常快。<br>内存用的芯片和 CPU Cache 有所不同，”它使用的是一种叫作 DRAM(Dynamic Random AccessMemory，动态随机存取存储器)的芯片。相比 SRAM，DRAM 的密度更高，功耗更低，有更大的容量，而且造价比 SRAM 芯片便宜很多。DRAM 存储一个 bit 数据，只重要一个晶体管和一个电容就能存储，但是因为数据会被存储在电容里，电容会不断漏电，所以需要「定时刷新」电容，才能保证数据不会被丢失，这就是 DRAM 之所以被称为「动态」存储器的原因，只有不断刷新，数据才能被存储起来。DRAM 的数据访问电路和刷新电路都比 SRAM 更复杂，所以访问的速度会更慢，内存速度大概在200~300 个时钟周期之间。<br>SSD&#x2F;HDD硬盘。SSD就是我们常说的固体硬盘，结构和内存类似，但是它相比内存的优点是断电后数据还是存在的，而内存、寄存器、高速缓存断电后数据都会丢失。内存的读写速度比 SSD 大概快10-1000 倍。当然，还有一款传统的硬盘，也就是机械硬盘(HDD)，它是通过物理读写的方式来访问数据的，因此它访问速度是非常慢的，它的速度比内存慢10w倍左右。</p><h3 id="什么是交叉编译"><a href="#什么是交叉编译" class="headerlink" title="什么是交叉编译 ?"></a>什么是交叉编译 ?</h3><p>在一种计算机环境中运行的编译程序，能编译出在另外一种环境下运行的代码，我们就称这种编译器支持交叉编译。这个编译过程就叫交叉编译。简单地说，就是在一个平台上生成另一个平台上的可执行代码。这里需要注意的是所谓平台，实际上包含两个概念：体系结构（Architecture）、操作系统（OperatingSystem）。同一个体系结构可以运行不同的操作系统；同样，同一个操作系统也可以在不同的体系结构上运行。举例来说，我们常说的x86 Linux平台实际上是Intel x86体系结构和Linux for x86操作系统的统称；而x86 WinNT平台实际上是Intel x86体系结构和Windows NT for x86操作系统的简称。</p><h3 id="为什么需要交叉编译？"><a href="#为什么需要交叉编译？" class="headerlink" title="为什么需要交叉编译？"></a>为什么需要交叉编译？</h3><p>有时是因为目的平台上不允许或不能够安装我们所需要的编译器，而我们又需要这个编译器的某些特征；有时是因为目的平台上的资源贫乏，无法运行我们所需要编译器，只发送可执行代码；有时又是因为目的平台还没有建立，连操作系统都没有，根本谈不上运行什么编译器。<br>如何实现？  .&#x2F;configure 配库，像opengl、gstreamer;  make;  make install</p><h3 id="SoC出现段错误，如何快速定位到故障函数？"><a href="#SoC出现段错误，如何快速定位到故障函数？" class="headerlink" title="SoC出现段错误，如何快速定位到故障函数？"></a>SoC出现段错误，如何快速定位到故障函数？</h3><p>出现段错误的原因：访问空指针或未初始化的指针；指针越界访问；栈溢出（如递归过深或局部变量过大）；动态内存释放后再次访问。<br>排查错误：使用调试工具（如GDB、Valgrind）找出崩溃点；结合硬件相关特性（如寄存器地址）分析原因；采用动态和静态分析工具排查潜在问题；优化代码结构和测试环境，防止类似问题再次发生。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C/Cpp</title>
    <link href="/2025/05/05/c&amp;cpp/"/>
    <url>/2025/05/05/c&amp;cpp/</url>
    
    <content type="html"><![CDATA[<h2 id="C-Cpp语法"><a href="#C-Cpp语法" class="headerlink" title="C&#x2F;Cpp语法"></a>C&#x2F;Cpp语法</h2><h3 id="c编译到执行的4个阶段"><a href="#c编译到执行的4个阶段" class="headerlink" title="c编译到执行的4个阶段"></a>c编译到执行的4个阶段</h3><p>在C语言编译运行的过程中，可以分为4个主要的阶段，包括预处理、编译、汇编和链接。<br>预处理阶段（Preprocessing）：在预处理阶段，编译器会处理源文件，包括展开宏定义、头文件的展开、条件编译等，生成一个经过预处理后的文本文件。此阶段的结果是一个以 .i 为扩展名的文件。<br>编译阶段（Compilation）：在编译阶段，编译器将经过预处理的文本文件翻译成汇编代码。汇编代码是一种低级的、与机器相关的语言。此阶段的结果是一个以 .s 为扩展名的文件。<br>汇编阶段（Assembly）：在汇编阶段，汇编器将汇编代码转换成机器可以执行的指令（机器语言，目标文件是二进制文件）。此阶段的结果是一个以 .o 为扩展名的文件。Keil5 ，.obj<br>链接阶段（Linking）：在链接阶段，链接器将多个目标文件和库文件进行链接，生成可执行文件。此阶段的结果是一个没有扩展名的可执行文件。链接器解析目标文件的符号引用，将其与符号定义进行关联，还会进行地址重定位、符号解析等操作。</p><h3 id="C／C-程序-内存分布情况常量所在的区"><a href="#C／C-程序-内存分布情况常量所在的区" class="headerlink" title="C／C++程序 内存分布情况常量所在的区"></a>C／C++程序 内存分布情况常量所在的区</h3><p>C&#x2F;C++程序内存分布情况通常可以分为以下几个区域：</p><ul><li>代码区（text segment）：存放程序执行代码的区域，text文本区存放程序的二进制代码（机器指令）。代码区不仅包含程序的执行代码，还可能包含字符串常量（如 “Hello”），该区域的内容在程序执行时不能被修改。</li><li>全局区（静态区）（static）全局变量和静态变量的存储是放在一块的。分为bss区和data区。常量一般位于代码区或数据区，不同编译器可能有不同的实现。在代码区中，通常存放的是字符串常量和只读变量；在数据区中，通常存放的是已初始化的全局变量、静态变量和常量。<ul><li>数据区（data segment）：存放已经初始化的全局变量和静态变量（包括全局和静态变量的指针、包括常量）的区域。</li><li>BSS区（bss segment）：存放未初始化的全局变量和静态变量的区域，不占用可执行文件的空间，仅在程序加载时分配内存，与数据区不同的是，BSS 区不存储具体的值，只记录变量所需的空间大小，该区域的值默认初始化为0，程序结束后由系统释放。</li></ul></li><li>栈区（stack segment）：存放函数调用时的局部变量、函数调用传递的参数和函数返回地址等信息。栈空间是由操作系统自动分配和回收的，它的大小通常是固定的，不能随意增加，程序运行时由编译器需要的时候分配，不需要的时候清除。栈空间是向下增长的，也就是说，栈顶的地址是越来越小的。栈是先进后出的(FILO)，队列是先进先出的(FIFO)。PUSH压栈，存在栈顶；POP，弹栈，从栈顶中删除一个元素。</li><li>堆区（heap segment）：存放由程序员手动申请的内存空间，存放程序运行时分配的变量。堆的大小不固定，可动态扩张或缩减；其分配使用c中new()&#x2F;malloc()函数实时分配内存，调用malloc()函数分配内存时，新分配的内存动态添加到堆上（堆被扩张）。delete()&#x2F;free()函数释放，被释放的内存从堆中提出（堆被缩减）。堆的内存释放由应用程序去控制，通常一个new()就要对应一个delete()，堆空间是由程序员手动管理的，在使用完毕后将其释放，如果没有释放，则在程序结束后会由操作系统自动回收。堆空间是向上增长的，也就是说，堆顶的地址是越来越大的。</li></ul><h3 id="常量的存储位置"><a href="#常量的存储位置" class="headerlink" title="常量的存储位置"></a>常量的存储位置</h3><p>常量可以位于代码区或数据区。字符串常量（如 “Hello”）通常存放在代码区。全局常量（如 const int x &#x3D; 10;）通常存放在数据区。局部常量（如函数内的 const 变量）通常存放在栈区。</p><h3 id="C语言中内存分配的方式有几种？"><a href="#C语言中内存分配的方式有几种？" class="headerlink" title="C语言中内存分配的方式有几种？"></a>C语言中内存分配的方式有几种？</h3><p>1、静态存储区分配。内存分配在程序编译之前完成，且在程序的整个运行期间都存在，例如全局变量、静态变量等。<br>2、栈上分配。在函数执行时，函数内的局部变量的存储单元在栈上创建，函数执行结束时这些存储单元自动释放。<br>3、堆上分配。比如new出来的对象，需要自己delete释放</p><h3 id="重载、重写、重定义的区别？"><a href="#重载、重写、重定义的区别？" class="headerlink" title="重载、重写、重定义的区别？"></a>重载、重写、重定义的区别？</h3><p>重载：两个函数名相同，但是参数列表不同（个数，类型），返回值类型没有要求，在同一作用域中。<br>函数重载满足条件：<br>1、同一个作用域下；<br>2、函数名称相同；<br>3、函数参数类型不同 或者个数不同 或者顺序不同（类 个 顺 ）<br>注意:  函数的返回值不可以作为函数重载的条件</p><p>重载：在同一作用域内，函数名相同但参数列表不同（个数、类型），返回值没有要求（注：不能通过返回值重载函数），支持编译时多态。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;func 的调用！&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;func (int a) 的调用！&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">double</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;func (double a)的调用！&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a ,<span class="hljs-type">double</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;func (int a ,double b) 的调用！&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">double</span> a ,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;func (double a ,int b)的调用！&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//函数返回值不可以作为函数重载条件</span><br><span class="hljs-comment">//int func(double a, int b)</span><br><span class="hljs-comment">//&#123;</span><br><span class="hljs-comment">//cout &lt;&lt; &quot;func (double a ,int b)的调用！&quot; &lt;&lt; endl;</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">func</span>();<br><span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>);<br><span class="hljs-built_in">func</span>(<span class="hljs-number">3.14</span>);<br><span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>,<span class="hljs-number">3.14</span>);<br><span class="hljs-built_in">func</span>(<span class="hljs-number">3.14</span>,<span class="hljs-number">10</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>重写：重写也叫作覆盖，子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，其函数名、参数列表和返回值类型都要相同，支持运行时多态。（在派生类的虚函数表中，对应的基类虚函数被派生类虚函数覆盖）<br>重定义：重定义又叫作隐藏，是指在派生类中定义一个与基类中同名的非虚函数或变量，使得基类的成员在派生类中被隐藏起来。（与重写的区别就在于定义的是否是虚函数）</p><h3 id="定义和声明的区别？"><a href="#定义和声明的区别？" class="headerlink" title="定义和声明的区别？"></a>定义和声明的区别？</h3><p>定义：编译器创建一个对象，为这个对象分配一块内存并给它取上一个名字，这个名字就是所说的变量名或对象名，这块内存的位置也不能被改变。一个变量或对象在一定的区域内（比如函数内，全局等）只能被定义一次，如果定义多次，编译器会提示重定义错误。int i；<br>声明：有两重含义。<br>第一重含义：告诉编译器，这个名字已经匹配到一块内存上了，下面的代码用到变量或对象是在别的地方定义的。声明可以出现多次，extern int i；。<br>第二重含义：告诉编译器，我这个名字我先预定了，别的地方再也不能用它来作为变量名或对象名。这种声明最典型的例子就是函数参数的声明，例如：void fun(int i, char c)；<br>定义声明最重要的区别：定义创建了对象并为对象分配了内存，声明没有分配内存。</p><h3 id="全局变量、局部变量和静态变量的区别是什么"><a href="#全局变量、局部变量和静态变量的区别是什么" class="headerlink" title="全局变量、局部变量和静态变量的区别是什么?"></a>全局变量、局部变量和静态变量的区别是什么?</h3><p>1、全局变量的作用域为程序块，而局部变量的作用域为当前函数。<br>2、内存存储方式不同，全局变量、静态变量（静态全局变量，静态局部变量）分配在全局数据区（静态存储空间），局部变量分配在栈区。<br>3、生命周期不同。全局变量随主程序创建而创建，随主程序销毁而销毁，局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在了。<br>4、使用方式不同。通过声明为全局变量，程序的各个部分都可以用到，而局部变量只能在局部使用。</p><h4 id="全局变量是否可以定义在头文件中？"><a href="#全局变量是否可以定义在头文件中？" class="headerlink" title="全局变量是否可以定义在头文件中？"></a>全局变量是否可以定义在头文件中？</h4><p>不可以。全局变量不能在头文件中定义，但可以在头文件中声明。</p><h4 id="全局变量可不可以定义在可被多个-C文件包含的头文件中？为什么？"><a href="#全局变量可不可以定义在可被多个-C文件包含的头文件中？为什么？" class="headerlink" title="全局变量可不可以定义在可被多个.C文件包含的头文件中？为什么？"></a>全局变量可不可以定义在可被多个.C文件包含的头文件中？为什么？</h4><p>可以，在不同的C文件中以static形式来声明同名全局变量；可以在不同的C文件中声明同名的全局变量，前提是其中只能有一个C文件中对此变量赋初值，此时连接不会出错。</p><h4 id="局部变量能否和全局变量重名？"><a href="#局部变量能否和全局变量重名？" class="headerlink" title="局部变量能否和全局变量重名？"></a>局部变量能否和全局变量重名？</h4><p>能，局部会屏蔽全局。局部变量可以与全局变量同名，在函数内引用这个变量时，会用到同名的局部变量，而不会用到全局变量。对于有些编译器而言，在同一个函数内可以定义多个同名的局部变量，比如在两个循环体内都定义一个同名的局部变量，而那个局部变量的作用域就在那个循环体内。</p><h4 id="在头文件中定义静态变量是否可行，为什么"><a href="#在头文件中定义静态变量是否可行，为什么" class="headerlink" title="在头文件中定义静态变量是否可行，为什么?"></a>在头文件中定义静态变量是否可行，为什么?</h4><p>不可行，如果在头文件中定义静态变量，会造成资源浪费的问题，同时也可能引起程序错误。因为如果在使用了该头文件的每个C语言文件中定义静态变量，按照编译的步骤，在每个头文件中都会单独存在一个静态变量，从而会引起空间浪费或者程序错误。所以，不推荐在头文件中定义任何变量，当然也包括静态变量。</p><h3 id="关键字static的作用是什么？"><a href="#关键字static的作用是什么？" class="headerlink" title="关键字static的作用是什么？"></a>关键字static的作用是什么？</h3><p>静态成员分为：静态成员变量和静态成员函数。<br>在静态成员变量中：所有对象共享同一份数据；在编译阶段分配内存；类内声明，类外初始化<br>在静态成员函数中：所有对象共享同一个函数；静态成员函数只能访问静态成员变量<br>1、在函数体，只会被初始化一次，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。<br>2、在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问(只能被当前文件使用）。例如在a.c 中定义了static int a&#x3D;10;那么在b.c中用extern int a是拿不到a的值的，a的作用域只在a.c中。一个被声明为静态的函数同样如此。<br>3、static定义的静态局部变量分配在数据段上，普通的局部变量分配在栈上，会因为函数栈帧的释放而被释放掉。它只被初始化一次，若没进行初始化则自动初始化为0.<br>4、对一个类中成员变量和成员函数来说，加了static 关键字，则此变量&#x2F;函数就没有了this 指针了，必须通过类名才能访问。</p><h3 id="在C语言中，为什么static变量只初始化一次？"><a href="#在C语言中，为什么static变量只初始化一次？" class="headerlink" title="在C语言中，为什么static变量只初始化一次？"></a>在C语言中，为什么static变量只初始化一次？</h3><p>对于所有的对象（不仅仅是静态对象），初始化都只有一次，而由于静态变量具有“记忆”功能，初始化后，一直都没有被销毁，都会保存在内存区域中，所以不会再次初始化。存放在静态区的变量的生命周期一般比较长，它与整个程序“同生死、共存亡”，所以它只需初始化一次。而auto变量，即自动变量，由于它存放在栈区，一旦函数调用结束，就会立刻被销毁。</p><h3 id="如何引用一个已经定义过的全局变量？"><a href="#如何引用一个已经定义过的全局变量？" class="headerlink" title="如何引用一个已经定义过的全局变量？"></a>如何引用一个已经定义过的全局变量？</h3><p>可以用引用头文件的方式，也可以用extern关键字，如果用引用头文件方式来引用某个在头文件中声明的全局变量，假定你将那个变量写错了，那么在编译期间会报错，如果你用extern方式引用时，假定你犯了同样的错误，那么在编译期间不会报错，而在连接期间报错。</p><h3 id="函数参数的传递方式有几种？"><a href="#函数参数的传递方式有几种？" class="headerlink" title="函数参数的传递方式有几种？"></a>函数参数的传递方式有几种？</h3><p>值传递、引用传递、指针传递。严格来看，只有一种传递，值传递，指针传递也是按值传递的，复制的是地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//1. 值传递</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mySwap01</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br><span class="hljs-type">int</span> temp = a;<br>a = b;<br>b = temp;<br>&#125;<br><span class="hljs-comment">//2. 地址传递</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mySwap02</span><span class="hljs-params">(<span class="hljs-type">int</span>* a, <span class="hljs-type">int</span>* b)</span> </span>&#123;<br><span class="hljs-type">int</span> temp = *a;<br>*a = *b;<br>*b = temp;<br>&#125;<br><span class="hljs-comment">//3. 引用传递</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mySwap03</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; a, <span class="hljs-type">int</span>&amp; b)</span> </span>&#123;<br><span class="hljs-type">int</span> temp = a;<br>a = b;<br>b = temp;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br><span class="hljs-built_in">mySwap01</span>(a, b);<br>cout &lt;&lt; <span class="hljs-string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;<br><span class="hljs-built_in">mySwap02</span>(&amp;a, &amp;b);<br>cout &lt;&lt; <span class="hljs-string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;<br><span class="hljs-built_in">mySwap03</span>(a, b);<br>cout &lt;&lt; <span class="hljs-string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><p>在C++中，类内的成员变量和成员函数分开存储，只有非静态成员变量才属于类的对象上。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>() &#123;<br>mA = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//非静态成员变量占对象空间</span><br><span class="hljs-type">int</span> mA;<br><span class="hljs-comment">//静态成员变量不占对象空间</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> mB; <br><span class="hljs-comment">//函数也不占对象空间，所有函数共享一个函数实例</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;mA:&quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;mA &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//静态成员函数也不占对象空间</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">sfunc</span><span class="hljs-params">()</span> </span>&#123;<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(Person) &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码。这一块代码是如何区分哪个对象调用自己的呢？<br>c++通过提供特殊的对象指针，this指针，解决上述问题。this指针指向被调用的成员函数所属的对象。<br>this指针是隐含每一个非静态成员函数内的一种指针，this指针不需要定义，直接使用即可<br>this指针的用途：<br>1、当形参和成员变量同名时，可用this指针来区分<br>2、在类的非静态成员函数中返回对象本身，可使用return *this</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> age)<br>&#123;<br><span class="hljs-comment">//当形参和成员变量同名时，可用this指针来区分,this指针指向被调用的成员函数所属的对象</span><br><span class="hljs-keyword">this</span>-&gt;age = age;<br>&#125;<br><span class="hljs-function">Person&amp; <span class="hljs-title">PersonAddPerson</span><span class="hljs-params">(Person p)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">this</span>-&gt;age += p.age;<br><span class="hljs-comment">//返回对象本身</span><br>        <span class="hljs-comment">//注意c++中不能返回局部变量的引用，但是 *this 并非局部变量，而是对象本身</span><br>        <span class="hljs-comment">//注意如果返回值不是引用而是值，会调用拷贝构造函数，重新生成一个对象返回，就不是对象本身了</span><br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-type">int</span> age;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;p1.age = &quot;</span> &lt;&lt; p<span class="hljs-number">1.</span>age &lt;&lt; endl;<br><span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>p<span class="hljs-number">2.</span><span class="hljs-built_in">PersonAddPerson</span>(p1).<span class="hljs-built_in">PersonAddPerson</span>(p1).<span class="hljs-built_in">PersonAddPerson</span>(p1);<br>cout &lt;&lt; <span class="hljs-string">&quot;p2.age = &quot;</span> &lt;&lt; p<span class="hljs-number">2.</span>age &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">test01</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="extern”C”-的作用是什么？"><a href="#extern”C”-的作用是什么？" class="headerlink" title="extern”C” 的作用是什么？"></a>extern”C” 的作用是什么？</h3><p>extern “C”的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern “C”后，会指示编译器这部分代码按C语言的进行编译，而不是C++的。很多库像ffmpeg的库使用c语言写的，在cpp中可以通过extern “C”来调包，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br>    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;libavformat/avformat.h&gt;</span> <span class="hljs-comment">// 用于处理多媒体容器格式</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;libavutil/imgutils.h&gt;</span>  <span class="hljs-comment">// 提供图像处理工具函数</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;libavutil/opt.h&gt;</span>       <span class="hljs-comment">// 提供选项处理功能</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;libavutil/time.h&gt;</span>      <span class="hljs-comment">// 提供时间相关函数</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;libavutil/channel_layout.h&gt;</span> <span class="hljs-comment">// 提供声道布局相关功能</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;libswscale/swscale.h&gt;</span>  <span class="hljs-comment">// 提供图像格式转换功能</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;libswresample/swresample.h&gt;</span> <span class="hljs-comment">// 提供音频重采样功能</span></span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数组指针和指针数组有什么区别？"><a href="#数组指针和指针数组有什么区别？" class="headerlink" title="数组指针和指针数组有什么区别？"></a>数组指针和指针数组有什么区别？</h3><p>数组指针就是指向数组的指针，它的重点是指针，size为4个字节。例如，int (*arr)[4];<br>指针数组是一个数组，其中的每个元素都是指针，size为（指针数组的元素个数×4）字节。例如，int *ptrs[3]        </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 数组指针    类型*  数组名[数组大小];         </span><br><span class="hljs-type">int</span> arr[<span class="hljs-number">8</span>]=&#123;<span class="hljs-number">1</span>，<span class="hljs-number">2</span>，<span class="hljs-number">3</span>，<span class="hljs-number">4</span>，<span class="hljs-number">5</span>，<span class="hljs-number">6</span>，<span class="hljs-number">7</span>，<span class="hljs-number">8</span>&#125;;<br><span class="hljs-type">int</span>(*pa)[<span class="hljs-number">8</span>]= &amp;arr; <span class="hljs-comment">// pa向arr数组</span><br><span class="hljs-comment">//访问数组元素，(*pa)表示解引用指针pa，得到它指向的数组，然后通过[3]访问数组的第4个元素。</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,(*pa)[<span class="hljs-number">3</span>]);  <span class="hljs-comment">//输出4 </span><br><br><span class="hljs-comment">// 指针数组    类型 (*指针变量名)[数组大小];    </span><br><span class="hljs-type">int</span> a=<span class="hljs-number">1</span>,b=<span class="hljs-number">2</span>,c=<span class="hljs-number">3</span>;<br><span class="hljs-type">int</span> *pa[<span class="hljs-number">3</span>]=&#123;&amp;a，&amp;b，&amp;c&#125;; <span class="hljs-comment">// pa是一个包含3个指针的数组</span><br><span class="hljs-comment">// 访访问指针数组中的元素</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>，*pa[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 输出2</span><br></code></pre></td></tr></table></figure><h3 id="函数指针和指针函数有什么区别？"><a href="#函数指针和指针函数有什么区别？" class="headerlink" title="函数指针和指针函数有什么区别？"></a>函数指针和指针函数有什么区别？</h3><p>1、函数指针<br>如果在程序中定义了一个函数，那么在编译时系统就会为这个函数代码分配一段存储空间，这段存储空间的首地址称为这个函数的地址。而且函数名表示的就是这个地址。既然是地址就可以定义一个指针变量来存放，这个指针变量就叫作函数指针变量，简称函数指针，指向函数的指针变量没有 ++ 和 – 运算。  int(*p)(int, int);   指针p存放函数int的地址。<br>2、指针函数<br>首先它是一个函数，只不过这个函数的返回值是一个地址值。函数返回值必须用同类型的指针变量来接受，也就是说，指针函数一定有“函数返回值”，指针函数是返回值是指针的函数，而且，在主调函数中，函数返回值必须赋给同类型的指针变量。类型名 *函数名(函数参数列表); 在调用语句中，即使函数不带参数，其参数表的一对括号也不能省略。其示例如下：int <em>pfun(int, int);<br>由于“</em>”的优先级低于“()”的优先级，因而pfun首先和后面的“()”结合，也就意味着，pfun是一个函数。即：int *(pfun(int, int));</p><h3 id="指针和引用的异同是什么？如何相互转换？"><a href="#指针和引用的异同是什么？如何相互转换？" class="headerlink" title="指针和引用的异同是什么？如何相互转换？"></a>指针和引用的异同是什么？如何相互转换？</h3><p>相同：<br>1、都是地址的概念，指针指向某一内存、它的内容是所指内存的地址；引用则是某块内存的别名。<br>2、从内存分配上看：两者都占内存，程序为指针会分配内存，一般是4个字节；而引用的本质是指针常量，指向对象不能变，但指向对象的值可以变。两者都是地址概念，所以本身都会占用内存。<br>区别：<br>1、指针是实体表变量、存储的是内存地址，而引用是别名<br>2、指针和引用的自增（++）运算符意义不同，指针是对内存地址自增，而引用是对值的自增。<br>3、引用使用时无需解引用(<em>)，指针需要解引用。<br>4、引用只能在定义时被初始化一次，之后不可变；指针可变。<br>5、引用不能为空，指针可以为空。<br>6、“sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身的大小，在32位系统指针变量一般占用4字节内存。<br>转换：<br>1、指针转引用：把指针用</em>就可以转换成对象，可以用在引用参数当中。<br>2、引用转指针：把引用类型的对象用&amp;取地址就获得指针了。</p><h3 id="指针变量和普通变量的区别"><a href="#指针变量和普通变量的区别" class="headerlink" title="指针变量和普通变量的区别"></a>指针变量和普通变量的区别</h3><p>指针变量定义语法：数据类型* 变量名；<br>普通变量存放的是数据,指针变量存放的是地址。指针变量可以通过” * “操作符，操作指针变量指向的内存空间，这个过程称为解引用。所有指针类型在32位操作系统下是4个字节,在64位操作系统下是8字节<br>总结1：我们可以通过 &amp; 符号 获取变量的地址<br>总结2：利用指针可以记录地址<br>总结3：对指针变量解引用，可以操作指针指向的内存</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//1、指针的定义</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>; <span class="hljs-comment">//定义整型变量a</span><br><span class="hljs-type">int</span>* p;  <span class="hljs-comment">// 定义指针</span><br><span class="hljs-comment">//指针变量赋值</span><br>p = &amp;a; <span class="hljs-comment">//指针指向变量a的地址,  &amp;为取址符</span><br>cout &lt;&lt; &amp;a &lt;&lt; endl; <span class="hljs-comment">//打印数据a的地址</span><br>cout &lt;&lt; p &lt;&lt; endl;  <span class="hljs-comment">//打印指针变量p</span><br><span class="hljs-comment">//2、指针的使用</span><br><span class="hljs-comment">//通过*操作指针变量指向的内存</span><br>cout &lt;&lt; <span class="hljs-string">&quot;*p = &quot;</span> &lt;&lt; *p &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span>&amp; ref = a; <span class="hljs-comment">// 此时&amp;为引用，用ref做别名与变量a绑定</span><br></code></pre></td></tr></table></figure><h4 id="空指针和野指针"><a href="#空指针和野指针" class="headerlink" title="空指针和野指针"></a>空指针和野指针</h4><p>空指针：指针变量指向内存中编号为0的空间，用来初始化指针变量<br>野指针：指针变量指向非法的内存空间<br>总结：空指针和野指针都不是我们申请的空间，因此不要访问</p><h3 id="const修饰指针的三种情况"><a href="#const修饰指针的三种情况" class="headerlink" title="const修饰指针的三种情况"></a>const修饰指针的三种情况</h3><p>1、const修饰指针   — 常量指针<br>2、const修饰常量   — 指针常量，本质上一个常量，常量值不可修改<br>3、const既修饰指针，又修饰常量<br>技巧：看const右侧紧跟着的是指针还是常量, 是指针就是常量指针，是常量就是指针常量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">10</span>;<br>    <span class="hljs-comment">//常量指针(记法：const在前 先常量 后指针 )</span><br><span class="hljs-comment">//指针指向可以改，指针指向的值不可以更改(const修饰的是解引用 int*)</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>* p1 = &amp;a; <br>p1 = &amp;b; <span class="hljs-comment">//正确</span><br><span class="hljs-comment">//*p1 = 100;  报错</span><br><br>    <span class="hljs-comment">//指针常量(记法：int* 在前 先指针 后常量)</span><br><span class="hljs-comment">//指针指向不可以改，指针指向的值可以更改(const修饰的是指针本身)</span><br><span class="hljs-type">int</span>* <span class="hljs-type">const</span> p2 = &amp;a;<br><span class="hljs-comment">//p2 = &amp;b; //错误</span><br>*p2 = <span class="hljs-number">100</span>; <span class="hljs-comment">//正确</span><br><br>    <span class="hljs-comment">//const既修饰指针又修饰常量</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> * <span class="hljs-type">const</span> p3 = &amp;a;<br><span class="hljs-comment">//p3 = &amp;b; //错误</span><br><span class="hljs-comment">//*p3 = 100; //错误</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="什么情况下使用const关键字？"><a href="#什么情况下使用const关键字？" class="headerlink" title="什么情况下使用const关键字？"></a>什么情况下使用const关键字？</h3><p>1、修饰一般常量。一般常量是指简单类型的常量。这种常量在定义时，修饰符const可以用在类型说明符前，也可以用在类型说明符后。例如：int const x&#x3D;2；const int x&#x3D;2<br>2、修饰常数组。定义或说明一个常数组可以采用如下格式：int const a[8]&#x3D;{1,2,3,4,5,6,7,8}                             const int a[8]&#x3D;{1,2,3,4,5,6,7,8}<br>3、修饰常对象。常对象是指对象常量。定义常对象时，同样要进行初始化，并且该对象不能再被更新。修饰符 const可以放在类名后面，也可以放在类名前面。<br>4、修饰常指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">int</span>*p； <span class="hljs-comment">//常量指针，指向常量的指针。即p指向的内存可以变，p指向的数值内容不可变</span><br><span class="hljs-type">int</span> <span class="hljs-type">const</span>*p； <span class="hljs-comment">//同上</span><br><span class="hljs-type">int</span>*<span class="hljs-type">const</span> p；<span class="hljs-comment">//指针常量，本质是一个常量，而用指针修饰它。 即p指向的内存不可以变，但是p内存位置的数值可以变</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>* <span class="hljs-type">const</span> p；<span class="hljs-comment">//指向常量的常量指针。即p指向的内存和数值都不可变</span><br></code></pre></td></tr></table></figure><p>5、修饰常引用。被 const修饰的引用变量为常引用，一旦被初始化，就不能再指向其他对象了。<br>6、修饰函数的常参数。 const修饰符也可以修饰函数的传递参数，格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Fun</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> Var)</span>;<br></code></pre></td></tr></table></figure><p>7、修饰函数的返回值。 const修饰符也可以修饰函数的返回值，表明该返回值不可被改变。如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-title function_">FunI</span><span class="hljs-params">()</span>；    <br><span class="hljs-type">const</span> MyClass <span class="hljs-title function_">Fun2</span><span class="hljs-params">()</span>；<br></code></pre></td></tr></table></figure><p>8、在另一连接文件中引用 const常量。使用方式有:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> j=<span class="hljs-number">10</span>；<br></code></pre></td></tr></table></figure><h3 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h3><p>作用：通过指针访问结构体中的成员<br>利用操作符 <code>-&gt; </code>可以通过结构体指针访问结构体属性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//结构体定义</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">student</span><br>&#123;<br><span class="hljs-comment">//成员列表</span><br>string name;  <span class="hljs-comment">//姓名</span><br><span class="hljs-type">int</span> age;      <span class="hljs-comment">//年龄</span><br><span class="hljs-type">int</span> score;    <span class="hljs-comment">//分数</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">student</span> stu = &#123; <span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-number">18</span>,<span class="hljs-number">100</span>, &#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">student</span>* p = &amp;stu;<br>p-&gt;score = <span class="hljs-number">80</span>; <span class="hljs-comment">//指针通过 -&gt; 操作符可以访问成员</span><br>cout &lt;&lt; <span class="hljs-string">&quot;姓名：&quot;</span> &lt;&lt; p-&gt;name &lt;&lt; <span class="hljs-string">&quot; 年龄：&quot;</span> &lt;&lt; p-&gt;age &lt;&lt; <span class="hljs-string">&quot; 分数：&quot;</span> &lt;&lt; p-&gt;score &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="和-的区别"><a href="#和-的区别" class="headerlink" title="#和## 的区别"></a>#和## 的区别</h3><p>‘#’和’##’是用于宏定义（#define）的特殊运算符。它们分别用于字符串化和连接操作。# 运算符的作用是将宏参数转换为字符串。## 运算符的作用是将两个标记（token）连接成一个新的标记。<br>Tip:<br>1、当用 ## 运算符的作用是将两个标记（token）连接成一个新的标记。<br>2、连接后的实际参数名，必须为实际存在的参数名或是编译器已知的宏定义。<br>3、如果##后的参数本身也是一个宏的话，##会阻止这个宏的展开。</p><h3 id="const有什么作用？"><a href="#const有什么作用？" class="headerlink" title="const有什么作用？"></a>const有什么作用？</h3><p>1、定义变量（局部变量或全局变量）为常量<br>2、修饰函数的参数，表示在函数体内不能修改这个参数的值。<br>3、修饰函数的返回值。<br>如果给用 const修饰返回值的类型为指针，那么函数返回值（即指针）的内容是不能被修改的，而且这个返回值只能赋给被 const修饰的指针。<br>如果用 const修饰普通的返回值，如返回int变量，由于这个返回值是一个临时变量，在函数调用结束后这个临时变量的生命周期也就结束了，因此把这些返回值修饰为 const是没有意义的。<br>4、节省空间，避免不必要的内存分配。</p><h3 id="定义常量谁更好？-define-还是-const？"><a href="#定义常量谁更好？-define-还是-const？" class="headerlink" title="定义常量谁更好？#define 还是 const？"></a>定义常量谁更好？#define 还是 const？</h3><p>define既可以替代常数值，又可以替代表达式，甚至是代码段，但是容易出错，而 const的引入可以增强程序的可读性，它使程序的维护与调试变得更加方便。区别如下：<br>1、define只是用来进行单纯的文本替换， define常量的生命周期止于编译期，不分配内存空间，它存在于程序的代码段，在实际程序中，它只是一个常数；而 const常量存在于程序的数据段，并在堆栈中分配了空间， const常量在程序中确确实实存在，并且可以被调用、传递。<br>2、const常量有数据类型（如const int MAX &#x3D; 100;），而 define常量没有数据类型。编译器可以对 const常量进行类型安全检査，如类型、语句结构等，而 define不行。<br>3、很多IDE支持调试 const定义的常量，而不支持 define定义的常量，由于 const修饰的变量可以排除程序之间的不安全性因素，保护程序中的常量不被修改，而且对数据类型也会进行相应的检查，极大地提高了程序的健壮性，所以一般更加倾向于用const来定义常量类型。</p><h3 id="typedef和-define有什么区别？"><a href="#typedef和-define有什么区别？" class="headerlink" title="typedef和 define有什么区别？"></a>typedef和 define有什么区别？</h3><p>typedef与 define都是替一个对象取一个别名，以此来增强程序的可读性，但是它们在使用和作用上也存在着以下4个方面的不同：<br>1、原理不同<br>#define 是C语言中定义的语法，它是预处理指令，在预处理时进行简单而机械的字符串替换，不做正确性检査，不管含义是否正确照样代入，只有在编译已被展开的源程序时，才会发现可能的错误并报错；typedef是关键字，它在编译时处理，所以 typedef具有类型检查的功能。它在自己的作用域内给一个已经存在的类型一个别名，但是不能在一个函数定义里面使用标识符 typedef<br>2、功能不同<br>typedef用来定义类型的别名，这些类型不仅包含内部类型（int、char等），还包括自定义类型（如struct），可以起到使类型易于记忆的功能。#define 不只是可以为类型取别名，还可以定义常量、变量、编译开关等。<br>3、作用域不同<br>#define 没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用，而 typedef有自己的作用域。<br>4、对指针的操作不同<br>两者修饰指针类型时，作用不同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> INTPTR1 int*</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span>* INTPTR2;<br>INTPTR1 p1,p2;<br>INTPTR2 p3,p4;<br></code></pre></td></tr></table></figure><p>INTPTR1 pl, p2 进行字符串替换后变成 int<em>p1,p2 ，即声明一个指针变量p1和一个整型变量p2；<br>INTPTR2 p3， p4，由于INTPTR2是具有含义的，一个指向整型数据的指针，那么p3和p4都为指针变量，这句相当于int</em>p3，int* p4 .<br>因此，进行宏替换是不含任何意义的替换，仅仅为字符串替换；而用 typedef为一种数据类型起的别名是带有一定含义的。</p><h3 id="new-delete与malloc-free的共同点和区别是什么？"><a href="#new-delete与malloc-free的共同点和区别是什么？" class="headerlink" title="new&#x2F;delete与malloc&#x2F;free的共同点和区别是什么？"></a>new&#x2F;delete与malloc&#x2F;free的共同点和区别是什么？</h3><p>共同点：都是用于实现动态内存分配和释放，都操作堆内存（heap memory），即分配的内存不在栈（stack）或全局区（global&#x2F;static area）。<br>区别：<br>1、new、delete是C++中的操作符，而malloc和free是标准库函数 stdlib.h；<br>2、对于非内部数据对象来说，只使用malloc是无法完成动态对象要求的，一般在创建对象时需要调用构造函数，对象消亡时，自动的调用析构函数。malloc free是库函数而不是运算符，不在编译器控制范围之内，不能够自动调用构造函数和析构函数。而NEW在为对象申请分配内存空间时，可以自动调用构造函数，同时也可以完成对对象的初始化。同理，delete也可以自动调用析构函数。而mallloc只是做一件事，只是为变量分配了内存，同理，free也只是释放变量的内存，不调用构造函数和析构函数。<br>3、new返回的是指定类型的指针，并且可以自动计算所申请内存的大小。而 malloc需要我们计算申请内存的大小，并且在返回时强行转换为实际类型的指针。</p><h3 id="strlen-“-0”-？-sizeof-“-0”"><a href="#strlen-“-0”-？-sizeof-“-0”" class="headerlink" title="strlen(“\0”) &#x3D;？ sizeof(“\0”)&#x3D;?"></a>strlen(“\0”) &#x3D;？ sizeof(“\0”)&#x3D;?</h3><p>strlen(“\0”) &#x3D;0，sizeof(“\0”)&#x3D;2。<br>strlen是C标准库中的一个函数，用来计算字符串的长度（在C&#x2F;C++中，字符串是以”\0”作为结束符的），它从内存的某个位置（可以是字符串开头，中间某个位置，甚至是某个不确定的内存区域）开始扫描直到碰到第一个字符串结束符\0为止，然后返回计数器值。sizeof是C和C++中的一个操作符（关键字），它以字节的形式给出了其操作数的存储大小，操作数可以是一个表达式或括在括号内的类型名，操作数的存储大小由操作数的类型决定。</p><h3 id="sizeof和strlen有什么区别？"><a href="#sizeof和strlen有什么区别？" class="headerlink" title="sizeof和strlen有什么区别？"></a>sizeof和strlen有什么区别？</h3><p>1、sizeof是运算符可以不加括弧。<br>2、sizeof运算符的结果类型是 size_t，它在头文件中 typedef为 unsigned int类型。该类型保证能够容纳实现所建立的最大对象的字节大小<br>3、sizeof可以用类型作为参数， strlen只能用char*作参数，而且必须是以’\o’结尾的。 sizeof还可以以函数作为参数，如int g()，则 sizeof(g())的值等于 sizeof（ int的值)，在32位计算机下，该值为4。<br>4、大部分编译程序的 sizeof都是在编译的时候计算的，所以可以通过 sizeof（x）来定义数组维数。而 strlen则是在运行期计算的，用来计算字符串的实际长度，不是类型占内存的大小。例如， char str[20] &#x3D; “0123456789”，字符数组str是编译期大小已经固定的数组，在32位机器下，为sizeof（char）*20&#x3D;20，而其 strlen大小则是在运行期确定的，所以其值为字符串的实际长度10。C语言中，sizeof(char)的值总是1，因为char类型被定义为占用1个字节的内存。<br>5、当数组作为参数传给函数时，传递的是指针，而不是数组，即传递的是数组的首地址。</p><h3 id="堆与栈有什么区别？"><a href="#堆与栈有什么区别？" class="headerlink" title="堆与栈有什么区别？"></a>堆与栈有什么区别？</h3><p>1、申请方式。栈的空间由操作系统自动分配&#x2F;释放，堆上的空间手动分配&#x2F;释放。<br>2、申请大小的限制<br>栈空间有限。在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。即栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M（也有的说是1M，总之是 一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。<br>堆是很大的自由存储区。堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。<br>3、申请效率。栈由系统自动分配，速度较快。但程序员是无法控制的。堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便.</p><h3 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h3><p>公共权限  public     类内可以访问  类外可以访问<br>保护权限  protected  类内可以访问  类外不可以访问 派生类可以访问<br>私有权限  private    类内可以访问  类外不可以访问</p><h3 id="公有继承、保护继承、私有继承的区别"><a href="#公有继承、保护继承、私有继承的区别" class="headerlink" title="公有继承、保护继承、私有继承的区别"></a>公有继承、保护继承、私有继承的区别</h3><p>封装、继承、多态是面对对象的三种特性。在继承中，父类也叫基类,子类也叫派生类。父类中私有内容，子类无论用哪种方式，都不可以访问(父类私有内容不可访问)。<br>公共继承：父类中公共的属性，在子类中依然是公共的属性，父类中是保护的属性，在子类中依然是保护的的属性（公共继承属性不变）<br>保护继承：父类中公共的属性和保护的属性，在子类中都变为了保护的属性（保护继承属性变保护）<br>私有继承：父类中公共的属性和保护的属性，在子类中都变为了私有的属性（私有继承属性变私有）<br>子类继承父类后，当创建子类对象，也会调用父类的构造函数。继承中会先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反。</p><h4 id="当子类与父类出现同名的成员，如何通过子类对象，访问到的是子类还是父类中同名的数据呢？"><a href="#当子类与父类出现同名的成员，如何通过子类对象，访问到的是子类还是父类中同名的数据呢？" class="headerlink" title="当子类与父类出现同名的成员，如何通过子类对象，访问到的是子类还是父类中同名的数据呢？"></a>当子类与父类出现同名的成员，如何通过子类对象，访问到的是子类还是父类中同名的数据呢？</h4><p>1、子类对象可以直接访问到子类中同名成员<br>2、子类对象加作用域可以访问到父类同名成员<br>3、当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数</p><h4 id="继承中同名的静态成员在子类对象上如何进行访问？"><a href="#继承中同名的静态成员在子类对象上如何进行访问？" class="headerlink" title="继承中同名的静态成员在子类对象上如何进行访问？"></a>继承中同名的静态成员在子类对象上如何进行访问？</h4><p>静态成员和非静态成员出现同名，处理方式一致。<br>访问子类同名成员直接访问即可；访问父类同名成员需要加作用域</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态的实现主要分为静态多态和动态多态。<br>静态多态主要是函数重载和运算符重载，复用函数名，在编译的时候就已经确定；<br>动态多态是用虚函数机制实现的，在运行期间动态绑定，虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销。通常在C++中所说的多态是指动态多态。<br>总结：<br>多态满足条件：1）有继承关系。 2）子类重写父类中的虚函数<br>多态使用条件：父类指针或引用指向子类对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractCalculator</span><br>&#123;<br><span class="hljs-keyword">public</span> :<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">int</span> m_Num1;<br><span class="hljs-type">int</span> m_Num2;<br>&#125;;<br><span class="hljs-comment">//加法计算器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddCalculator</span> :<span class="hljs-keyword">public</span> AbstractCalculator<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> m_Num1 + m_Num2;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容,因此可以将虚函数改为纯虚函数.<br>纯虚函数语法：virtual 返回值类型 函数名（参数列表）&#x3D; 0 ;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>当类中有了纯虚函数，这个类也称为抽象类<br>抽象类特点：1）无法实例化对象; 2）子类必须重写抽象类中的纯虚函数，否则也属于抽象类,无法实例化对象</p><h4 id="虚函数的实现？"><a href="#虚函数的实现？" class="headerlink" title="虚函数的实现？"></a>虚函数的实现？</h4><p>虚函数是用 virtual 关键字声明的成员函数，允许在派生类中重写（override）它的实现。<br>在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。<br>当你构造一个对象的时候，对象的内存里有一个虚表指针，指向的是类的虚表，虚表里面存放的是虚函数的地址，如果对象都没构造完，则无法使用虚函数。虚表指针是跟着对象走的，对象是在堆上创建则堆管理，如果是栈上的话则栈管理；</p><h4 id="构造函数能不能成为虚函数？"><a href="#构造函数能不能成为虚函数？" class="headerlink" title="构造函数能不能成为虚函数？"></a>构造函数能不能成为虚函数？</h4><p>不能。构造函数用途是初始化对象状态。<br>虚函数的调用依赖于对象的类型，构造函数在对象被创建时被调用，此时对象未构造完成，无法进行虚函数调用。虚函数的目的：是为了实现多态；<br>C++内部为每一个类维持一个虚函数表，该类的对象都指向这同一个虚函数表。</p><h4 id="虚函数和纯虚函数的区别"><a href="#虚函数和纯虚函数的区别" class="headerlink" title="虚函数和纯虚函数的区别"></a>虚函数和纯虚函数的区别</h4><p>虚函数：将基类的成员函数声明为虚函数，在派生类中可以进行重写。通过使用指向基类对象的指针或引用调用虚函数时，会根据实际对象类型来确定调用的是哪个版本的函数；<br>纯虚函数：在基类中声明一个没有实现体的纯虚函数，要求派生类必须提供自己的实现。当一个类包含纯虚函数时，它就变成了抽象类，无法直接创建对象，只能作为其他派生类的基类。通过在虚函数声明后添加&#x3D; 0，可以将其定义为纯虚函数。包含纯虚函数的类被称为抽象类，它不能被实例化。纯虚函数为派生类提供了一个必须实现的接口。</p><h4 id="为什么析构函数必须是虚函数？-析构函数可以是虚函数吗？"><a href="#为什么析构函数必须是虚函数？-析构函数可以是虚函数吗？" class="headerlink" title="为什么析构函数必须是虚函数？&#x2F;析构函数可以是虚函数吗？"></a>为什么析构函数必须是虚函数？&#x2F;析构函数可以是虚函数吗？</h4><p>将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间。<br>声明为虚析构函数后，通过基类指针删除对象时，会根据指针指向的实际对象类型调用相应的析构函数，从而确保对象中的资源能够正确释放，防止内存泄漏。</p><h4 id="虚析构和纯虚析构"><a href="#虚析构和纯虚析构" class="headerlink" title="虚析构和纯虚析构"></a>虚析构和纯虚析构</h4><p>虚析构和纯虚析构共性：可以解决父类指针释放子类对象；都需要有具体的函数实现<br>虚析构和纯虚析构区别：如果是纯虚析构，该类属于抽象类，无法实例化对象<br>虚析构语法：  virtual ~类名(){}<br>纯虚析构语法：  virtual ~类名() &#x3D; 0;<br>总结：<br>​1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象<br>​2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构<br>​3. 拥有纯虚析构函数的类也属于抽象类</p><h4 id="对象访问普通函数快还是虚函数快？"><a href="#对象访问普通函数快还是虚函数快？" class="headerlink" title="对象访问普通函数快还是虚函数快？"></a>对象访问普通函数快还是虚函数快？</h4><p>如果是普通对象的访问，那么访问两者的速度是一样快的；如果是指针或引用对象，则访问普通函数更快，因为此时构成多态，访问虚函数需要先到虚函数列表中去查找对应的虚函数指针，才能访问到虚函数。</p><h4 id="静态成员可以是虚函数吗？"><a href="#静态成员可以是虚函数吗？" class="headerlink" title="静态成员可以是虚函数吗？"></a>静态成员可以是虚函数吗？</h4><p>不可以。静态成员函数是属于类而不是类的实例的成员函数，它不依赖于类的任何实例化对象存在。静态成员函数在整个类的声明周期中保持唯一的一份拷贝。<br>虚函数的动态绑定需要在运行时根据对象的类型确定调用的函数版本，但静态成员函数在编译时已经确定了调用的版本，因此不适合作为虚函数。</p><h4 id="什么是菱形继承、虚继承？"><a href="#什么是菱形继承、虚继承？" class="headerlink" title="什么是菱形继承、虚继承？"></a>什么是菱形继承、虚继承？</h4><p>菱形继承是指一个派生类同时继承自两个间接基类，而这两个基类由继承自同一个共同的基类，形成了一种菱形的继承结构。<br>虚继承是为了解决菱形继承的二义性问题而引入的机制，通过在派生类堆共同基类的继承前面加上‘virtual’关键字，使得共同基类在派生类中只保留一份实例，从而避免二义性。</p><h3 id="c-文件操作"><a href="#c-文件操作" class="headerlink" title="c++文件操作"></a>c++文件操作</h3><p>C++中对文件操作需要包含头文件 <fstream>。文件类型分为两种：<br>1、文本文件  -  文件以文本的 ASCII码 形式存储在计算机中<br>2、二进制文件 - 文件以文本的 二进制 形式存储在计算机中，用户一般不能直接读懂它们。<br>操作文件的三大类:<br>1、ofstream：写操作<br>2、ifstream：读操作<br>3、fstream ：读写操作</p><h3 id="struct和class区别-c和c-中的struct有什么不同？"><a href="#struct和class区别-c和c-中的struct有什么不同？" class="headerlink" title="struct和class区别 ?&#x2F;c和c++中的struct有什么不同？"></a>struct和class区别 ?&#x2F;c和c++中的struct有什么不同？</h3><p>c和c++中struct的主要区别是c中的struct不可以含有成员函数，而c++中的struct可以。<br>c++中struct和class的主要区别在于默认的权限不同，struct默认为public，而class默认为private</p><h3 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h3><p>编译器提供的构造函数和析构函数是空实现。<br>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。​按参数分为有参构造和无参构造，按类型分为：普通构造和拷贝构造。构造函数语法：类名(){}<br>1、构造函数，没有返回值也不写void<br>2、函数名称与类名相同<br>3、构造函数可以有参数，因此可以发生重载<br>4、程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次</p><p>析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作。析构函数语法：~类名(){}<br>1、析构函数，没有返回值也不写void<br>2、函数名称与类名相同,在名称前加上符号  ~<br>3、析构函数不可以有参数，因此不可以发生重载<br>4、程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次</p><h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><p>基本数据类型(String, Number, Boolean, Null, Undefined，Symbol)和引用数据类型。<br>基本数据类型的特点是直接存储在栈(stack)中的数据。<br>引用数据类型存储的是该对象在栈中引用，真实的数据存放在堆内存里。<br>浅拷贝：创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址，如果其中一个对象改变了这个地址，就会影响到另一个对象。是简单的赋值拷贝操作（在栈区）,内存自动释放<br>深拷贝：会拷贝所有的属性，并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。拷贝前后两个对象互不影响。会在堆区重新申请空间，进行拷贝操作，内存需要手动释放<br>总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</p><h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术。友元的目的就是让一个函数或者类访问另一个类中私有成员，友元的关键字为friend。<br>友元的三种实现：全局函数做友元、类做友元、成员函数做友元。</p><h3 id="STL标准模板库"><a href="#STL标准模板库" class="headerlink" title="STL标准模板库"></a>STL标准模板库</h3><p>STL从广义上分为: 容器(container)、算法(algorithm)、迭代器(iterator)。容器和算法之间通过迭代器进行无缝连接。STL几乎所有的代码都采用了模板类或者模板函数。<br>STL大体分为六大组件，分别是: 容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器<br>1、容器：各种数据结构，如vector、list、deque、set、map等，用来存放数据。容器分为序列式容器和关联式容器两种。<br>序列式容器强调值的排序，序列式容器中的每个元素均有固定的位置。关联式容器是二叉树结构，各元素之间没有严格的物理上的顺序关系<br>2、算法：分为质变算法和非质变算法。常用的算法如sort、find、copy、for_each等<br>质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等。<br>非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等<br>3、迭代器：提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。每个容器都有自己专属的迭代器。迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针。<br>4、仿函数：行为类似函数，可作为算法的某种策略。<br>5、适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。<br>6、空间配置器：负责空间的配置与管理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 创建二维动态数组</span><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;  v;<br></code></pre></td></tr></table></figure><h3 id="模板类和模板函数的区别是什么？"><a href="#模板类和模板函数的区别是什么？" class="headerlink" title="模板类和模板函数的区别是什么？"></a>模板类和模板函数的区别是什么？</h3><p>是由编译程序在处理函数调用时自动完成的，而类模板的实例化必须<br>由程序员在程序中显式地指定。即函数模板允许隐式调用和显式调用而类模板只能显示<br>调用。在使用时类模板必须加<T>，而函数模板不必</p><h3 id="智能指针的作用；"><a href="#智能指针的作用；" class="headerlink" title="智能指针的作用；"></a>智能指针的作用；</h3><h3 id="动态编译与静态编译"><a href="#动态编译与静态编译" class="headerlink" title="动态编译与静态编译"></a>动态编译与静态编译</h3><p>1、静态编译，编译器在编译可执行文件时，把需要用到的对应动态链接库中的部分提取出来，连接到可执行文件中去，使可执行文件在运行时不需要依赖于动态链接库；<br>2、动态编译的可执行文件需要附带一个动态链接库，在执行时，需要调用其对应动态 链接库的命令。所以其优点一方面是缩小了执行文件本身的体积，另一方面是加快了编译速度，节省了系统资源。缺点是哪怕是很简单的程序，只用到了链接库的一两条命令，也需要附带一个相对庞大的链接库；二是如果其他计算机上没有安装对应的运行库，则用动态编译的可执行文件就不能运行。</p><h3 id="动态链接和静态链接区别"><a href="#动态链接和静态链接区别" class="headerlink" title="动态链接和静态链接区别"></a>动态链接和静态链接区别</h3><p>1、静态连接库就是把(lib)文件中用到的函数代码直接链接进目标程序，程序运行的时候不再需要其它的库文件；动态链接就是把调用的函数所在文件模块（DLL）和调用函数在文件中的位置等信息链接进目标程序，程序运行的时候再从 DLL 中寻找相应函数代码，因此需要相应 DLL 文件的支持。<br>2、静态链接库与动态链接库都是共享代码的方式，如果采用静态链接库，则无论你愿不愿意，lib中的指令都全部被直接包含在最终生成的EXE文件中了。但是若使用 DLL，该DLL不必被包含在最终 EXE 文件中，EXE文件执行时可以“动态”地引用和卸载这个与 EXE 独立的 DLL 文件。静态链接库和动态链接库的另外一个区别在于静态链接库中不能再包含其他的动态链接库或者静态库，而在动态链接库中还可以再包含其他的动态或静态链接库。<br>3、动态库就是在需要调用其中的函数时，根据函数映射表找到该函数然后调入堆栈执行。如果在当前工程中有多处对 dll 文件中同一个函数的调用，那么执行时，这个函数只会留下一份拷贝。但是如果有多处对 lib 文件中同一个函数的调用，那么执行时，该函数将在当前程序的执行空间里留下多份拷贝，而且是一处调用就产生一份拷贝。</p><h3 id="strcpy-和-memcpy-的区别"><a href="#strcpy-和-memcpy-的区别" class="headerlink" title="strcpy 和 memcpy 的区别"></a>strcpy 和 memcpy 的区别</h3><p>1、复制的内容不同。strcpy只能复制字符串，而 memcpy 可以复制任意内容，例如字符数组、整型、结构体、类等。<br>2、复制的方法不同。strcpy不需要指定长度，它遇到被复制字符的串结束符”\0”才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度。<br>3、用途不同。通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy</p><h3 id="malloc和calloc的区别"><a href="#malloc和calloc的区别" class="headerlink" title="malloc和calloc的区别"></a>malloc和calloc的区别</h3><p>malloc 分配内存后，不会对分配的内存进行初始化。分配的内存块中的内容是未定义的（即可能包含垃圾值）；<br>calloc 分配内存后，会将分配的内存初始化为零。</p><h3 id="strcpy和strcat的区别"><a href="#strcpy和strcat的区别" class="headerlink" title="strcpy和strcat的区别"></a>strcpy和strcat的区别</h3><p>strcpy()函数的功能是将src指针指向的字符串（包括结束符）复制到dst指向的数组中。（src会替换掉dst指向的字符）。<br>strcat()函数的功能是将src指针指向的字符串添加到dst指针指向的字符串后面，src第一个字符从dst指针结尾处开始。（src和dst指向的字符会拼接到一起）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-type">char</span>* <span class="hljs-title function_">strcpy</span><span class="hljs-params">( <span class="hljs-type">char</span>* dst,<span class="hljs-type">const</span> <span class="hljs-type">char</span>* src )</span>;<br><span class="hljs-type">char</span>* <span class="hljs-title function_">strcat</span><span class="hljs-params">( <span class="hljs-type">char</span>* dst,<span class="hljs-type">const</span> <span class="hljs-type">char</span>* src )</span>;<br></code></pre></td></tr></table></figure><h3 id="结构体对齐的好处？"><a href="#结构体对齐的好处？" class="headerlink" title="结构体对齐的好处？"></a>结构体对齐的好处？</h3><p>在内存中，数据的存储并不是连续的，而是按照一定的规则进行排列的。内存对齐规则的实现会按照结构体中最大的成员类型进行对齐，这样可以使结构体的大小变为最小值，并且提高对结构体内成员的访问效率。具体来说，<br>1、提高内存读写速度：物理内存是连续的，内存对齐使得结构体成员所处的内存地址是按照一定规则排列的，这样就可以避免出现跨越多个内存块的情况，从而提高了内存访问效率。<br>2、减少内存浪费：内存对齐规则会在结构体成员之间插入一些填充字节，这些字节在结构体的大小计算中没有计入，但是却占据了内存空间。这样可以减少内存浪费，提高内存利用率，加快访问速度。<br>3、便于处理：内存对齐后，结构体中成员的地址是按照一定规则排列的，这样就可以方便地进行内存操作和数据传输等操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-type">char</span> t:<span class="hljs-number">4</span>;<br><span class="hljs-type">char</span> k:<span class="hljs-number">4</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> i:<span class="hljs-number">8</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> m;<br>&#125;; <span class="hljs-comment">//sizeof(A)大小为8.  1+2，padding5</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">name1</span>&#123;<br><span class="hljs-type">char</span> str;<br><span class="hljs-type">short</span> x;<br><span class="hljs-type">int</span> num;<br>&#125;; <span class="hljs-comment">// sizeof(name1)大小为8.  1 padding1，2+2+4</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">name2</span>&#123;<br><span class="hljs-type">char</span> str;<br><span class="hljs-type">int</span> num;<br><span class="hljs-type">short</span> x;<br>&#125;; <span class="hljs-comment">//sizeof(name2)大小为12.   1 padding3，4+4+4=12</span><br></code></pre></td></tr></table></figure><h3 id="C语言中-struct与-union的区别是什么"><a href="#C语言中-struct与-union的区别是什么" class="headerlink" title="C语言中 struct与 union的区别是什么?"></a>C语言中 struct与 union的区别是什么?</h3><p>struct（结构体）与 union（联合体）是C语言中两种不同的数据结构，两者都是常见的复合结构，其区别主要表现在以下两个方面。<br>1、结构体与联合体虽然都是由多个不同的数据类型成员组成的，但不同之处在于：<br>联合体中所有成员共用一块地址空间，即联合体只存放了一个被选中的成员，而结构体中所有成员占用空间是累加的，其所有成员都存在，不同成员会存放在不同的地址。<br>在计算一个结构型变量的总长度时，其内存空间大小等于所有成员长度之和（需要考虑字节对齐，结构体对齐），而在联合体中，所有成员不能同时占用内存空间，它们不能同时存在，所以一个联合型变量的长度等于其最长的成员的长度。<br>2、对于联合体的不同成员赋值，将会对它的其他成员重写，原来成员的值就不存在了，而对结构体的不同成员赋值是互不影响的。</p><h3 id="头文件的学习："><a href="#头文件的学习：" class="headerlink" title="头文件的学习："></a>头文件的学习：</h3><p>双引号一般用于自己写的头文件，在同一目录下，可以直接#include “stdio.h”；如果不在同一目录下，则需要 #include “anotherDir&#x2F;stdio.h”<br>尖括号不能用于自己写的头文件，它是默认去系统指定的目录下找，如&#x2F;usr&#x2F;include、 &#x2F;usr&#x2F;local&#x2F;include等<br>放在&#x2F;usr&#x2F;include的头文件也可以用双引号来包含，双引号包含的头文件在当前目录找不到，还会在系统指定的目录下去找。<br>可以用include 包含.c文件，预处理的时候依然是展开代码，因此不能出现变量和函数的重复定义。<br>&lt; &gt; 效率更高，因为它直接查找系统路径。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span>    </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span>            </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mysql/mysql.h&gt;</span>                 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;jsoncpp/json/json.h&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="关键字volatile有什么含意-并给出三个不同的例子。"><a href="#关键字volatile有什么含意-并给出三个不同的例子。" class="headerlink" title="关键字volatile有什么含意? 并给出三个不同的例子。"></a>关键字volatile有什么含意? 并给出三个不同的例子。</h3><p>一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是volatile变量的几个例子： <br>1、并行设备的硬件寄存器（如：状态寄存器）<br>2、 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables) <br>3、 多线程应用中被几个任务共享的变量 </p><h4 id="一个参数既可以是const还可以是volatile吗？解释为什么。"><a href="#一个参数既可以是const还可以是volatile吗？解释为什么。" class="headerlink" title="一个参数既可以是const还可以是volatile吗？解释为什么。"></a>一个参数既可以是const还可以是volatile吗？解释为什么。</h4><p>是的。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。</p><h4 id="一个指针可以是volatile-吗？解释为什么。"><a href="#一个指针可以是volatile-吗？解释为什么。" class="headerlink" title="一个指针可以是volatile 吗？解释为什么。"></a>一个指针可以是volatile 吗？解释为什么。</h4><p>是的。尽管这并不很常见。一个例子是当一个中服务子程序修该一个指向一个buffer的指针时。</p><h4 id="下面的函数有什么错误："><a href="#下面的函数有什么错误：" class="headerlink" title="下面的函数有什么错误："></a>下面的函数有什么错误：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">square</span><span class="hljs-params">(<span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> *ptr)</span><br> &#123; <br>    <span class="hljs-keyword">return</span> *ptr * *ptr; <br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码有点变态。这段代码的目的是用来返指针<em>ptr指向值的平方，但是，由于</em>ptr指向一个volatile型参数，编译器将产生类似下面的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">square</span><span class="hljs-params">(<span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> *ptr)</span><br>&#123; <br>    <span class="hljs-type">int</span> a,b;<br>    a = *ptr;<br>    b = *ptr; <br>    <span class="hljs-keyword">return</span> a * b; <br>&#125;<br></code></pre></td></tr></table></figure><p>由于*ptr的值可能被意想不到地改变，因此a和b可能是不同的。结果，这段代码可能返不是你所期望的平方值！正确的代码如下： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-title function_">square</span><span class="hljs-params">(<span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> *ptr)</span> <br>&#123; <br>    <span class="hljs-type">int</span> a; <br>    a = *ptr; <br>    <span class="hljs-keyword">return</span> a * a; <br>&#125; <br></code></pre></td></tr></table></figure><h3 id="头文件中的-ifndef-define-endif-干什么用？"><a href="#头文件中的-ifndef-define-endif-干什么用？" class="headerlink" title="头文件中的 ifndef&#x2F;define&#x2F;endif  干什么用？"></a>头文件中的 ifndef&#x2F;define&#x2F;endif  干什么用？</h3><p>防止该头文件被重复引用。  </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>网络通信</title>
    <link href="/2025/04/29/tcp-udp/"/>
    <url>/2025/04/29/tcp-udp/</url>
    
    <content type="html"><![CDATA[<h2 id="计算机网路"><a href="#计算机网路" class="headerlink" title="计算机网路"></a>计算机网路</h2><h3 id="网络发展历史"><a href="#网络发展历史" class="headerlink" title="网络发展历史"></a>网络发展历史</h3><p>1、最开始 设备A-B通信通过网口，网线连接进行通信<br>2、当网口过多时，采用集线器：将电信号转发到所有出口（广播）。–物理层 需要全局唯一的名字作为标识，你把这个更高端的名字称为 MAC 地址。添加数据链路层头部。<br>3、广播：既不安全，又不节省网络资源 。采用交换机，只发给目标 MAC 地址指向的那台电脑。–数据链路层。通过端口映射发到目标MAC地址，接收方做出响应。以太网工作在数据链路层。<br>4、交换机已经无法记录过于庞大的MAC地址和端口的映射关系。路由器：一台独立的拥有 MAC 地址的设备，并且可以把数据包做一次转发。  –网络层。   </p><h3 id="假设设备A给设备C发数据包，怎么知道是否要通过路由器转发呢？"><a href="#假设设备A给设备C发数据包，怎么知道是否要通过路由器转发呢？" class="headerlink" title="假设设备A给设备C发数据包，怎么知道是否要通过路由器转发呢？"></a>假设设备A给设备C发数据包，怎么知道是否要通过路由器转发呢？</h3><p>通过子网，同一个子网基本意味着同一个网段。<br>通过IP与子网掩码按位与运算求出网络号。如果源 IP 与目的 IP 处于一个子网，直接将包通过交换机发出去，因为交换机工作在OSI模型的第二层（数据链路层），它能够识别数据包中的目标MAC地址，并将数据包直接转发到目标设备。如果源 IP 与目的 IP 不处于一个子网，属于不同的网络段，由于路由器工作在OSI模型的第三层（网络层），因此需要交给路由器去处理。<br>假设：<br>A电脑：192.168.0.1 &amp; 255.255.255.0 &#x3D; 192.168.0.0                        B电脑：192.168.0.2 &amp; 255.255.255.0 &#x3D; 192.168.0.0<br>C电脑：192.168.1.1 &amp; 255.255.255.0 &#x3D; 192.168.1.0                        D电脑：192.168.1.2 &amp; 255.255.255.0 &#x3D; 192.168.1.0<br>即A与B 在同一个子网，C与D 在同一个子网，但是A与C就不在同一个子网，与D也不在同一个子网。</p><h3 id="网络编程三要素"><a href="#网络编程三要素" class="headerlink" title="网络编程三要素"></a>网络编程三要素</h3><p>IP地址、端口、协议。<br>IP地址：IP（Internet Protocol）：全称”互联网协议地址”，设备在网络中的地址，是唯一的标识。常见的IP分类为：IPv4和IPv6。<br>端口：应用程序在设备中唯一的标识，比如80 端口通常是 Web 服务器用的，22 端口通常是远程登录服务器用的，而对于浏览器(客户端)中的每个标签栏都是一个独立的进程，由操作系统分配临时的端口号。HTTPS：443。HTTP代理：8080。<br>协议: 数据在网络中传输的规则，常见的协议有UDP协议和TCP协议。</p><h3 id="DNS作用"><a href="#DNS作用" class="headerlink" title="DNS作用"></a>DNS作用</h3><p>DNS是互联网的域名系统，用于查询服务器域名对应的IP地址。DNS中的域名都是用句点来分隔的，比如 <a href="http://www.server.com/">www.server.com</a>. ，这里的句点代表了不同层次之间的界限。在域名中，越靠右的位置表示其层级越高。IP地址基本寻路、域名解析流程、 域名解析和访问过程如下：<br>用户输入域名：用户在计算机的浏览器中输入一个域名（例如：<a href="http://www.itcast.cn/">http://www.itcast.cn</a> ）。<br>DNS解析：计算机首先检查本地缓存（如hosts文件或浏览器缓存）中是否有该域名对应的IP地址。如果没有找到，计算机会向配置的DNS服务器发送一个DNS查询请求，询问域名对应的IP地址。DNS服务器收到请求后，会在其数据库中查找对应的IP地址。如果找到，就直接返回给计算机；如果没有找到，DNS服务器会继续向上级DNS服务器查询，直到找到为止。<br>获取IP地址：DNS服务器将查询到的IP地址返回给计算机。<br>建立连接：计算机使用获取到的IP地址，通过网络向目标服务器（例如：黑马程序员服务器）发起连接请求。<br>服务器处理请求：目标服务器接收到连接请求后，根据请求的内容（如URL、HTTP方法等）处理请求。服务器可能需要访问数据库、执行脚本等操作来生成响应数据。<br>返回数据：目标服务器将处理结果（如HTML页面、图片、视频等）封装成HTTP响应报文，发送回计算机。<br>展示数据：计算机接收到响应数据后，浏览器解析并展示这些数据，最终呈现给用户。<br>总结：即本地缓存-&gt;本地DNS-&gt; 1 先问根DNS ； 2、再问顶级域名服务器；3、再问权威DNS服务器； 4、权威DNS服务器告知-&gt; 本地DNS 将IP返回客户端并进行访问，浏览器解析服务器的http响应报文，在页面进行显示。通过 DNS 获取到 IP 后，就可以把 HTTP 的传输工作交给操作系统中的协议栈。</p><h3 id="应用程序（浏览器）如何工作？"><a href="#应用程序（浏览器）如何工作？" class="headerlink" title="应用程序（浏览器）如何工作？"></a>应用程序（浏览器）如何工作？</h3><p>应用程序（浏览器）通过调用 Socket 库，来委托协议栈工作。协议栈的上半部分有两块，分别是负责收发数据的 TCP 和 UDP 协议，这两个传输协议会接受应用层的委托执行收发数据的操作。协议栈的下面一半是用 IP 协议控制网络包收发操作，在互联网上传数据时，数据会被切分成一块块的网络包，而将网络包发送给对方的操作就是由 IP 负责的。此外 IP 中还包括 ICMP 协议和 ARP 协议，ICMP 用于告知网络包传送过程中产生的错误以及各种控制信息，ARP 用于根据 IP 地址查询相应的以太网 MAC 地址。</p><h3 id="OSI-七层模型及其包含的协议如下"><a href="#OSI-七层模型及其包含的协议如下" class="headerlink" title="OSI 七层模型及其包含的协议如下"></a>OSI 七层模型及其包含的协议如下</h3><p>物理层：通过媒介传输比特,确定机械及电气规范,传输单位为bit，主要包括的协议为：IEE802.3 CLOCK RJ45。<br>数据链路层：将比特组装成帧和点到点的传递,传输单位为帧,主要包括的协议为MAC、 VLAN、 PPP。<br>网络层：负责数据包从源到宿的传递和网际互连，传输单位为包,主要包括的协议为IP ARP ICMP。<br>传输层：提供端到端的可靠报文传递和错误恢复，传输单位为报文，主要包括的协议为TCP UDP。<br>会话层：建立、管理和终止会话，传输单位为 SPDU，主要包括的协议为 RPC NFS。<br>表示层：对数据进行翻译、加密和压缩,传输单位为PPDU，主要包括的协议为JPEG ASII 。<br>应用层：允许访问OSI 环境的手段,传输单位为APDU，主要包括的协议为FTP HTTP DNS</p><h3 id="TCP-IP-四层模型"><a href="#TCP-IP-四层模型" class="headerlink" title="TCP&#x2F;IP 四层模型"></a>TCP&#x2F;IP 四层模型</h3><p>网络接口层（原物理层和数据链路层）：MAC、VLAN。<br>网络层: IP、ARP、ICMP<br>传输层: TCP、UDP ；<br>应用层（原会话层、表示层、应用层）: HTTP、DNS、SMT</p><h3 id="TCP的三次握手和四次挥手"><a href="#TCP的三次握手和四次挥手" class="headerlink" title="TCP的三次握手和四次挥手"></a>TCP的三次握手和四次挥手</h3><p>三次握手（Three-way Handshake）：<br>第一步：客户端向服务器发送一个SYN（同步）标志的数据包，请求建立连接。此时客户端进入 SYN_SENT 状态。<br>第二步：服务器收到请求后，确认收到，并发送一个带有 ACK（确认）和 SYN报文作为响应。同时，服务器还会分配资源用于接收客户端的数据。此时服务器进入 SYN_RCVD 状态。<br>第三步：客户端收到服务器的响应后，发送一个带有 ACK 标志的数据包作为最后确认。此时客户端进入 ESTABLISHED（已建立）状态，服务器接收到数据后进入 ESTABLISHED（已建立）状态，连接建立完成，可以开始传输数据。<br>四次挥手（Four-way Handshake）：<br>第一步：当客户端想要关闭连接时，发送一个带有 FIN（结束）标志的数据包给服务器。此时客户端进入 FIN_WAIT_1 状态。<br>第二步：服务器接收到关闭请求后，回复一个 ACK 标志的数据包来确认，并进入 CLOSE_WAIT 状态等待关闭信号。<br>第三步：当服务器确定自己已经完成所有传输任务后，发送一个带有 FIN 标志的数据包给客户端。此时服务器进入 LAST_ACK 状态。<br>第四步：客户端收到服务器的关闭请求后，发送一个 ACK 标志的数据包进行确认。此时客户端和服务器都进入 CLOSED（已关闭）状态</p><h3 id="TCP-握手为什么是三次，为什么不能是两次？不能是四次？"><a href="#TCP-握手为什么是三次，为什么不能是两次？不能是四次？" class="headerlink" title="TCP 握手为什么是三次，为什么不能是两次？不能是四次？"></a>TCP 握手为什么是三次，为什么不能是两次？不能是四次？</h3><p>如果只有两次握手，过程可能是：客户端发送SYN报文。服务器发送ACK确认报文。这种情况下，引发服务端误判造成无效连接，如果客户端发送的SYN报文在网络中延迟到达，服务器可能会误以为这是一个新的连接请求，从而导致错误；其次是因为两次握手无法确保双方都能接收和发送数据，只能确保服务器可以接收客户端的数据，但无法确保客户端可以接收服务器的数据。<br>如果采用四次握手，过程可能是：客户端发送SYN报文。服务器发送SYN+ACK报文。客户端发送ACK确认报文。服务器再发送一个ACK确认报文。   这种情况下，存在冗余和效率问题，四次握手会增加通信的开销，降低效率。TCP协议的设计目标之一是高效地建立连接；也会引发不必要的确认，造成资源浪费：第四次握手的ACK确认是多余的，因为第三次握手的ACK已经足够确认客户端和服务器都准备好建立连接。</p><h3 id="为什么连接的时候是三次握手，关闭的时候却是四次握手？"><a href="#为什么连接的时候是三次握手，关闭的时候却是四次握手？" class="headerlink" title="为什么连接的时候是三次握手，关闭的时候却是四次握手？"></a>为什么连接的时候是三次握手，关闭的时候却是四次握手？</h3><p>因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，“你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p><h3 id="TCP序列号和确认号是如何变化的？"><a href="#TCP序列号和确认号是如何变化的？" class="headerlink" title="TCP序列号和确认号是如何变化的？"></a>TCP序列号和确认号是如何变化的？</h3><p>发送的TCP报文：<br>公式一：序列号&#x3D;上一次发送的序列号+len(数据长度)。特殊情况，如果上一次发送的报文是 SYN报文或者 FIN 报文，则改为 上一次发送的序列号 +1。<br>公式二：确认号&#x3D;上一次收到的报文中的序列号+len(数据长度)。特殊情况，如果收到的是 SYN报文或者 FIN 报文，则改为上一次收到的报文中的序列号+1。</p><h3 id="没有-listen，能建立-TCP-连接吗？"><a href="#没有-listen，能建立-TCP-连接吗？" class="headerlink" title="没有 listen，能建立 TCP 连接吗？"></a>没有 listen，能建立 TCP 连接吗？</h3><p>可以的，客户端是可以自己连自己的形成连接(TCP自连接)，也可以两个客户端同时向对方发出请求建立连接(TCP同时打开)，这两个情况都有个共同点，就是没有服务端参与，也就是没有listen，就能建立连接。执行 listen 方法时，会创建半连接队列和全连接队列。三次握手的过程中会在这两个队列中暂存连接信息。所以形成连接，前提是你得有个地方存放着，方便握手的时候能根据IP+端口等信息找到对应的socket.</p><h3 id="TCP-的主要特点是什么？"><a href="#TCP-的主要特点是什么？" class="headerlink" title="TCP 的主要特点是什么？"></a>TCP 的主要特点是什么？</h3><p>可靠性：TCP使用确认和重传机制来确保数据的可靠传输。它会追踪每个发送的数据段，并等待接收方发送确认信息。如果发送方未收到确认或超时，则重新发送该数据段。<br>有序性：TCP保持数据的顺序传输，即接收方按照发送方发送的顺序将数据重组。<br>流量控制：TCP通过滑动窗口机制来控制流量。接收方可以告诉发送方它所能接受的最大数据量，以避免过载导致丢包或延迟。<br>拥塞控制：TCP具有拥塞控制机制，以防止网络拥塞。它通过动态调整发送速率、检测丢包并减少发送速率来维护网络质量。<br>面向连接：在通信之前，TCP需要在客户端和服务器之间建立连接。这种连接是全双工的，并且在通信结束后会释放。<br>支持多种应用层协议：TCP不仅提供了基本的传输功能，还支持许多应用层协议（如HTTP、FTP等）进行高层次的通信。</p><h3 id="TCP是如何保证可靠传输的？"><a href="#TCP是如何保证可靠传输的？" class="headerlink" title="TCP是如何保证可靠传输的？"></a>TCP是如何保证可靠传输的？</h3><h4 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h4><p>解决数据丢失的问题，通过序列号 + 确认应答机制；<br>怎么重传？   1、超时重传（启动定时器，超时间隔加倍），以时间为基准；2、快速重传   以数据驱动重传 （反馈信息（通常是确认或拥塞信号）<br>快速重传是传一个还是重传后面左右的数据包？<br>机制1：SACK（选择确认）–将已收到的数据告知发送方，只重传丢失的数据 （使发送方知道哪些数据段需要被重传，提高了重传的精确性和效率。） ；<br>机制2：D-SACK（重复选择确认） 把重复收到的包通过 SACK 告知发送方，选项中实现，来判读是数据丢失情况的哪一种（了解到丢失的数据包的范围，从而避免不必要的重传）<br>数据丢失情况有哪几种？  1、发送时，数据包丢失    2、ack丢失（ack不会重传）     3、网络延时</p><h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p>解决了无需为每个数据应答，实现发送端发送多个，而只需要一个ack响应<br>窗口：没有应答的情况下，发送方可以发送多少数据（可用窗口）<br>滑动：收到确认后，移动窗口<br>发送方的滑动窗口由接收方的滑动窗口决定</p><h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>根据接收方的处理能力限制发送方的数据量<br>接收方的处理能力，recv buffer一直没有经系统调用取出，会导致可用窗口越来越小<br>怎么控制？   先收缩发送窗口，过段时间缩小缓冲区recv buffer大小</p><h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p>发生网络拥塞，如果继续发送，会造成更多的时延，更多的丢包，因此需要拥塞控制<br>拥塞窗口cwnd：拥塞窗口会根据网络的拥塞程度动态变换。 若发生超时重传，那么就说明发生网络拥塞；如果是快速重传，丢失部分数据。<br>发送方窗口&#x3D;min(拥塞窗口(发送方窗口的一种)，接收方窗口)。<br>怎么进行拥塞控制？<br>1、慢启动。最开始发送方的拥塞窗口为 1，由小到大逐渐增大发送窗口和拥塞窗口，达到慢启动门限前（ssthresh），呈指数增加。当发送方每收到一个 ACK，拥塞窗囗cwnd 的大小就会加 1。当cwnd &lt; ssthresh 时，使用慢启动算法，当cwnd &gt;&#x3D; ssthresh 时，就会使用拥塞避免算法。一般来说 ssthresh 的大小是 65535 字节。<br>2、拥塞避免。进入拥塞避免算法后， 每当收到一个 ACK 时，cwnd 增加 1&#x2F;cwnd，呈线性增加<br>3、拥塞发生。线性增加到一定值时拥塞发生，拥塞发生会引起数据包重传，重传机制有两种。<br>超时重传造成。 ssthresh &#x3D; cwnd &#x2F; 2  , cwnd  &#x3D;  1 (恢复为 cwnd 初始化值，这里假定 cwnd 初始化值 1)，重新开始慢启动，方式激进，数据流丢失，会造成网络卡顿；<br>快速重传造成（更优）。cwnd &#x3D; cwnd &#x2F; 2 ，ssthread &#x3D; cwnd 。进入快速恢复<br>4、快速恢复。拥塞窗口 cwnd&#x3D;ssthresh+3 (3的意思是确认有3个重复确认的数据包被收到了)；重传丢失的数据包；如果再收到重复的 ACK，那么 cwnd 增加 1；如果收到新数据的 ACK 后，把 cwnd 设置为拥塞发送中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态;采用快恢复算法时，慢开始只在建立连接和网络超时才使用。</p><h3 id="达到什么情况的时候开始减慢增长的速度？"><a href="#达到什么情况的时候开始减慢增长的速度？" class="headerlink" title="达到什么情况的时候开始减慢增长的速度？"></a>达到什么情况的时候开始减慢增长的速度？</h3><p>1.cwnd&gt;慢开始门限：停止使用慢开始算法，转而采用拥塞避免算法，拥塞窗口的增长速度会从指数增长变为线性增长，减慢增长速度<br>2.出现丢包情况：在慢开始和拥塞避免阶段，一旦发现网络拥塞（如未按时收到确认），TCP会将ssthresh设置为当前cwnd的一半，并将cwnd重置为1，然后重新进入慢开始阶段。这样，TCP会减慢增长速度并尝试恢复网络稳定性。<br>3.连续收到三个重复确认：在快重传和快恢复阶段，当发送方连续收到三个重复确认时，TCP会执行快恢复算法。此时，虽然cwnd不会重置为1，但ssthresh会减半，cwnd会设置为ssthresh减半后的值，并继续执行拥塞避免算法。这样，TCP也会减慢增长速度并尝试恢复网络稳定性。</p><h3 id="拔掉网线后，原本的TCP连接还存在吗？"><a href="#拔掉网线后，原本的TCP连接还存在吗？" class="headerlink" title="拔掉网线后，原本的TCP连接还存在吗？"></a>拔掉网线后，原本的TCP连接还存在吗？</h3><p>客户端拔掉网线后，并不会直接影响 TCP 连接状态。所以，拔掉网线后，TCP 连接是否还会存在，关键要看拔掉网线之后，有没有进行数据传输。有数据传输的情况：在客户端拔掉网线后，如果服务端发送了数据报文，在服务端重传次数没有达到最大值之前，客户端就插回了网线，双方原本的 TCP 连接还是能正常存在。在客户端拔掉网线后，如果服务端发送了数据报文，在客户端插回网线之前，服务端重传次数达到了最大值时，服务端就会断开 TCP 连接。等到客户端插回网线后，向服务端发送了数据，因为服务端已经断开了与客户端相同四元组的 TCP 连接，所以就会回 RST 报文，客户端收到后就会断开 TCP 连接。至此，双方的 TCP 连接都断开了。         没有数据传输的情况：如果双方都没有开启 TCP keepalive 机制，那么在客户端拔掉网线后，如果客户端一直不插回网线，那么客户端和服务端的 TCP 连接状态将会一直保持存在。如果双方都开启了 TCP keepalive 机制，那么在客户端拔掉网线后，如果客户端一直不插回网线，TCPkeepalive 机制会探测到对方的 TCP 连接没有存活，于是就会断开 TCP 连接。而如果在 TCP 探测期间客户端插回了网线，那么双方原本的 TCP 连接还是能正常存在。</p><h3 id="TCP-协议有什么缺陷？"><a href="#TCP-协议有什么缺陷？" class="headerlink" title="TCP 协议有什么缺陷？"></a>TCP 协议有什么缺陷？</h3><p>升级 TCP 的工作很困难；TCP 建立连接的延迟；TCP 存在队头阻塞问题；网络迀移需要重新建立 TCP 连接;</p><h3 id="UDP的三种通信方式"><a href="#UDP的三种通信方式" class="headerlink" title="UDP的三种通信方式"></a>UDP的三种通信方式</h3><p>单播：单台主机与单台主机之间的通信。<br>广播：当前主机与所在网络中的所有主机通信。<br>组播：当前主机与选定的一组主机的通信。</p><h3 id="UDP如何实现广播？"><a href="#UDP如何实现广播？" class="headerlink" title="UDP如何实现广播？"></a>UDP如何实现广播？</h3><p>使用广播地址：255.255.255.255。具体操作：<br>1、发送端发送的数据包的目的地写的是广播地址、且指定端口。（255.255.255.255, 9999）。<br>2、本机所在网段的其他主机的程序只要注册对应端口（9999）就可以收到消息了。</p><h3 id="UDP如何实现组播？"><a href="#UDP如何实现组播？" class="headerlink" title="UDP如何实现组播？"></a>UDP如何实现组播？</h3><p>使用组播地址：224.0.0.0 ~ 239.255.255.255。 具体操作：<br>1、发送端的数据包的目的地是组播IP  (例如：224.0.1.1,  端口：9999)。<br>2、接收端必须绑定该组播IP(224.0.1.1)，端口还要注册发送端的目的端口9999 ，这样即可接收该组播消息。DatagramSocket的子类MulticastSocket可以在接收端绑定组播IP。</p><h3 id="UDP协议为什么不可靠？"><a href="#UDP协议为什么不可靠？" class="headerlink" title="UDP协议为什么不可靠？"></a>UDP协议为什么不可靠？</h3><p>无连接：UDP是一种无连接的协议，发送端和接收端之间不会建立持久的连接。这意味着每个UDP数据包都是独立的实体，没有先后顺序或依赖关系。<br>不提供确认机制：UDP在发送数据后不会收到接收端的确认消息，也就是说发送端不知道数据是否成功到达目标地址。如果发生丢包或者错误，UDP本身并没有重发机制。<br>不提供拥塞控制：TCP通过拥塞控制算法来防止网络拥塞，并适应网络负载变化。而UDP没有这样的机制，在网络负载高或者链路质量差的情况下容易造成丢包现象。<br>不保证数据顺序：由于UDP是无连接的，并且数据包是独立传输的，所以接收端可能以不同顺序接收到数据包。这可能导致乱序问题，需要应用层自行处理。</p><h3 id="TCP和UDP的区别和相同点？"><a href="#TCP和UDP的区别和相同点？" class="headerlink" title="TCP和UDP的区别和相同点？"></a>TCP和UDP的区别和相同点？</h3><p>相同点：都处于四层模型的传输层，都直接使用网络层的IP协议进行数据包的传输，依赖于IP地址来标识网络中的设备。<br>区别：<br>1、是否面向连接。  TCP面向连接； UDP面向无连接（因此不需要三次握手（连接）四次挥手（断开）），因此TCP允许双端同时收发数据（全双工、端对端），UDP支持一对一、一对多、多对一、多对多的传输。<br>2、数据传输方式。  TCP基于字节流（粘包–不一定是完整的数据包，在应用层进行粘包处理）；UDP基于报文传输<br>3、是否可靠。     TCP可靠传输（接收端一定会按序收到）；UDP不可靠传输（不保证交互顺序）<br>4、传输效率。     TCP效率低（传输层有tcp头–20字节、网络层有ip头、网络接口层有MAC头）；UDP效率高（UDP头–8字节）<br>5、应用场景。     要求数据准确且要求传输速度不高的场合使用TCP；要求实时性高并且丢数据不在乎的情况下使用UDP</p><h3 id="运行在TCP-或UDP的应用层协议分析"><a href="#运行在TCP-或UDP的应用层协议分析" class="headerlink" title="运行在TCP 或UDP的应用层协议分析"></a>运行在TCP 或UDP的应用层协议分析</h3><p>应用层协议：RTSP、NFS、SFTP等<br>运行在TCP协议上的协议：<br>HTTP（Hypertext Transfer Protocol，超文本传输协议），主要用于普通浏览。<br>HTTPS（HTTP over SSL，安全超文本传输协议）,HTTP协议的安全版本。<br>FTP（File Transfer Protocol，文件传输协议），用于文件传输。<br>POP3（Post Office Protocol, version 3，邮局协议），收邮件用。<br>SMTP（Simple Mail Transfer Protocol，简单邮件传输协议），用来发送电子邮件。<br>TELNET（Teletype over the Network，网络电传），通过一个终端（terminal）登陆到网络。<br>SSH（Secure Shell，用于替代安全性差的TELNET），用于加密安全登陆用。<br>运行在UDP协议上的协议：<br>BOOTP（Boot Protocol，启动协议），应用于无盘设备。<br>NTP（Network Time Protocol，网络时间协议），用于网络同步。<br>DHCP（Dynamic Host Configuration Protocol，动态主机配置协议），动态配置IP地址。</p><h3 id="编写一个socket网络编程"><a href="#编写一个socket网络编程" class="headerlink" title="编写一个socket网络编程"></a>编写一个socket网络编程</h3><p>基于 TCP-服务器<br>1、创建一个 socket，用函数 socket()<br>2、绑定 IP 地址、端口等信息到 socket 上，用函数 bind()<br>3、监听该端口的连接请求，用函数 listen()<br>4、接收客户端上来的连接，用函数 accept()<br>5、收发数据，用函数 send()和 recv()，或者 read()和 write()<br>6、关闭socket网络连接<br>基于 TCP-客户端<br>1、创建一个 socket，用函数 socket()<br>2、设置要连接的对方的 IP 地址和端口等属性<br>3、连接服务器，用函数 connect()<br>4、收发数据，用函数 send()和 recv()，或者 read()和 write()<br>5、关闭网络连接</p><h3 id="传递到-IP-层怎么知道报文该给哪个应用程序，它怎么区分-UDP-报文还是-TCP-报文"><a href="#传递到-IP-层怎么知道报文该给哪个应用程序，它怎么区分-UDP-报文还是-TCP-报文" class="headerlink" title="传递到 IP 层怎么知道报文该给哪个应用程序，它怎么区分 UDP 报文还是 TCP 报文"></a>传递到 IP 层怎么知道报文该给哪个应用程序，它怎么区分 UDP 报文还是 TCP 报文</h3><p>根据端口区分；看ip 头中的协议标识字段，17 是udp，6 是tcp</p><h3 id="linux系统如何收发数据包"><a href="#linux系统如何收发数据包" class="headerlink" title="linux系统如何收发数据包"></a>linux系统如何收发数据包</h3><p>Linux发送数据包的流程：应用层通过 系统调用 找到对应的Socket，把数据写到sk_buff中，写到send_buffer中，TCP的话同时克隆一个sk_buff（生成两个），而UDP只生成一个，经过IP层，通过DNS解析域名获取真实的IP地址同时加上MAC头（知道本地端的MAC地址和对应），加上帧头帧尾。该数据写到网卡驱动的发送列表，接着发起软中断，把发送列表的sk_buff写道DMA内存区域，网卡通过DMA取数据（没有CPU参与），取sk_buff发送出去，如果是TCP ，将克隆的那一份sk_buff删除，未来收到ack确认时把send buffer中的sk_buff删除<br>Linux接收数据包的流程：网卡接收数据包，通过DMA写到内存区域，网卡向CPU发起硬件中断，当 CPU 收到硬件中断请求后，暂时屏蔽其他硬件中断，根据中断表，调用已经注册的中断处理函数。接着发起软中断（数据全部从DMA中取出后，再接收下一个数据包，也即再次触发一次硬件中断），然后恢复刚才屏蔽的中断。通过网卡驱动进行校验，如果正确，解头，获得一个四元组（源IP 目的IP 源端口 目的端口），四元组索引到Socket，写到recv buffer，此时内核态工作结束。如果应用层进行read&#x2F;recv。则会通过socket系统调用recv buffer中的数据。</p><h3 id="HTTP常见的状态码有哪些？"><a href="#HTTP常见的状态码有哪些？" class="headerlink" title="HTTP常见的状态码有哪些？"></a>HTTP常见的状态码有哪些？</h3><p>1xx 类状态码属于提示信息，是协议处理中的一种中间状态，实际用到的比较少。<br>2xx 类状态码表示服务器成功处理了客户端的请求。[200 OK]是最常见的成功状态码，表示一切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据。[204 No Content]与 200 OK基本相同，但响应头没有 body 数据。[206 Partial content]是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分。<br>3xx 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是重定向。[301 Moved Permanently]表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。「302 Found」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。[304 Not Modified]不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，告诉客户端可以继续使用缓存资源，用于缓存控制。<br>4xx 类状态码表示客户端发送的报文有误，服务器无法处理，也就是错误码的含义。[400 Bad Request]表示客户端请求的报文有错误，但只是个笼统的错误。[403 Forbidden]表示服务器禁止访问资源，并不是客户端的请求出错。[404 Not Found]表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。<br>5xx 类状态码表示客户端请求报文正确，但是服务器处理时内部发生了错误。[500 Internal Server Error]与 400类似，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。[501 Not lmplemented]表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。[502 Bad Gateway]通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。[503 Service Unavailable]表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。</p><h3 id="HTTP-协议特点？"><a href="#HTTP-协议特点？" class="headerlink" title="HTTP 协议特点？"></a>HTTP 协议特点？</h3><p>1、简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有 GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于 HTTP 协议简单，使得HTTP 服务器的程序规模小，因而通信速度很快。<br>2、灵活：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记。<br>3、无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后， 即断开连接。采用这种方式可以节省传输时间。<br>4、无状态：HTTP 协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方 面，在服务器不需要先前信息时它的应答就较快。<br>5、支持B&#x2F;S 及 C&#x2F;S 模式。<br>6、默认端口 80<br>7、基于TCP 协议</p><h3 id="HTTP-和-HTTPS-的区别？"><a href="#HTTP-和-HTTPS-的区别？" class="headerlink" title="HTTP 和 HTTPS 的区别？"></a>HTTP 和 HTTPS 的区别？</h3><p>1、HTTP协议是以明文的方式在网络中传输数据，而HTTPS 协议传输的数据则是经过SSL&#x2F;TLS加密后的，HTTPS具有更高的安全性；<br>2、HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL&#x2F;TLS 的握手过程，才可进入加密报文传输；<br>3、HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。浏览器端安装对应的根证书；<br>4、HTTP 协议端口是80，HTTPS 协议端口是443。</p><h3 id="为什么HTTPS比HTTP更安全？"><a href="#为什么HTTPS比HTTP更安全？" class="headerlink" title="为什么HTTPS比HTTP更安全？"></a>为什么HTTPS比HTTP更安全？</h3><p>1、数据加密<br>HTTPS采用混合加密的方式，即在通信开始时使用非对称加密算法（如RSA、ECDHE）进行密钥交换，确保双方能够安全地共享一个对称加密的会话密钥。之后，双方使用这个会话密钥进行对称加密通信，这样既保证了加密的效率，又避免了密钥交换过程中的安全风险。TLS（传输层安全协议）中包含了多种对称加密算法（如AES、ChaCha20）供选择，这些算法都经过严格的安全评估，能够有效抵抗各种破解尝试。<br>2、数据完整性<br>HTTPS使用摘要算法（如SHA-2）来确保数据的完整性。发送方在发送数据前会先对数据进行哈希运算，生成一个摘要，并将这个摘要与数据一起发送给接收方。接收方在收到数据后，也会对数据进行哈希运算，并将结果与接收到的摘要进行对比，以验证数据在传输过程中是否被篡改。<br>3、身份认证<br>HTTPS通过数字证书来实现身份认证。数字证书由可信的证书颁发机构（CA）签发，包含了网站的公钥、域名、有效期等信息，并经过CA的私钥签名。浏览器在访问HTTPS网站时，会验证网站证书的有效性，包括证书是否由受信任的CA签发、证书是否过期、证书中的域名是否与访问的域名一致等。（防范中间人攻击）。除了证书外，HTTPS还使用数字签名来确保消息的真实性和完整性。发送方在发送消息时，会使用自己的私钥对消息的摘要进行加密（防范中间人攻击），生成数字签名，并将数字签名与消息一起发送给接收方。接收方在收到消息后，会使用发送方的公钥对数字签名进行解密，并验证消息的摘要是否与解密后的摘要一致，从而确认消息的真实性和完整性。</p><h3 id="搜索baidu，会用到计算机网络中的什么层？每层是干什么的"><a href="#搜索baidu，会用到计算机网络中的什么层？每层是干什么的" class="headerlink" title="搜索baidu，会用到计算机网络中的什么层？每层是干什么的"></a>搜索baidu，会用到计算机网络中的什么层？每层是干什么的</h3><p>浏览器要将URL 解析为IP 地址，解析域名就要用到DNS 协议，首先主机会查询DNS 的缓存，如果没有就给本地DNS 发送查询请求。DNS 查询分为两种方式，一种是递归查询，一种是迭代查询。如果是迭代查询，本地的DNS 服务器，向根域名服务器发送查询请求，根域名服务器告知该域名的一级域名服务器，然后本地服务器给该一级域名服务器发送查询请求，然后依次类推直到查询到该域名的IP地址。DNS 服务器是基于UDP 的，因此会用到UDP 协议。</p><h3 id="一个完整的网址都包括那些内容？"><a href="#一个完整的网址都包括那些内容？" class="headerlink" title="一个完整的网址都包括那些内容？"></a>一个完整的网址都包括那些内容？</h3><p>网址简化： 协议:&#x2F;&#x2F;域名:端口号&#x2F;资源位置?参数&#x3D;值<br>资源位置，用于描述WEB资源在服务器上的位置。参数&#x3D;值，浏览器和服务器交互传递的数据。其中， ? 是参数和路径连接的符号（第一个参数和路径拼接使用？）； &amp; 是参数和参数之间连接的符号（参数和参数之间的拼接使用 &amp;）<br>完整的网址(url)中文版本：协议:&#x2F;&#x2F;主机名(域名):端口号&#x2F;路径&#x2F;文件名?查询字符串#锚点<br>协议：指定访问资源的协议。主机名（域名）：指定资源所在的服务器地址。端口号：指定服务器上运行的服务端口（可选，默认端口可以省略）。路径：指定服务器上资源的具体路径，<a href="http://www.baidu.com访问服务器根路径(/%EF%BC%89%E3%80%82%E6%9F%A5%E8%AF%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%9A%E4%BC%A0%E9%80%92%E9%A2%9D%E5%A4%96%E7%9A%84%E5%8F%82%E6%95%B0%E7%BB%99%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E5%8F%AF%E9%80%89%EF%BC%89%E3%80%82%E9%94%9A%E7%82%B9%EF%BC%9A%E6%8C%87%E5%AE%9A%E9%A1%B5%E9%9D%A2%E5%86%85%E7%9A%84%E6%9F%90%E4%B8%AA%E7%89%B9%E5%AE%9A%E4%BD%8D%E7%BD%AE%EF%BC%88%E5%8F%AF%E9%80%89%EF%BC%89%E3%80%82%E5%9F%9F%E5%90%8D%EF%BC%9A%E5%AD%90%E5%9F%9F%E5%90%8D%EF%BC%9Awww%EF%BC%8C%E8%A1%A8%E7%A4%BA%E4%B8%BB%E7%BD%91%E9%A1%B5%E6%9C%8D%E5%8A%A1%E3%80%82%E4%B8%BB%E5%9F%9F%E5%90%8D%EF%BC%9Abaidu%EF%BC%8C%E8%A1%A8%E7%A4%BA%E7%99%BE%E5%BA%A6%E5%85%AC%E5%8F%B8%E6%88%96%E5%85%B6%E7%BD%91%E7%AB%99%E3%80%82%E9%A1%B6%E7%BA%A7%E5%9F%9F%E5%90%8D%EF%BC%9Acom%EF%BC%8C%E8%A1%A8%E7%A4%BA%E5%95%86%E4%B8%9A%E7%94%A8%E9%80%94%E3%80%82">www.baidu.com访问服务器根路径（/）。查询字符串：传递额外的参数给服务器（可选）。锚点：指定页面内的某个特定位置（可选）。域名：子域名：www，表示主网页服务。主域名：baidu，表示百度公司或其网站。顶级域名：com，表示商业用途。</a></p><h3 id="GET-和-POST-有什么区别？"><a href="#GET-和-POST-有什么区别？" class="headerlink" title="GET 和 POST 有什么区别？"></a>GET 和 POST 有什么区别？</h3><p>GET 的语义是请求获取指定的资源，用于从服务器获获取资源。GET 方法是安全、幂等、可被缓存的，数据通过URL的查询字符串（Query String）传递。<br>POST的语义是根据请求负荷(报文主体)对指定的资源做出处理，具体的处理方式视资源类型而不同，用于向服务器提交数据，数据通过请求体（Request Body）传递。POST不安全，不是幂等，(大部分实现)不可缓存。<br>安全是指请求方法不会「破坏」服务器上的资源。幂等是指多次执行相同的操作，结果都是「相同」的。</p><h3 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h3><p>在传输一个IP 数据报的时候，确定了源IP 地址和目标 IP 地址后，就会通过主机「路由表」确定 IP 数据包下一跳。然而，网络层的下一层是数据链路层，所以还要知道「下一跳」的 MAC 地址。<br>主机会通过广播发送 ARP 请求，这个包中包含了想要知道的 MAC 地址的主机 IP 地址。当同个链路中的所有设备收到 ARP 请求时，会去拆开 ARP 请求包里的内容，如果 ARP 请求包中的目标IP 地址与自己的 IP 地址一致，那么这个设备就将自己的 MAC地址塞入 ARP 响应包返回给主机。</p><h3 id="公网服务器的-Mac-地址是在什么时机通过什么方式获取到的？arp-获取Mac地址只能获取到内网机器的-Mac-地址吧？"><a href="#公网服务器的-Mac-地址是在什么时机通过什么方式获取到的？arp-获取Mac地址只能获取到内网机器的-Mac-地址吧？" class="headerlink" title="公网服务器的 Mac 地址是在什么时机通过什么方式获取到的？arp 获取Mac地址只能获取到内网机器的 Mac 地址吧？"></a>公网服务器的 Mac 地址是在什么时机通过什么方式获取到的？arp 获取Mac地址只能获取到内网机器的 Mac 地址吧？</h3><p>在发送数据包时，如果目标主机不是本地局域网，填入的MAC地址是路由器，也就是把数据包转发给路由器，路由器一直转发下一个路由器，直到转发到目标主机的路由器，发现 IP 地址是自己局域网内的主机，就会 arp 请求获取目标主机的 MAC 地址，从而转发到这个服务器主机。<br>转发的过程中，源IP地址和目标IP地址是不会变的（前提：没有使用 NAT 网络的），源 MAC 地址和目标 MAC 地址是会变化的</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于HEXO</title>
    <link href="/2025/04/23/hexo/"/>
    <url>/2025/04/23/hexo/</url>
    
    <content type="html"><![CDATA[<p>博客美化记录</p><h2 id="Fluid主题博客记录"><a href="#Fluid主题博客记录" class="headerlink" title="Fluid主题博客记录"></a>Fluid主题博客记录</h2><h3 id="关于Markdown图片显示问题"><a href="#关于Markdown图片显示问题" class="headerlink" title="关于Markdown图片显示问题"></a>关于Markdown图片显示问题</h3><p>网上很多方案，比如本地和使用网络图片，存在两个弊端：<br>1、本地图片存在于本地地址，开源分享无法显示；<br>2、网络图片当被删除后，该博客的上的图片也会无法加载；</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>采用PicGo结合Github仓库，将本地图片上传到仓库中。</p><h4 id="如何获取Token"><a href="#如何获取Token" class="headerlink" title="如何获取Token"></a>如何获取Token</h4><p>1、登录Github，进去Setting<br>2、点击左侧菜单点击开发者设置Developer Setting选项<br>3、点击个人访问令牌 Personal access tokens<br>4、生成新的令牌</p><h4 id="PicGo图片上传失败"><a href="#PicGo图片上传失败" class="headerlink" title="PicGo图片上传失败"></a>PicGo图片上传失败</h4><blockquote><p>确保Github上获取了正确的Token并且没有复制错误。<br>设置正确的仓库名，一般为“用户名&#x2F;仓库名”格式<br>设置正确的自定义域名，如 <a href="https://raw.githubusercontent.com/user/blog/main">https://raw.githubusercontent.com/user/blog/main</a> ，user和blog换成自己的名字</p></blockquote><h3 id="通过js美化页面主题"><a href="#通过js美化页面主题" class="headerlink" title="通过js美化页面主题"></a>通过js美化页面主题</h3><!-- <pre> --><!-- </pre> --><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">custom_js:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/DynamicRibbon.min.js</span> <span class="hljs-comment"># 动态彩带</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/runtime.min.js</span> <span class="hljs-comment"># 运行时间</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/Ribbon.min.js</span> <span class="hljs-comment"># 静态彩带</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/DynamicLine.min.js</span> <span class="hljs-comment"># 动态黑色线条</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/snowflake.min.js</span> <span class="hljs-comment"># 小雪花飘落</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/Cherry.min.js</span> <span class="hljs-comment">#樱花飘落</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/star.min.js</span> <span class="hljs-comment"># 鼠标跟随小星星</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/containsWord.min.js</span> <span class="hljs-comment"># 鼠标点击出字</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/love.min.js</span> <span class="hljs-comment">#鼠标点击出爱心</span><br><br><span class="hljs-attr">custom_css:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/shubiao.css</span> <span class="hljs-comment">#鼠标指针</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/scroll.css</span> <span class="hljs-comment"># 滚动条颜色</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/gradient.css</span> <span class="hljs-comment"># 头部打字机颜色效果渐变</span><br></code></pre></td></tr></table></figure><h4 id="解决PicGo手机端无法加载图片的问题"><a href="#解决PicGo手机端无法加载图片的问题" class="headerlink" title="解决PicGo手机端无法加载图片的问题"></a>解决PicGo手机端无法加载图片的问题</h4><p>在D:\MyBlog\myFirstBlog\themes\fluid\layout_partials\head.ejs文件修改meta信息（目录换成自己的），在head开始处添加如下内容，其他主题类似<br><code>&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;</code></p><!-- <code>&lt;meta name="referrer" content="no-referrer" /&gt;</code> --><h3 id="固定背景图片"><a href="#固定背景图片" class="headerlink" title="固定背景图片"></a>固定背景图片</h3><p>1、进入 ~&#x2F;blog&#x2F;themes&#x2F;fluid&#x2F;scripts 创建 injector.js 文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 全屏背景的需要导入这些js</span><br><span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">root</span>: siteRoot = <span class="hljs-string">&quot;/themes/fluid/source/&quot;</span> &#125; = hexo.<span class="hljs-property">config</span>;<br>hexo.<span class="hljs-property">extend</span>.<span class="hljs-property">injector</span>.<span class="hljs-title function_">register</span>(<span class="hljs-string">&quot;body_begin&quot;</span>, <span class="hljs-string">`&lt;div id=&quot;web_bg&quot;&gt;&lt;/div&gt;`</span>);<br>hexo.<span class="hljs-property">extend</span>.<span class="hljs-property">injector</span>.<span class="hljs-title function_">register</span>(<br>  <span class="hljs-string">&quot;body_end&quot;</span>,<br>  <span class="hljs-string">`&lt;script src=&quot;<span class="hljs-subst">$&#123;siteRoot&#125;</span>js/backgroundize.js&quot;&gt;&lt;/script&gt;</span><br><span class="hljs-string">  &lt;link defer rel=&quot;stylesheet&quot; href=&quot;<span class="hljs-subst">$&#123;siteRoot&#125;</span>css/backgroundize.css&quot; /&gt;</span><br><span class="hljs-string">  `</span><br>);<br></code></pre></td></tr></table></figure><p>2、进入 ~&#x2F;blog&#x2F;themes&#x2F;fluid&#x2F;source&#x2F;js 创建 backgroundize.js 文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> bannerContainer = $(<span class="hljs-string">&quot;#banner&quot;</span>);<br><span class="hljs-keyword">const</span> viewBg = $(<span class="hljs-string">&quot;#web_bg&quot;</span>);<br><span class="hljs-keyword">const</span> bannerMask = $(<span class="hljs-string">&quot;#banner .mask&quot;</span>);<br><span class="hljs-keyword">const</span> bg = $(bannerContainer).<span class="hljs-title function_">css</span>(<span class="hljs-string">&quot;background-image&quot;</span>);<br>$(viewBg).<span class="hljs-title function_">css</span>(<span class="hljs-string">&quot;background-image&quot;</span>, bg);<br>$(bannerContainer).<span class="hljs-title function_">css</span>(<span class="hljs-string">&quot;background-image&quot;</span>, <span class="hljs-string">&quot;url()&quot;</span>);<br><span class="hljs-keyword">const</span> color = $(bannerMask).<span class="hljs-title function_">css</span>(<span class="hljs-string">&quot;background-color&quot;</span>);<br>$(bannerMask).<span class="hljs-title function_">css</span>(<span class="hljs-string">&quot;background-color&quot;</span>, <span class="hljs-string">`rgba(0,0,0,0)`</span>);<br>$(viewBg).<span class="hljs-title function_">css</span>(<span class="hljs-string">&quot;background-color&quot;</span>, color);<br></code></pre></td></tr></table></figure><p>3、进入 ~&#x2F;blog&#x2F;themes&#x2F;fluid&#x2F;source&#x2F;css 创建 backgroundize.css 文件</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#web_bg</span> &#123;<br>    <span class="hljs-attribute">position</span>: fixed;<br>    <span class="hljs-attribute">z-index</span>: -<span class="hljs-number">999</span>;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">background-attachment</span>: local;<br>    <span class="hljs-attribute">background-position</span>: center;<br>    -webkit-<span class="hljs-attribute">background-size</span>: cover;<br>    -moz-<span class="hljs-attribute">background-size</span>: cover;<br>    <span class="hljs-attribute">background-size</span>: cover;<br>    <span class="hljs-attribute">background-repeat</span>: repeat;<br>  &#125;<br></code></pre></td></tr></table></figure><p>4、执行hexo cl ，之后hexo s或者hexo g -d都可以。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode</title>
    <link href="/2025/04/20/leetcode/"/>
    <url>/2025/04/20/leetcode/</url>
    
    <content type="html"><![CDATA[<p>数据结构与算法学习，Cpp实现，代码随想录、HOT100</p><h2 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h2><h3 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704 二分查找"></a>704 二分查找</h3><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">示例<span class="hljs-number">1</span>：<br>输入: nums = [<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>,<span class="hljs-number">12</span>], target = <span class="hljs-number">9</span>     <br>输出: <span class="hljs-number">4</span>       <br>解释: <span class="hljs-number">9</span> 出现在 nums 中并且下标为 <span class="hljs-number">4</span>     <br><br>示例 <span class="hljs-number">2</span>:<br>输入: nums = [<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>,<span class="hljs-number">12</span>], target = <span class="hljs-number">2</span>     <br>输出: <span class="hljs-number">-1</span>        <br>解释: <span class="hljs-number">2</span> 不存在 nums 中因此返回 <span class="hljs-number">-1</span>    <br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">solution</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span></span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>            <span class="hljs-type">int</span> middle=left+((right-left)/<span class="hljs-number">2</span>);<br>            <span class="hljs-keyword">if</span>(nums[middle]&lt; target)&#123;<br>                left = middle + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[middle]&gt;target)&#123;<br>                right = middle <span class="hljs-number">-1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> middle;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>；<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a>35. 搜索插入位置</h3><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。<br>请必须使用时间复杂度为 O(log n) 的算法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">示例 <span class="hljs-number">1</span>:<br>输入: nums = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>], target = <span class="hljs-number">5</span><br>输出: <span class="hljs-number">2</span><br><br>示例 <span class="hljs-number">2</span>:<br>输入: nums = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>], target = <span class="hljs-number">2</span><br>输出: <span class="hljs-number">1</span><br><br>示例 <span class="hljs-number">3</span>:<br>输入: nums = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>], target = <span class="hljs-number">7</span><br>输出: <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            <span class="hljs-type">int</span> m = l  + (r - l) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[m] &gt; target) &#123;<br>                r = m - <span class="hljs-number">1</span>;      <br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[m] &lt; target) &#123;<br>                l = m + <span class="hljs-number">1</span>;            <br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> m;          <br>            &#125;      <br>        &#125;<br>        <span class="hljs-keyword">return</span> l;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h3><p>给定一个n个元素有序的(升序)整型数组nums和一个目标值target，写一个函数搜素 nums 中的target，如果目标值存在返回下标，否则返回-1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">示例 <span class="hljs-number">1</span>：<br>输入：nums = [<span class="hljs-number">2</span>,<span class="hljs-number">7</span>,<span class="hljs-number">11</span>,<span class="hljs-number">15</span>], target = <span class="hljs-number">9</span><br>输出：[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br>解释：因为 nums[<span class="hljs-number">0</span>] + nums[<span class="hljs-number">1</span>] == <span class="hljs-number">9</span> ，返回 [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>] 。<br><br>示例 <span class="hljs-number">2</span>：<br>输入：nums = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>], target = <span class="hljs-number">6</span><br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br><br>示例 <span class="hljs-number">3</span>：<br>输入：nums = [<span class="hljs-number">3</span>,<span class="hljs-number">3</span>], target = <span class="hljs-number">6</span><br>输出：[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        std::unordered_map &lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; map;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-comment">// 遍历当前元素，并在map中寻找是否有匹配的key</span><br>            <span class="hljs-keyword">auto</span> iter = map.<span class="hljs-built_in">find</span>(target - nums[i]); <br>            <span class="hljs-keyword">if</span>(iter != map.<span class="hljs-built_in">end</span>()) &#123;<br>                <span class="hljs-keyword">return</span> &#123;iter-&gt;second, i&#125;;<br>            &#125;<br>            <span class="hljs-comment">// 如果没找到匹配对，就把访问过的元素和下标加入到map中</span><br>            map.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(nums[i], i)); <br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49. 字母异位词分组"></a>49. 字母异位词分组</h3><p>给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。<br>字母异位词 是由重新排列源单词的所有字母得到的一个新单词。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">示例 <span class="hljs-number">1</span>:<br>输入: strs = [<span class="hljs-string">&quot;eat&quot;</span>, <span class="hljs-string">&quot;tea&quot;</span>, <span class="hljs-string">&quot;tan&quot;</span>, <span class="hljs-string">&quot;ate&quot;</span>, <span class="hljs-string">&quot;nat&quot;</span>, <span class="hljs-string">&quot;bat&quot;</span>]<br>输出: [[<span class="hljs-string">&quot;bat&quot;</span>],[<span class="hljs-string">&quot;nat&quot;</span>,<span class="hljs-string">&quot;tan&quot;</span>],[<span class="hljs-string">&quot;ate&quot;</span>,<span class="hljs-string">&quot;eat&quot;</span>,<span class="hljs-string">&quot;tea&quot;</span>]]<br><br>示例 <span class="hljs-number">2</span>:<br>输入: strs = [<span class="hljs-string">&quot;&quot;</span>]<br>输出: [[<span class="hljs-string">&quot;&quot;</span>]]<br><br>示例 <span class="hljs-number">3</span>:<br>输入: strs = [<span class="hljs-string">&quot;a&quot;</span>]<br>输出: [[<span class="hljs-string">&quot;a&quot;</span>]]<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;<br>        <span class="hljs-comment">// 字符串排序，对应的值是数组</span><br>        unordered_map&lt;string, vector&lt;string&gt;&gt; data;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; s : strs)<br>        &#123;<br>            <span class="hljs-keyword">auto</span> key  =  s;<br>            <span class="hljs-built_in">sort</span>(key.<span class="hljs-built_in">begin</span>(), key.<span class="hljs-built_in">end</span>());<br>            <span class="hljs-comment">// 比如排序后的key aet对应的值有eat tea ate，</span><br>            <span class="hljs-comment">// 把原值与键对应</span><br>            data[key].<span class="hljs-built_in">push_back</span>(s);<br>        &#125;<br><br>        vector&lt;vector&lt;string&gt;&gt; ret;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; p : data)<br>        &#123;<br>            <span class="hljs-comment">// 按数组打印</span><br>            ret.<span class="hljs-built_in">push_back</span>(p.second);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128 最长连续序列"></a>128 最长连续序列</h3><p>给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。<br>请你设计并实现时间复杂度为 O(n) 的算法解决此问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">示例 <span class="hljs-number">1</span>：<br>输入：nums = [<span class="hljs-number">100</span>,<span class="hljs-number">4</span>,<span class="hljs-number">200</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>]<br>输出：<span class="hljs-number">4</span><br>解释：最长数字连续序列是 [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]。它的长度为 <span class="hljs-number">4</span>。<br><br>示例 <span class="hljs-number">2</span>：<br>输入：nums = [<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">9</span><br><br>示例 <span class="hljs-number">3</span>：<br>输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> current = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; nums.<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(nums[i] == (nums[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>))&#123;<br>                current++;<br>                res = <span class="hljs-built_in">max</span>(current, res);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                current = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><h3 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a>283. 移动零</h3><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。<br>请注意 ，必须在不复制数组的情况下原地对数组进行操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">示例 <span class="hljs-number">1</span>:<br>输入: nums = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">12</span>]<br>输出: [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">12</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br><br>示例 <span class="hljs-number">2</span>:<br>输入: nums = [<span class="hljs-number">0</span>]<br>输出: [<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[i] != <span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-comment">// 每次保证是0和非0的位置在交换</span><br>                <span class="hljs-built_in">swap</span>(nums[j++], nums[i]);    <br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a>11. 盛最多水的容器</h3><p>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。<br>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。<br>返回容器可以储存的最大水量。<br>说明：你不能倾斜容器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">示例 <span class="hljs-number">1</span>：<br>输入：[<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>]<br>输出：<span class="hljs-number">49</span> <br>解释：图中垂直线代表输入数组 [<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 <span class="hljs-number">49</span>。<br><br>示例 <span class="hljs-number">2</span>：<br>输入：height = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = height.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt; right)<br>        &#123;<br>            ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">min</span>(height[left], height[right]) * (right-left));<br>            <span class="hljs-keyword">if</span>(height[left] &lt; height[right])  left++;<br>            <span class="hljs-keyword">else</span> right--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>思路<br>双指针法：<br>1、使用两个指针，一个指向数组的起始位置（left），另一个指向数组的末尾位置（right）。<br>2、计算面积：计算当前两个指针所指向的线段与x轴构成的容器的面积，面积由较短的那条线的高度和两个指针之间的距离决定。<br>因此为了寻找可能更大的面积，移动较短的那条线的指针向内侧移动一位（移动较长的线的指针不会增加容器的高度），移动较短的线的指针有可能找到更高的线，从而增加面积。<br>3、更新最大面积：在每次移动指针后，计算新的面积，并更新最大面积。<br>4、重复步骤：重复上述过程，直到两个指针相遇。</p><h3 id="15、三数之和"><a href="#15、三数之和" class="headerlink" title="15、三数之和"></a>15、三数之和</h3><p>给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i !&#x3D; j、i !&#x3D; k 且 j !&#x3D; k ，同时还满足 nums[i] + nums[j] + nums[k] &#x3D;&#x3D; 0 。请你返回所有和为 0 且不重复的三元组。<br>注意：答案中不可以包含重复的三元组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp">示例 <span class="hljs-number">1</span>：<br>输入：nums = [<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-4</span>]<br>输出：[[<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]]<br>解释：<br>nums[<span class="hljs-number">0</span>] + nums[<span class="hljs-number">1</span>] + nums[<span class="hljs-number">2</span>] = (<span class="hljs-number">-1</span>) + <span class="hljs-number">0</span> + <span class="hljs-number">1</span> = <span class="hljs-number">0</span> 。<br>nums[<span class="hljs-number">1</span>] + nums[<span class="hljs-number">2</span>] + nums[<span class="hljs-number">4</span>] = <span class="hljs-number">0</span> + <span class="hljs-number">1</span> + (<span class="hljs-number">-1</span>) = <span class="hljs-number">0</span> 。<br>nums[<span class="hljs-number">0</span>] + nums[<span class="hljs-number">3</span>] + nums[<span class="hljs-number">4</span>] = (<span class="hljs-number">-1</span>) + <span class="hljs-number">2</span> + (<span class="hljs-number">-1</span>) = <span class="hljs-number">0</span> 。<br>不同的三元组是 [<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>] 和 [<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>] 。<br>注意，输出的顺序和三元组的顺序并不重要。<br><br>示例 <span class="hljs-number">2</span>：<br>输入：nums = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br>输出：[]<br>解释：唯一可能的三元组和不为 <span class="hljs-number">0</span> 。<br><br>示例 <span class="hljs-number">3</span>：<br>输入：nums = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br>输出：[[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]]<br>解释：唯一可能的三元组和为 <span class="hljs-number">0</span> 。<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[i] &gt; <span class="hljs-number">0</span> ) <span class="hljs-keyword">return</span> result;<br>            <span class="hljs-comment">// 错误去重a方法，将会漏掉-1,-1,2 这种情况</span><br>            <span class="hljs-comment">// if (nums[i] == nums[i + 1]) continue;</span><br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i<span class="hljs-number">-1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">int</span> left = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> right =  nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(right &gt; left)&#123;<br>                <span class="hljs-keyword">if</span>(nums[i] + nums[left] + nums[right] &gt; <span class="hljs-number">0</span>) right--;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[i] + nums[left] + nums[right] &lt; <span class="hljs-number">0</span>) left++;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    result.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-type">int</span>&gt;&#123;nums[i], nums[left], nums[right]&#125;);<br>                    <span class="hljs-comment">// 去重逻辑应该放在找到一个三元组之后，对b 和 c去重</span><br>                    <span class="hljs-keyword">while</span>(right &gt; left &amp;&amp; nums[right] == nums[right<span class="hljs-number">-1</span>]) right--;<br>                    <span class="hljs-keyword">while</span>(right &gt; left &amp;&amp; nums[left] == nums[left<span class="hljs-number">+1</span>]) left++;<br>                    right--;<br>                    left++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>思路：for循环 + 双指针法，获取三个值<br>1、定义返回值是个二元数组<br>2、要求三值和为0，先进行排序处理<br>3、答案中不能包含重复三元组，因此去重，包括nums[i] &#x3D;&#x3D; nums[i-1]， nums[right] &#x3D; nums[right-1]等方式进行去重</p><h3 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a>42. 接雨水</h3><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">示例 <span class="hljs-number">1</span>：<br>输入：height = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">6</span><br>解释：上面是由数组 [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>] 表示的高度图，在这种情况下，可以接 <span class="hljs-number">6</span> 个单位的雨水（蓝色部分表示雨水）<br><br>示例 <span class="hljs-number">2</span>：<br>输入：height = [<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>]<br>输出：<span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = height.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> lmax = <span class="hljs-number">0</span>, rmax = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>            lmax = <span class="hljs-built_in">max</span>(lmax, height[l]);<br>            rmax = <span class="hljs-built_in">max</span>(rmax, height[r]);<br>            <span class="hljs-keyword">if</span>(lmax &lt; rmax)&#123;<br>                ans += lmax - height[l];<br>                l++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                ans += rmax - height[r];<br>                r--;<br>            &#125; <br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>思路： 每列的雨水量的计算值 &#x3D; 左侧最高与右侧最高的最低值 - 当前柱子的高度</p><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><h3 id="3-无重复字符的最长字串"><a href="#3-无重复字符的最长字串" class="headerlink" title="3. 无重复字符的最长字串"></a>3. 无重复字符的最长字串</h3><p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长 子串 的长度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp">示例 <span class="hljs-number">1</span>:<br>输入: s = <span class="hljs-string">&quot;abcabcbb&quot;</span><br>输出: <span class="hljs-number">3</span> <br>解释: 因为无重复字符的最长子串是 <span class="hljs-string">&quot;abc&quot;</span>，所以其长度为 <span class="hljs-number">3</span>。<br><br>示例 <span class="hljs-number">2</span>:<br>输入: s = <span class="hljs-string">&quot;bbbbb&quot;</span><br>输出: <span class="hljs-number">1</span><br>解释: 因为无重复字符的最长子串是 <span class="hljs-string">&quot;b&quot;</span>，所以其长度为 <span class="hljs-number">1</span>。<br><br>示例 <span class="hljs-number">3</span>:<br>输入: s = <span class="hljs-string">&quot;pwwkew&quot;</span><br>输出: <span class="hljs-number">3</span><br>解释: 因为无重复字符的最长子串是 <span class="hljs-string">&quot;wke&quot;</span>，所以其长度为 <span class="hljs-number">3</span>。<br>      请注意，你的答案必须是 子串 的长度，<span class="hljs-string">&quot;pwke&quot;</span> 是一个子序列，不是子串。<br><br>提示：<br><span class="hljs-number">0</span> &lt;= s.length &lt;= <span class="hljs-number">5</span> * <span class="hljs-number">104</span><br>s 由英文字母、数字、符号和空格组成<br>```   <br>```cpp<br><span class="hljs-keyword">class</span> Solution &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> <span class="hljs-built_in">lengthOfLongestSubstring</span>(string s) &#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-built_in">pos</span>(<span class="hljs-number">128</span>, <span class="hljs-number">-1</span>);<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            j = <span class="hljs-built_in">max</span>(j, pos[s[i]] + <span class="hljs-number">1</span>);<br>            ans = <span class="hljs-built_in">max</span>(ans, i - j + <span class="hljs-number">1</span>);<br>            pos[s[i]] = i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>注意字串与子序列的区别：比如字符串”abbcd”，不重复的最长子序列为”abcd”，最长字串为”bcd”<br>思路：<br>1、ASCII码表128个字符，每个字符用一个字节存储，因此初始化一个大小为 128 的数组，所有值为 -1<br>2、重复的字符，将位置更新，i作为由边界，j作为左边界</p><h3 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438. 找到字符串中所有字母异位词"></a>438. 找到字符串中所有字母异位词</h3><p>给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp">示例 <span class="hljs-number">1</span>:<br>输入: s = <span class="hljs-string">&quot;cbaebabacd&quot;</span>, p = <span class="hljs-string">&quot;abc&quot;</span><br>输出: [<span class="hljs-number">0</span>,<span class="hljs-number">6</span>]<br>解释:<br>起始索引等于 <span class="hljs-number">0</span> 的子串是 <span class="hljs-string">&quot;cba&quot;</span>, 它是 <span class="hljs-string">&quot;abc&quot;</span> 的异位词。<br>起始索引等于 <span class="hljs-number">6</span> 的子串是 <span class="hljs-string">&quot;bac&quot;</span>, 它是 <span class="hljs-string">&quot;abc&quot;</span> 的异位词。<br><br>示例 <span class="hljs-number">2</span>:<br>输入: s = <span class="hljs-string">&quot;abab&quot;</span>, p = <span class="hljs-string">&quot;ab&quot;</span><br>输出: [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br>解释:<br>起始索引等于 <span class="hljs-number">0</span> 的子串是 <span class="hljs-string">&quot;ab&quot;</span>, 它是 <span class="hljs-string">&quot;ab&quot;</span> 的异位词。<br>起始索引等于 <span class="hljs-number">1</span> 的子串是 <span class="hljs-string">&quot;ba&quot;</span>, 它是 <span class="hljs-string">&quot;ab&quot;</span> 的异位词。<br>起始索引等于 <span class="hljs-number">2</span> 的子串是 <span class="hljs-string">&quot;ab&quot;</span>, 它是 <span class="hljs-string">&quot;ab&quot;</span> 的异位词。<br><br>提示:<br><span class="hljs-number">1</span> &lt;= s.length, p.length &lt;= <span class="hljs-number">3</span> * <span class="hljs-number">104</span><br>s 和 p 仅包含小写字母<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findAnagrams</span><span class="hljs-params">(string s, string p)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() &lt; p.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">counts</span><span class="hljs-params">(<span class="hljs-number">26</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; p.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            counts[p[i] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-comment">// i作为右边界，j作为左边界</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            counts[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>            <span class="hljs-keyword">while</span>(counts[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>] &lt; <span class="hljs-number">0</span>)&#123;<br>                counts[s[j] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>                j++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(i - j + <span class="hljs-number">1</span> == p.<span class="hljs-built_in">size</span>())&#123;<br>                res.<span class="hljs-built_in">push_back</span>(j);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>思路：滑动窗口<br>1、首先确定返回值是一个数组，s.size() 小于 p.size() 直接返回<br>2、s、p仅包含小写字母，采用26位的数组进行次数统计<br>3、若出现之前出现过的字母，则将之前出现的删除并右移，统计满足条件的异位词。<br>4、若size符合，则将起始位置j放入数组中。<br>5、获得所有满足条件的j值，输出数组。</p><h3 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h3><h3 id="560-和为K的子数组"><a href="#560-和为K的子数组" class="headerlink" title="560. 和为K的子数组"></a>560. 和为K的子数组</h3><p>给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。<br>子数组是数组中元素的连续非空序列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">示例 <span class="hljs-number">1</span>：<br>输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>], k = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">2</span><br><br>示例 <span class="hljs-number">2</span>：<br>输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], k = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; map;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>, res = <span class="hljs-number">0</span>;;<br>        <span class="hljs-comment">//为了处理从数组开头开始的子数组和为 k 的情况</span><br>        map[<span class="hljs-number">0</span>]++;  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> n : nums)&#123;<br>            sum += n;<br>            <span class="hljs-comment">// 如果存在前缀和为 sum - k 的情况</span><br>            <span class="hljs-keyword">if</span>(map.<span class="hljs-built_in">count</span>(sum - k)) <br>            &#123;<br>                <span class="hljs-comment">// 增加子数组的计数</span><br>                res += map[sum - k]; <br>            &#125;<br>            <span class="hljs-comment">// 更新当前前缀和的出现次数</span><br>            map[sum]++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>思路：前缀和+哈希表<br>&#x2F;&#x2F; 0 1 2 3 4 5 6<br>&#x2F;&#x2F; 0 1 3 6 10 15 21<br>0是肯定要的存在于map表中，因此需要初始化+1，假设k为6，<br>cur &#x3D; 6 .<br>cur - ? &#x3D; 6    ?&#x3D;0  res+&#x3D;1<br>cur &#x3D; 21 .<br>cur - ? &#x3D; 6    ?&#x3D;15  res+&#x3D;1<br>题目要求：子数组是数组中元素的连续非空序列。<br>用哈希表统计前缀和和前缀和出现的次数，但是一定要先把前缀和为0，出现次数为1的情况初始化。<br>遍历数组，将当前数加入前缀和，如果哈希表中有前缀和为prefix - k的，说明前缀和为prefix - k 到 前缀和为prefix这之间的数组，数组和刚好为k。<br>以当前的prefix为基准，有**map.get(prefix - k)**这么多对可以匹配，把出现数量加入result，最后再更新当前prefix出现的次数。</p><h3 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a>239. 滑动窗口最大值</h3><p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。<br>返回 滑动窗口中的最大值 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">示例 <span class="hljs-number">1</span>：<br>输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>], k = <span class="hljs-number">3</span><br>输出：[<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]<br>解释：<br>滑动窗口的位置                最大值<br>---------------               -----<br>[<span class="hljs-number">1</span>  <span class="hljs-number">3</span>  <span class="hljs-number">-1</span>] <span class="hljs-number">-3</span>  <span class="hljs-number">5</span>  <span class="hljs-number">3</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>       <span class="hljs-number">3</span><br> <span class="hljs-number">1</span> [<span class="hljs-number">3</span>  <span class="hljs-number">-1</span>  <span class="hljs-number">-3</span>] <span class="hljs-number">5</span>  <span class="hljs-number">3</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>       <span class="hljs-number">3</span><br> <span class="hljs-number">1</span>  <span class="hljs-number">3</span> [<span class="hljs-number">-1</span>  <span class="hljs-number">-3</span>  <span class="hljs-number">5</span>] <span class="hljs-number">3</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>       <span class="hljs-number">5</span><br> <span class="hljs-number">1</span>  <span class="hljs-number">3</span>  <span class="hljs-number">-1</span> [<span class="hljs-number">-3</span>  <span class="hljs-number">5</span>  <span class="hljs-number">3</span>] <span class="hljs-number">6</span>  <span class="hljs-number">7</span>       <span class="hljs-number">5</span><br> <span class="hljs-number">1</span>  <span class="hljs-number">3</span>  <span class="hljs-number">-1</span>  <span class="hljs-number">-3</span> [<span class="hljs-number">5</span>  <span class="hljs-number">3</span>  <span class="hljs-number">6</span>] <span class="hljs-number">7</span>       <span class="hljs-number">6</span><br> <span class="hljs-number">1</span>  <span class="hljs-number">3</span>  <span class="hljs-number">-1</span>  <span class="hljs-number">-3</span>  <span class="hljs-number">5</span> [<span class="hljs-number">3</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>]      <span class="hljs-number">7</span><br><br>示例 <span class="hljs-number">2</span>：<br>输入：nums = [<span class="hljs-number">1</span>], k = <span class="hljs-number">1</span><br>输出：[<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        deque&lt;<span class="hljs-type">int</span>&gt; q;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(r &lt; nums.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-comment">//单调递减队列</span><br>            <span class="hljs-comment">//把队列内小于当前数值的数都弹出</span><br>            <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[q.<span class="hljs-built_in">back</span>()] &lt; nums[r])&#123;<br>                q.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>            q.<span class="hljs-built_in">push_back</span>(r);<br><br>            <span class="hljs-comment">//移除已经不属于窗口内的左指针左边的元素</span><br>            <span class="hljs-keyword">if</span>(l &gt; q[<span class="hljs-number">0</span>])&#123;<br>                q.<span class="hljs-built_in">pop_front</span>();<br>            &#125; <br><br>            <span class="hljs-keyword">if</span>(r + <span class="hljs-number">1</span> &gt;= k)&#123;<br>                res.<span class="hljs-built_in">push_back</span>(nums[q[<span class="hljs-number">0</span>]]);<br>                l++;<br>            &#125;<br>            r++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        deque&lt;<span class="hljs-type">int</span>&gt; q; <span class="hljs-comment">//双端队列，deque存储的是数组nums的索引</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-comment">//如果队列中最后一个元素对应的 nums 值小于当前元素 nums[i]</span><br>            <span class="hljs-comment">//那么队列中最后一个元素对应的索引可以被移除，因为它不可能成为后续窗口的最大值，维护单调递减。</span><br>            <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[q.<span class="hljs-built_in">back</span>()] &lt; nums[i]) q.<span class="hljs-built_in">pop_back</span>();<br>            <span class="hljs-comment">//如果队列中第一个元素的索引（q.front()）距离当前索引 i 大于等于窗口大小 k</span><br>            <span class="hljs-comment">// 那么队列中第一个元素的索引已经不在当前滑动窗口内，需要将其移除。</span><br>            <span class="hljs-keyword">while</span>(!dq.<span class="hljs-built_in">empty</span>() &amp;&amp; i - k + <span class="hljs-number">1</span> &gt; dq.<span class="hljs-built_in">front</span>()) q.<span class="hljs-built_in">pop_front</span>(); <br>            q.<span class="hljs-built_in">push_back</span>(i); <span class="hljs-comment">//将当前元素插入队列</span><br>            <span class="hljs-comment">// 滑动窗口的元素达到了k个，才可以将其加入答案数组中</span><br>            <span class="hljs-keyword">if</span>(i &gt;= k - <span class="hljs-number">1</span>)  res.<span class="hljs-built_in">push_back</span>(nums[q.<span class="hljs-built_in">front</span>()]); <br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>std::queue 和 std::deque 是两种不同的容器<br>1、std::queue<br>提供了先进先出（FIFO）的操作方式。它基于其他容器（如 std::deque 或 std::list）实现。<br>queue.back()：访问队列的最后一个元素（队尾元素）。<br>queue.pop()：移除队列的第一个元素（队头元素）。<br>queue.push(value)：在队列的末尾添加一个元素。<br>2、std::deque<br>std::deque 是一个双端队列，它允许在两端进行高效的插入和删除操作。<br>主要成员函数：<br>deque.front() 访问双端队列的队首元素的值。<br>deque.back()：访问双端队列的最后一个元素（队尾元素）。<br>deque.pop_back()：移除双端队列的最后一个元素（队尾元素）。<br>deque.pop_front():移除双端队列的最前一个元素（队首元素）。<br>deque.push_back(value)：在双端队列的末尾添加一个元素。</p><h3 id="76-最小覆盖字串"><a href="#76-最小覆盖字串" class="headerlink" title="76 最小覆盖字串"></a>76 最小覆盖字串</h3><p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。<br>注意：<br>对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。<br>如果 s 中存在这样的子串，我们保证它是唯一的答案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp">示例 <span class="hljs-number">1</span>：<br>输入：s = <span class="hljs-string">&quot;ADOBECODEBANC&quot;</span>, t = <span class="hljs-string">&quot;ABC&quot;</span><br>输出：<span class="hljs-string">&quot;BANC&quot;</span><br>解释：最小覆盖子串 <span class="hljs-string">&quot;BANC&quot;</span> 包含来自字符串 t 的 <span class="hljs-string">&#x27;A&#x27;</span>、<span class="hljs-string">&#x27;B&#x27;</span> 和 <span class="hljs-string">&#x27;C&#x27;</span>。<br><br>示例 <span class="hljs-number">2</span>：<br>输入：s = <span class="hljs-string">&quot;a&quot;</span>, t = <span class="hljs-string">&quot;a&quot;</span><br>输出：<span class="hljs-string">&quot;a&quot;</span><br>解释：整个字符串 s 是最小覆盖子串。<br><br>示例 <span class="hljs-number">3</span>:<br>输入: s = <span class="hljs-string">&quot;a&quot;</span>, t = <span class="hljs-string">&quot;aa&quot;</span><br>输出: <span class="hljs-string">&quot;&quot;</span><br>解释: t 中两个字符 <span class="hljs-string">&#x27;a&#x27;</span> 均应包含在 s 的子串中，<br>因此没有符合条件的子字符串，返回空字符串。<br><br>提示：<br>m == s.length<br>n == t.length<br><span class="hljs-number">1</span> &lt;= m, n &lt;= <span class="hljs-number">105</span><br>s 和 t 由英文字母组成<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">minWindow</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; hs,ht;<br>        string ans;<br>        <span class="hljs-comment">// 字符出现次数统计</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; t.<span class="hljs-built_in">size</span>(); i++) ht[t[i]]++;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-comment">// 等价于  if条件语句满足执行，cnt++后，再将hs[s[i]]的值++</span><br>            <span class="hljs-keyword">if</span>(hs[s[i]]++ &lt; ht[s[i]])  cnt++;<br>            <span class="hljs-keyword">while</span>(hs[s[j]] &gt;  ht[s[j]]) hs[s[j++]]--;<br>            <span class="hljs-keyword">if</span>(cnt == t.<span class="hljs-built_in">size</span>())&#123;<br>                <span class="hljs-keyword">if</span>(ans.<span class="hljs-built_in">empty</span>() || ans.<span class="hljs-built_in">size</span>() &gt; i - j + <span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-comment">//从字符串 s 中提取从位置 j 开始的、长度为 i - j + 1 的子串。</span><br>                    ans = s.<span class="hljs-built_in">substr</span>(j, i-j<span class="hljs-number">+1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="普通数组"><a href="#普通数组" class="headerlink" title="普通数组"></a>普通数组</h3><h3 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a>53. 最大子数组和</h3><p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<br>子数组是数组中的一个连续部分。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp">示例 <span class="hljs-number">1</span>：<br>输入：nums = [<span class="hljs-number">-2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-5</span>,<span class="hljs-number">4</span>]<br>输出：<span class="hljs-number">6</span><br>解释：连续子数组 [<span class="hljs-number">4</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>] 的和最大，为 <span class="hljs-number">6</span> 。<br><br>示例 <span class="hljs-number">2</span>：<br>输入：nums = [<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">1</span><br><br>示例 <span class="hljs-number">3</span>：<br>输入：nums = [<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>]<br>输出：<span class="hljs-number">23</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> pre = nums[<span class="hljs-number">0</span>], ans = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            pre = pre &gt; <span class="hljs-number">0</span> ? pre + nums[i] : nums[i];<br>            ans = <span class="hljs-built_in">max</span>(ans,pre);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>思路：两种情况，第一种是前面的和加上当前的值，另一种是改变起始位置从当前位置开始计算。递推公式：dp[i] &#x3D; max(f(i-1)+nums[i], nums[i])</p><h3 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a>56. 合并区间</h3><p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] &#x3D; [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">示例 <span class="hljs-number">1</span>：<br>输入：intervals = [[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">8</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">18</span>]]<br>输出：[[<span class="hljs-number">1</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">8</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">18</span>]]<br>解释：区间 [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>] 和 [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>] 重叠, 将它们合并为 [<span class="hljs-number">1</span>,<span class="hljs-number">6</span>].<br><br>示例 <span class="hljs-number">2</span>：<br>输入：intervals = [[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]]<br>输出：[[<span class="hljs-number">1</span>,<span class="hljs-number">5</span>]]<br>解释：区间 [<span class="hljs-number">1</span>,<span class="hljs-number">4</span>] 和 [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>] 可被视为重叠区间。<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">merge</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; intervals) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> start = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], end = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; intervals.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">if</span>(intervals[i][<span class="hljs-number">0</span>] &gt; end)&#123;<br>                ans.<span class="hljs-built_in">push_back</span>(&#123;start,end&#125;);<br>                start = intervals[i][<span class="hljs-number">0</span>];<br>                end = intervals[i][<span class="hljs-number">1</span>];<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                end = <span class="hljs-built_in">max</span>(end, intervals[i][<span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        ans.<span class="hljs-built_in">push_back</span>(&#123;start, end&#125;);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>思路：返回值为二维数组，首先进行排序，通过当前的区间的末尾与下一个数组的起始位置的大小进行比较，判断是否有重叠的区间，更新左右边界进行下一次比较。</p><h3 id="189-轮转数组"><a href="#189-轮转数组" class="headerlink" title="189. 轮转数组"></a>189. 轮转数组</h3><p>给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp">示例 <span class="hljs-number">1</span>:<br>输入: nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>], k = <span class="hljs-number">3</span><br>输出: [<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>解释:<br>向右轮转 <span class="hljs-number">1</span> 步: [<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>向右轮转 <span class="hljs-number">2</span> 步: [<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>向右轮转 <span class="hljs-number">3</span> 步: [<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br><br>示例 <span class="hljs-number">2</span>:<br>输入：nums = [<span class="hljs-number">-1</span>,<span class="hljs-number">-100</span>,<span class="hljs-number">3</span>,<span class="hljs-number">99</span>], k = <span class="hljs-number">2</span><br>输出：[<span class="hljs-number">3</span>,<span class="hljs-number">99</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-100</span>]<br>解释: <br>向右轮转 <span class="hljs-number">1</span> 步: [<span class="hljs-number">99</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-100</span>,<span class="hljs-number">3</span>]<br>向右轮转 <span class="hljs-number">2</span> 步: [<span class="hljs-number">3</span>,<span class="hljs-number">99</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-100</span>]<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp">解法 <span class="hljs-number">1</span>：<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        k = k % nums.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 处理k大于数组长度的情况</span><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 如果k=0，无需旋转</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =nums.<span class="hljs-built_in">size</span>() - k; i &lt; nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            ans.<span class="hljs-built_in">push_back</span>(nums[i]);<br>        &#125;<br> <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>() - k;i++)&#123;<br>            ans.<span class="hljs-built_in">push_back</span>(nums[i]);<br>        &#125;<br>        <span class="hljs-comment">// 将结果复制回原数组</span><br>        nums = ans;<br>    &#125;<br>&#125;;<br><br>解法 <span class="hljs-number">2</span>： 三次反转<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">// k == n：如果k等于数组长度n，旋转n步实际上相当于不旋转。取模操作k=k%n会将k变为0，从而直接返回原数组。</span><br>        <span class="hljs-comment">// k &gt; n：如果k大于数组长度n，取模操作可以将k转换为一个更小的值。例如，对于长度为7的数组，旋转10步和旋转3步是等效的，因为 10 % 7 = 3。</span><br>        k %= nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-built_in">reverse</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">reverse</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">begin</span>() + k);<br>        <span class="hljs-built_in">reverse</span>(nums.<span class="hljs-built_in">begin</span>() + k, nums.<span class="hljs-built_in">end</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>1、 reverse函数反转，reverse(nums.begin(), nums.begin() + k);包前不包后，即反转前K个数值，数组从0开始。<br>2、 k %&#x3D; nums.size();<br>这一步将 k 的值调整为一个合理的范围（0 &lt;&#x3D; k &lt; nums.size()）。<br>如果 k 为 0，则不需要进行任何旋转操作。<br>如果 k 为非零值，则按照调整后的 k 进行旋转。</p><h3 id="238-除自身以外数组的乘积"><a href="#238-除自身以外数组的乘积" class="headerlink" title="238. 除自身以外数组的乘积"></a>238. 除自身以外数组的乘积</h3><p>给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。<br>题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内。<br>请 不要使用除法，且在 O(n) 时间复杂度内完成此题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">示例 <span class="hljs-number">1</span>:<br>输入: nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>输出: [<span class="hljs-number">24</span>,<span class="hljs-number">12</span>,<span class="hljs-number">8</span>,<span class="hljs-number">6</span>]<br><br>示例 <span class="hljs-number">2</span>:<br>输入: nums = [<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-3</span>,<span class="hljs-number">3</span>]<br>输出: [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">9</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">productExceptSelf</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(nums.size(),<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-comment">// ans[0]是1，便于计算前缀积</span><br>            ans[i] = ans[i<span class="hljs-number">-1</span>] * nums[i<span class="hljs-number">-1</span>]; <br>        &#125;<br><br>        <span class="hljs-type">int</span> tmp = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>;i--)&#123;<br>            ans[i] *= tmp;<br>            tmp *= nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>先计算前缀积，再计算后缀积<br>前缀积（Prefix Product）是指在数组中，从第一个元素开始到某个特定位置的所有元素的乘积。具体来说，对于数组nums，前缀积数组prefix的定义是：<br>prefix[i]&#x3D;nums[0]×nums[1]×⋯×nums[i−1]<br>Tip：前缀积和后缀积的乘积等于整个数组中除当前元素外其他所有元素的乘积</p><h3 id="41-缺失的第一个正数"><a href="#41-缺失的第一个正数" class="headerlink" title="41. 缺失的第一个正数"></a>41. 缺失的第一个正数</h3><p>给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。<br>请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp">示例 <span class="hljs-number">1</span>：<br>输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>]<br>输出：<span class="hljs-number">3</span><br>解释：范围 [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>] 中的数字都在数组中。<br><br>示例 <span class="hljs-number">2</span>：<br>输入：nums = [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">2</span><br>解释：<span class="hljs-number">1</span> 在数组中，但 <span class="hljs-number">2</span> 没有。<br><br>示例 <span class="hljs-number">3</span>：<br>输入：nums = [<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>]<br>输出：<span class="hljs-number">1</span><br>解释：最小的正数 <span class="hljs-number">1</span> 没有出现。<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">firstMissingPositive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">while</span>(nums[i] &gt;= <span class="hljs-number">1</span> &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[i] != nums[nums[i]<span class="hljs-number">-1</span>])&#123;<br>                <span class="hljs-built_in">swap</span>(nums[i], nums[nums[i] - <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] != i<span class="hljs-number">+1</span>)&#123;<br>                <span class="hljs-keyword">return</span> i<span class="hljs-number">+1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> n<span class="hljs-number">+1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>思路： n数组的长度，数值[1, n+1]   只需要记录[1, n+1]已经出现的整数<br>nums 数组索引[0, n - 1]  让nums的值对应 [1, n], 即 nums[i] &#x3D; i + 1<br>两种情况：<br>1、从小到大第一个满足nums[i] !&#x3D; i + 1 ， i+1为答案<br>2、如果都满足nums[i] &#x3D; i + 1， 那么 n+1就是答案<br>num[i] 如果[1, n]放到合适的位置  nums[num[i] - 1]</p><h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><h3 id="73-矩阵置零"><a href="#73-矩阵置零" class="headerlink" title="73. 矩阵置零"></a>73. 矩阵置零</h3><p>给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">示例 <span class="hljs-number">1</span>：<br>输入：matrix = [[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]]<br>输出：[[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]]<br><br>示例 <span class="hljs-number">2</span>：<br>输入：matrix = [[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>]]<br>输出：[[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]]<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setZeroes</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-type">int</span> m = matrix.<span class="hljs-built_in">size</span>(), n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">bool</span> rowZero = <span class="hljs-literal">false</span>, colZero = <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 遍历矩阵中所有元素</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(matrix[i][j] == <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-comment">// 行列的第一个位置为0</span><br>                    matrix[<span class="hljs-number">0</span>][j] = matrix[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>                    <span class="hljs-comment">// 如果第一行 </span><br>                    <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>) rowZero = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-comment">// 如果第一列</span><br>                    <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span>) colZero = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(matrix[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> || matrix[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span>)&#123;<br>                    matrix[i][j] = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 处理第一行或者第一列</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; colZero &amp;&amp; i &lt; m; i++) matrix[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; rowZero &amp;&amp; j &lt; n; j++) matrix[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a>54. 螺旋矩阵</h3><p>给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">示例 <span class="hljs-number">1</span>：<br>输入：matrix = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br><br>示例 <span class="hljs-number">2</span>：<br>输入：matrix = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>],[<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>]]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">12</span>,<span class="hljs-number">11</span>,<span class="hljs-number">10</span>,<span class="hljs-number">9</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">spiralOrder</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = matrix.<span class="hljs-built_in">size</span>(), n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> up = <span class="hljs-number">0</span>, down = m - <span class="hljs-number">1</span>, left = <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = left; i &lt;= right; i++) ans.<span class="hljs-built_in">push_back</span>(matrix[up][i]);<br>            <span class="hljs-keyword">if</span>(++up &gt; down) <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = up; i &lt;= down; i++) ans.<span class="hljs-built_in">push_back</span>(matrix[i][right]);<br>            <span class="hljs-keyword">if</span>(--right &lt; left) <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = right; i &gt;= left; i--) ans.<span class="hljs-built_in">push_back</span>(matrix[down][i]);<br>            <span class="hljs-keyword">if</span>(--down &lt; up) <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = down; i &gt;= up; i--) ans.<span class="hljs-built_in">push_back</span>(matrix[i][left]);<br>            <span class="hljs-keyword">if</span>(++left &gt; right) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a>48. 旋转图像</h3><p>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。<br>你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">示例 <span class="hljs-number">1</span>：<br>输入：matrix = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]]<br>输出：[[<span class="hljs-number">7</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">8</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">9</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>]]<br><br>示例 <span class="hljs-number">2</span>：<br>输入：matrix = [[<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">9</span>,<span class="hljs-number">11</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">13</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">14</span>,<span class="hljs-number">12</span>,<span class="hljs-number">16</span>]]<br>输出：[[<span class="hljs-number">15</span>,<span class="hljs-number">13</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">14</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">12</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>],[<span class="hljs-number">16</span>,<span class="hljs-number">7</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>]]<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 矩阵转置</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; matrix.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)&#123;<br>                <span class="hljs-built_in">swap</span>(matrix[i][j], matrix[j][i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 交换列</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n / <span class="hljs-number">2</span>; j++)&#123;<br>                <span class="hljs-built_in">swap</span>(matrix[i][j], matrix[i][n - j - <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>避免重复交换，只需要遍历矩阵的上三角部分（不包括对角线），即 j &lt; i 的部分<br>思路：矩阵旋转90度，即将矩阵转置，再交换列<br>[1 2 3]        [1 4 7]         [7 4 1]<br>[4 5 6]   -&gt;   [2 5 8]   -&gt;    [8 5 2]<br>[7 8 9]        [3 6 9]         [9 6 3]  </p><h3 id="240-搜索二维矩阵-II"><a href="#240-搜索二维矩阵-II" class="headerlink" title="240. 搜索二维矩阵 II"></a>240. 搜索二维矩阵 II</h3><p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：<br>每行的元素从左到右升序排列。<br>每列的元素从上到下升序排列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">示例 <span class="hljs-number">1</span>：<br>输入：matrix = [[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">11</span>,<span class="hljs-number">15</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">12</span>,<span class="hljs-number">19</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">9</span>,<span class="hljs-number">16</span>,<span class="hljs-number">22</span>],[<span class="hljs-number">10</span>,<span class="hljs-number">13</span>,<span class="hljs-number">14</span>,<span class="hljs-number">17</span>,<span class="hljs-number">24</span>],[<span class="hljs-number">18</span>,<span class="hljs-number">21</span>,<span class="hljs-number">23</span>,<span class="hljs-number">26</span>,<span class="hljs-number">30</span>]], target = <span class="hljs-number">5</span><br>输出：<span class="hljs-literal">true</span><br><br>示例 <span class="hljs-number">2</span>：<br>输入：matrix = [[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">11</span>,<span class="hljs-number">15</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">12</span>,<span class="hljs-number">19</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">9</span>,<span class="hljs-number">16</span>,<span class="hljs-number">22</span>],[<span class="hljs-number">10</span>,<span class="hljs-number">13</span>,<span class="hljs-number">14</span>,<span class="hljs-number">17</span>,<span class="hljs-number">24</span>],[<span class="hljs-number">18</span>,<span class="hljs-number">21</span>,<span class="hljs-number">23</span>,<span class="hljs-number">26</span>,<span class="hljs-number">30</span>]], target = <span class="hljs-number">20</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//自写解法1  测试用例通过，提交的例子超时，时间复杂度 O(m×n)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>        <span class="hljs-type">int</span> m = matrix.<span class="hljs-built_in">size</span>(); <span class="hljs-type">int</span> n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                vec.<span class="hljs-built_in">push_back</span>(matrix[i][j]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(),vec.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = vec.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>            <span class="hljs-type">int</span> middle = left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(vec[middle] &lt; target) &#123;<br>                left = middle + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(vec[middle] &gt; target)&#123;<br>                right = middle - <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125; <br>&#125;;<br><br><span class="hljs-comment">// 解法 2  二叉树思想   时间复杂度 O(m+n)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(matrix.<span class="hljs-built_in">empty</span>() || matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> m = <span class="hljs-number">0</span>, n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(m &lt; matrix.<span class="hljs-built_in">size</span>() &amp;&amp; n &gt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(matrix[m][n] == target)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(matrix[m][n] &gt; target)&#123;<br>                n--;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                m++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>解法一：先开辟一个数组存放所有元素，排序后通过二分判断是否存在target<br>解法二：矩阵具有升序的特点，因此可以从第一行的最后一个值开始遍历，判断与target值的关系</p><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h3 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a>160. 相交链表</h3><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。<br>比如两个链表在节点 c1 开始相交，则返回c1.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        ListNode* curA = headA;<br>        ListNode* curB = headB;<br>        <span class="hljs-type">int</span> lena = <span class="hljs-number">0</span>, lenb  = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(curA != <span class="hljs-literal">NULL</span>)&#123;<br>            curA = curA-&gt;next;<br>            lena++;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(curB != <span class="hljs-literal">NULL</span>)&#123;<br>            curB = curB-&gt;next;<br>            lenb++;<br>        &#125;<br>        curA =  headA;<br>        curB =  headB;<br>        <span class="hljs-keyword">if</span>(lenb &gt; lena)&#123;<br>            <span class="hljs-built_in">swap</span>(lena,lenb);<br>            <span class="hljs-built_in">swap</span>(curA,curB);<br>        &#125;<br>        <span class="hljs-type">int</span> gap = lena - lenb;<br>        <span class="hljs-keyword">while</span>(gap--)&#123;<br>            curA = curA-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(curA != <span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">if</span>(curA == curB) &#123;<br>                <span class="hljs-keyword">return</span> curA;<br>            &#125;<br>            curA = curA-&gt;next;<br>            curB = curB-&gt;next;<br>        &#125; <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a>206. 反转链表</h3><p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">示例<span class="hljs-number">1</span><br>输入：head = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>输出：[<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br><br>示例<span class="hljs-number">2</span><br>输入：head = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br>输出：[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br><br>示例 <span class="hljs-number">3</span>：<br>输入：head = []<br>输出：[]<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 双指针法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* cur = head;<br>        ListNode* tmp;<br>        ListNode* pre = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">while</span>(cur)&#123;<br>            ListNode* tmp = cur-&gt;next;<br>            cur-&gt;next = pre;<br>            pre = cur;<br>            cur = tmp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 递归法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">reverse</span>(<span class="hljs-literal">NULL</span>, head);<br>    &#125;<br><br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverse</span><span class="hljs-params">(ListNode* pre, ListNode* cur)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> pre;<br>        ListNode* tmp = cur-&gt;next;<br>        cur-&gt;next = pre;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">reverse</span>(cur, tmp); <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>思路：先反转前两个，再不断后移</p><h3 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a>234. 回文链表</h3><p>给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">示例 <span class="hljs-number">1</span>：<br>输入：head = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-literal">true</span><br><br>示例 <span class="hljs-number">2</span>：<br>输入：head = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* cur = head;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-keyword">while</span>(cur)&#123;<br>            st.<span class="hljs-built_in">push</span>(cur-&gt;val);<br>            cur = cur-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(head)&#123;<br>            <span class="hljs-type">int</span> t  = st.<span class="hljs-built_in">top</span>(); st.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(head-&gt;val != t) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            head = head-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>思路：回文序列是向前和向后读都相同的序列，通过栈先进后出的特点，通过弹栈函数，将其与头节点比较</p><h3 id="141-环形链表-142-环形链表II"><a href="#141-环形链表-142-环形链表II" class="headerlink" title="141. 环形链表 &amp;&amp; 142. 环形链表II"></a>141. 环形链表 &amp;&amp; 142. 环形链表II</h3><p>给你一个链表的头节点 head ，判断链表中是否有环。<br>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。<br>如果链表中存在环 ，则返回 true 。 否则，返回 false 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp">示例 <span class="hljs-number">1</span>：<br>输入：head = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-4</span>], pos = <span class="hljs-number">1</span><br>输出：<span class="hljs-literal">true</span><br>解释：链表中有一个环，其尾部连接到第二个节点。<br> <br>示例<span class="hljs-number">2</span>：<br>输入：head = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], pos = <span class="hljs-number">0</span><br>输出：<span class="hljs-literal">true</span><br>解释：链表中有一个环，其尾部连接到第一个节点。<br><br>示例<span class="hljs-number">3</span>：<br>输入：head = [<span class="hljs-number">1</span>], pos = <span class="hljs-number">-1</span><br>输出：<span class="hljs-literal">false</span><br>解释：链表中没有环。<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        ListNode* slow = head;<br>        ListNode* fast = head;<br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="hljs-literal">NULL</span>)&#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>            <span class="hljs-keyword">if</span>(slow == fast)&#123;<br>                ListNode* index1 = fast;<br>                ListNode* index2 = head;<br>                <span class="hljs-keyword">while</span>(index1 != index2)&#123;<br>                    index1 = index1-&gt;next;<br>                    index2 = index2-&gt;next;<br>                &#125;<br>                <span class="hljs-keyword">return</span> index1;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>141与142本质是同一题，141只要求返回true和false来判断链表中有无环，142要求返回的是链表，也即返回链表头节点。<br>思路：通过快慢指针法，慢指针走一步，快指针走两步。<br>如果存在快慢节点在同一位置处，即判断有环，返回true；否则返回false；<br>如果需要返回链表，则将某一结点返回到头节点，两者各走一步直到再次相遇。</p><h3 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a>21. 合并两个有序链表</h3><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">示例 <span class="hljs-number">1</span>：<br>输入：l1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>], l2 = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>]<br><br>示例 <span class="hljs-number">2</span>：<br>输入：l1 = [], l2 = []<br>输出：[]<br><br>示例 <span class="hljs-number">3</span>：<br>输入：l1 = [], l2 = [<span class="hljs-number">0</span>]<br>输出：[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* list1, ListNode* list2)</span> </span>&#123;<br>        ListNode *dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        ListNode *cur = dummy;<br>        <span class="hljs-keyword">while</span>(list1 &amp;&amp; list2)&#123;<br>            <span class="hljs-keyword">if</span>(list1-&gt;val &lt;= list2-&gt;val)&#123;<br>                cur-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(list1-&gt;val);<br>                list1 = list1-&gt;next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                cur-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(list2-&gt;val);<br>                list2 = list2-&gt;next;<br>            &#125;<br>            cur =  cur-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// 将剩下的节点添加到链表中</span><br>        cur-&gt;next = list1 ? list1 : list2;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;; <br></code></pre></td></tr></table></figure><p>思路：通过一个虚节点，便于后面插入节点<br>通过判断同一位置的两个链表节点的值大小，将较小的一位加入链表，并将位置后移<br>当两个链表中的某一链表没有指向空节点时，将剩余的节点添加到结果链表中（题目中已知的两个链表为升序，因此可以直接添加）</p><h3 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a>2. 两数相加</h3><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。<br>请你将两个数相加，并以相同形式返回一个表示和的链表。<br>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp">示例 <span class="hljs-number">1</span>：<br>输入：l1 = [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>], l2 = [<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>]<br>输出：[<span class="hljs-number">7</span>,<span class="hljs-number">0</span>,<span class="hljs-number">8</span>]<br>解释：<span class="hljs-number">342</span> + <span class="hljs-number">465</span> = <span class="hljs-number">807</span><br><br>示例 <span class="hljs-number">2</span>：<br>输入：l1 = [<span class="hljs-number">0</span>], l2 = [<span class="hljs-number">0</span>]<br>输出：[<span class="hljs-number">0</span>]<br><br>示例 <span class="hljs-number">3</span>：<br>输入：l1 = [<span class="hljs-number">9</span>,<span class="hljs-number">9</span>,<span class="hljs-number">9</span>,<span class="hljs-number">9</span>,<span class="hljs-number">9</span>,<span class="hljs-number">9</span>,<span class="hljs-number">9</span>], l2 = [<span class="hljs-number">9</span>,<span class="hljs-number">9</span>,<span class="hljs-number">9</span>,<span class="hljs-number">9</span>]<br>输出：[<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">9</span>,<span class="hljs-number">9</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        ListNode* cur  = dummy;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(l1 || l2 || sum)&#123;<br>            <span class="hljs-comment">// l1-&gt;val + l2-&gt;val + 进位</span><br>            <span class="hljs-keyword">if</span>(l1) sum += l<span class="hljs-number">1.</span>val, l1 = l1-&gt;next;<br>            <span class="hljs-keyword">if</span>(l2) sum += l<span class="hljs-number">2.</span>val, l2 = l2-&gt;next;<br>            cur-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(sum % <span class="hljs-number">10</span>);<br>            cur = cur-&gt;next;<br>            sum /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a>19. 删除链表的倒数第 N 个结点</h3><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">示例 <span class="hljs-number">1</span>：<br>输入：head = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], n = <span class="hljs-number">2</span><br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>]<br><br>示例 <span class="hljs-number">2</span>：<br>输入：head = [<span class="hljs-number">1</span>], n = <span class="hljs-number">1</span><br>输出：[]<br><br>示例 <span class="hljs-number">3</span>：<br>输入：head = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], n = <span class="hljs-number">1</span><br>输出：[<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummy-&gt;next = head;<br>        ListNode* slow = dummy;<br>        ListNode* fast = dummy;<br>        <span class="hljs-keyword">while</span>(n-- &amp;&amp; fast != <span class="hljs-literal">NULL</span>)&#123;<br>            fast = fast-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// fast-&gt;next != NULL</span><br>        <span class="hljs-keyword">while</span>(fast-&gt;next)&#123;<br>            fast = fast-&gt;next;<br>            slow = slow-&gt;next;<br>        &#125;<br>        slow-&gt;next = slow-&gt;next-&gt;next;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>思路：采用快慢指针法，先走n步，之后再移动到末尾节点处，即可删除倒数n个节点。</p><h3 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a>24. 两两交换链表中的节点</h3><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">示例 <span class="hljs-number">1</span>：<br>输入：head = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>输出：[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>]<br><br>示例 <span class="hljs-number">2</span>：<br>输入：head = []<br>输出：[]<br><br>示例 <span class="hljs-number">3</span>：<br>输入：head = [<span class="hljs-number">1</span>]<br>输出：[<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummy-&gt;next  = head;<br>        ListNode* cur = dummy;<br>        <span class="hljs-keyword">while</span>(cur-&gt;next &amp;&amp; cur-&gt;next-&gt;next)&#123;<br>            ListNode* tmp1 = cur-&gt;next;<br>            ListNode* tmp2 = cur-&gt;next-&gt;next-&gt;next;<br>            cur-&gt;next = cur-&gt;next-&gt;next;<br>            cur-&gt;next-&gt;next = tmp1;<br>            cur-&gt;next-&gt;next-&gt;next = tmp2;<br><br>            cur = cur-&gt;next-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>思路：先交换前两个，再往后移两个继续交换</p><h3 id="虹软实习面-用两个栈实现一个队列"><a href="#虹软实习面-用两个栈实现一个队列" class="headerlink" title="虹软实习面 用两个栈实现一个队列"></a>虹软实习面 用两个栈实现一个队列</h3><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、top、empty）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 逻辑，初始化两个栈为空，先放栈A，再转栈B，再弹出栈B，栈A 存放123元素（此时弹出顺序为321），弹出到B栈顶为1，弹出顺序为123（逆转顺序），最后再弹出</span><br><span class="hljs-comment">// https://zhuanlan.zhihu.com/p/268794221</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span>;   <span class="hljs-comment">// 入队列</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>;            <span class="hljs-comment">// 出队列</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span></span>;            <span class="hljs-comment">// 获取队首元素（不删除）</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;   <span class="hljs-comment">// 判断队列是否为空</span><br><span class="hljs-keyword">private</span>:<br>    std::stack&lt;<span class="hljs-type">int</span>&gt; pushStack;  <span class="hljs-comment">// 用于入队</span><br>    std::stack&lt;<span class="hljs-type">int</span>&gt; popStack;   <span class="hljs-comment">// 用于出队</span><br>&#125;;<br><span class="hljs-comment">// 入队：直接 push 到 pushStack</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MyQueue::push</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>    pushStack.<span class="hljs-built_in">push</span>(num);<br>&#125;<br><span class="hljs-comment">// 出队：如果 popStack 为空，则从 pushStack 转移数据</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MyQueue::pop</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 1. 检查队列是否为空</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Queue is empty!&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 2. 如果 popStack 为空，需要从 pushStack 转移数据</span><br>    <span class="hljs-keyword">if</span> (popStack.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">while</span> (!pushStack.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-comment">// 将 pushStack 的栈顶元素压入 popStack</span><br>            popStack.<span class="hljs-built_in">push</span>(pushStack.<span class="hljs-built_in">top</span>());<br>            <span class="hljs-comment">// 移除 pushStack 的栈顶元素</span><br>            pushStack.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 3. 弹出 popStack 的栈顶元素（即队列的队首元素）</span><br>    <span class="hljs-type">int</span> data = popStack.<span class="hljs-built_in">top</span>();<br>    popStack.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">return</span> data;<br>&#125;<br><span class="hljs-comment">// 获取队首元素（不删除）</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MyQueue::top</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Queue is empty!&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (popStack.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">while</span> (!pushStack.<span class="hljs-built_in">empty</span>()) &#123;<br>            popStack.<span class="hljs-built_in">push</span>(pushStack.<span class="hljs-built_in">top</span>());<br>            pushStack.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> popStack.<span class="hljs-built_in">top</span>();<br>&#125;<br><span class="hljs-comment">// 判断队列是否为空</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">MyQueue::empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> pushStack.<span class="hljs-built_in">empty</span>() &amp;&amp; popStack.<span class="hljs-built_in">empty</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyQueue myQueue;<br>    myQueue.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);                                                                                                                                                                       <br>    myQueue.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>);<br>    myQueue.<span class="hljs-built_in">push</span>(<span class="hljs-number">3</span>);<br>    myQueue.<span class="hljs-built_in">push</span>(<span class="hljs-number">4</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Current pop: &quot;</span> &lt;&lt; myQueue.<span class="hljs-built_in">pop</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 1</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Current pop: &quot;</span> &lt;&lt; myQueue.<span class="hljs-built_in">pop</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 2</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Current pop: &quot;</span> &lt;&lt; myQueue.<span class="hljs-built_in">pop</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 3</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Current pop: &quot;</span> &lt;&lt; myQueue.<span class="hljs-built_in">pop</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 4</span><br>    <span class="hljs-comment">// 测试空队列情况</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Current pop: &quot;</span> &lt;&lt; myQueue.<span class="hljs-built_in">pop</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 抛出异常</span><br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::runtime_error&amp; e) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 输出错误信息</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>STM32笔记</title>
    <link href="/2025/04/06/STM32/"/>
    <url>/2025/04/06/STM32/</url>
    
    <content type="html"><![CDATA[<p>一个记录STM32外设通信协议知识点的博客。</p><h2 id="STM32秋招八股"><a href="#STM32秋招八股" class="headerlink" title="STM32秋招八股"></a>STM32秋招八股</h2><h3 id="通信方式分类"><a href="#通信方式分类" class="headerlink" title="通信方式分类"></a>通信方式分类</h3><h4 id="1-同步-异步传输"><a href="#1-同步-异步传输" class="headerlink" title="1.同步&#x2F;异步传输"></a>1.同步&#x2F;异步传输</h4><p>同步传输是一种典型的基于字节的输入输出，数据按每次一个字节进行传输，其传输速度低，有时钟线，时钟线保证发送和接收双方的信号能够同步起来，如I2C(SDA\SCL)，SPI(SCLK\CS\MOSI\MISO)， USART。<br>异步传输需要外界的时钟信号进行通信，是把数据字节组合起来一起发送，这种组合称之为帧，其传输速度比异步传输快，无时钟线， 波特率作为约束条件，如UART ，传输双方统一波特率，常见波特率9600&#x2F;51，115200&#x2F;STM32。  </p><h4 id="2-串行-并行"><a href="#2-串行-并行" class="headerlink" title="2.串行&#x2F;并行"></a>2.串行&#x2F;并行</h4><p>外设协议如UART、IIC、SPI、RS232、RS485、CAN都是串行。<br>效率不同：并行传输效率高，一次可传输多个数据；串行传输一次可传输一个数据。<br>速度不同：大多数情况下串行速度更快     传输距离不同：并行传输适用于短距离，串行适用于长距离。  </p><h4 id="3-方向-时间"><a href="#3-方向-时间" class="headerlink" title="3.方向&#x2F;时间"></a>3.方向&#x2F;时间</h4><p>全双工：在通信的任意时刻，线路上存在A到B和B到A的双向信号传输，如UART和SPI。<br>半双工：可以实现双向的通信，但不能在两个方向同时进行，必须轮流交替进行，如I2C。<br>单工：发送端只能发送信息，不能接收信息；接收端只能接收信息，不能发送信息。  </p><h3 id="计算机三大总线"><a href="#计算机三大总线" class="headerlink" title="计算机三大总线"></a>计算机三大总线</h3><h4 id="数据总线DB"><a href="#数据总线DB" class="headerlink" title="数据总线DB"></a>数据总线DB</h4><p>数据总线DB用来传送数据信息，是双向的。CPU既可通过DB从内存或输入设备读入数据，又可通过DB将内部数据送至内存或输出设备。DB的宽度决定了CPU和计算机其他设备之间每次交换数据的位数。数据总线的位数是微型计算机的一个重要指标，通常与微处理的字长相一致。需要指出的是，数据的含义是广义的，它可以是真正的数据，也可以是指令代码或状态信息，有时甚至是一个控制信息，因此，在实际工作中，数据总线上传送的并不一定仅仅是真正意义上的数据。</p><h4 id="地址总线AB"><a href="#地址总线AB" class="headerlink" title="地址总线AB"></a>地址总线AB</h4><p>地址总线AB用于传送CPU发出的地址信息，是单向的。传送地址信息的目的是指明与CPU交换信息的内存单元或I&#x2F;O设备。存储器是按地址访问的，所以每个存储单元都有一个固定地址，要访问1MB存储器中的任一单元，需要给出1M个地址，即需要20位地址（2^20&#x3D;1M）。一般来说，若地址总线为n位，则可寻址空间为2^n字节。因此，地址总线的宽度决定了CPU 的最大寻址能力。</p><h4 id="控制总线CB"><a href="#控制总线CB" class="headerlink" title="控制总线CB"></a>控制总线CB</h4><p>控制总线CB用来传送控制信号、时序信号和状态信息等，是双向的。其中有的是CPU向内存或外部设备发出的信息，如读&#x2F;写信号，片选信号、中断响应信号等；有的是内存或外部设备向CPU发出的信息，中断申请信号、复位信号、总线请求信号、设备就绪信号等。显然，CB中的每一条线的信息传送方向是一定的、单向的，但作为一个整体则是双向的。所以，凡涉及到控制总线CB，均是以双向线表示。</p><h4 id="单片机总线及挂载外设"><a href="#单片机总线及挂载外设" class="headerlink" title="单片机总线及挂载外设"></a>单片机总线及挂载外设</h4><p>AHB：高级高性能总线（Advanced High Performance Bus），主要用于连接高性能模块，如CPU、DMA和DSP等。<br>APB1：高级外设总线1（Advanced Peripheral Bus 1），属于低速外设总线, 时钟频率通常为系统时钟的一半，STM32F103为72MHz的一半。连接低速外设，如定时器TIM2到TIM7、RTC、WDT看门狗、SPI2、SPI3、USART2、USART3、UART4、UART5、I2C1、I2C2、USB&#x2F;CAN共享的512字节SRAM、bXCAN1、bXCAN2、后备寄存器、电源控制PWR、DAC等<br>APB2：高级外设总线2（Advanced Peripheral Bus 2），属于高速外设总线。连接如USART1、高级控制定时器TIM1和TIM8、模数转换器ADC1、ADC2、ADC3、SPI1、外部中断EXTI、复用IO:AFIO、通用IO:GPIOA-G等<br><img src="https://raw.githubusercontent.com/JohnTino/blogImage/main/img/F103Bridge.png"><br>分频器：对频率做除法<br>锁相环：对频率做乘法<br>复用器：对频率做选择 </p><h3 id="复用与映射"><a href="#复用与映射" class="headerlink" title="复用与映射"></a>复用与映射</h3><p>复用指Pin脚本身除了支持普通GPIO功能之外，还支持别的功能，使用别的功能就叫复用。AFIO复用IO口指AFIO主要用于引脚复用功能的选择和重定义。在STM32中，AFIO主要完成两个任务：复用功能引脚重映射、中断引脚选择。重映射指Pin脚本身不支持这些功能，配置重映射寄存器，使其具备别的功能。</p><h3 id="标准库和HAL库的区别"><a href="#标准库和HAL库的区别" class="headerlink" title="标准库和HAL库的区别"></a>标准库和HAL库的区别</h3><p>标准库：1、直接操作寄存器，代码较为底层。2、配置灵活但代码复杂，容易出错。3、不同 STM32 系列的代码兼容性较差。<br>HAL 库：1、提供统一的 API，代码更简洁。 2、支持跨平台和跨系列移植。3、功能更强大，但运行时效率稍低（因增加了抽象层）。</p><h3 id="STM32F1和F4的区别？"><a href="#STM32F1和F4的区别？" class="headerlink" title="STM32F1和F4的区别？"></a>STM32F1和F4的区别？</h3><p>内核不同：F1是Cortex-M3内核，F4是Cortex-M4内核；<br>主频不同：F1主频72MHz，F4主频168MHz；<br>浮点运算：F1无浮点运算单位，F4有；<br>功能性能：F4外设比F1丰富且功能更强大，比如GPIO翻转速率、上下拉电阻配置、ADC精度等；<br>内存大小：F1内部SRAM最大64K，F4有192K(112+64+16)。</p><h3 id="介绍以下STM32启动过程？"><a href="#介绍以下STM32启动过程？" class="headerlink" title="介绍以下STM32启动过程？"></a>介绍以下STM32启动过程？</h3><p>通过Boot引脚设定,寻找初始地址<br>初始化栈指针 __initial_sp<br>指向复位程序 Reset_Hander<br>设置异常中断 HardFault_Handler<br>设置系统时钟 SystemInit<br>调用C库函数 _main</p><h3 id="时钟树"><a href="#时钟树" class="headerlink" title="时钟树"></a>时钟树</h3><p>时钟RCC，Reset and Clock Control（复位和时钟控制），在绝大部分MCU芯片中都包含复位和时钟控制模块，也是MCU重要的组成部分。51单片机，11.0592Mhz晶振；stm32F103，8Mh晶振，主频72Mhz；stm32F407，12Mhz，主频168Mhz<br>时钟树：一种树状的电路结构，用于将主时钟信号（通常来自晶体振荡器或PLL）分配到芯片上的各个逻辑单元和模块。<br>时钟源：STM32的时钟源分为高速、低速两类时钟，同时也分内部和外部。<br>HSE：High Speed External，高速外部时钟，可接石英&#x2F;陶瓷谐振器，或者接外部时钟源，频率范围为4MHz~16MHz，c8t6是接的8Mhz。<br>HSI：High Speed Internal，高速内部时钟，RC振荡器，频率为8MHz，精度不高。<br>LSE：Low Speed External ，低速外部时钟 ，接频率为32.768kHz的石英晶体。<br>LSI：Low Speed Internal，低速内部时钟，RC振荡器，频率为40kHz，提供低功耗时钟。</p><h3 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h3><p><img src="https://raw.githubusercontent.com/JohnTino/blogImage/main/img/GPIO.png"></p><h4 id="输入模式"><a href="#输入模式" class="headerlink" title="输入模式"></a>输入模式</h4><p>浮空输入（IN_FLOATING），（IPU）上拉输入（TTL）、（IPD）下拉输入、（AIN）模拟输入(ADC)。<br>区别：<br>1.浮空输入没有上拉和下拉电阻，引脚的电平完全由外部电路决定（外部电路需要提供稳定电平），电平不稳定容易收到外界干扰，如按键输入、传感器信号；<br>2.上拉输入，接上拉电阻当没有外部信号作用时，默认电平为高电平，3.3v或者5v，当外部信号为低电平并产生作用时，引脚会被拉低。<br>3.下拉输入：接下拉电阻，默认电平为0V，如数字信号输入等；<br>4.模拟输入：用以接受模拟信号如（电压值），通常连接一个模数转换器（ADC），如传感器信号输入（如温度、光照、压力等）、音频信号输入（高精度）等。</p><h4 id="输出模式"><a href="#输出模式" class="headerlink" title="输出模式"></a>输出模式</h4><p>开漏输出（Out_OD、没有P-MOS，只能输出低电平）、推挽输出（Out_PP、高低电平都可）、推挽复用输出（AF_PP）、开漏复用输出（AF_OD）。GPIO输出速率有四种，分别是低速（2MHz）、中速（10MHz）和高速（50MHz）。<br>区别：<br>1.开漏输出只有 N-MOS 管，没有 P-MOS 管，因此只能输出低电平或高阻态（浮空），高电平需要通过外部上拉电阻才能进行输出，允许多个设备共享同一条总线（如 I²C 总线），应用在IIC、电平转换线路、总线共享的场景；<br>2.推挽输出包含 P-MOS 和 N-MOS 管，可以主动输出高电平和低电平，高电平时 P-MOS 导通，低电平时 N-MOS 导通，输出速度快，电平稳定，不支持多设备共享同一信号线（可能引起短路），应用在适合驱动较高负载（如 LED、电机等）、继电器等场景，以及SPI、UART等通信接口；复用不是让CPU直接写输出数据寄存器，而是利用片上外设模块的复用功能输出来决定的。<br>其中，I²C 总线：使用开漏输出或开漏复用输出，允许多个设备共享同一条总线。需要外部上拉电阻提供高电平。SPI 通信：使用推挽输出或推挽复用输出，确保高速、稳定的信号传输。GPIO 控制：如果需要驱动 LED 或继电器，使用推挽输出。如果用于按键检测，多个按键，无需驱动能力，可以选择开漏输出。  </p><h3 id="定时器-PWM"><a href="#定时器-PWM" class="headerlink" title="定时器&amp;PWM"></a>定时器&amp;PWM</h3><p>定时器可以对输入的时钟进行计数，并在计数值达到设定值时触发中断。16位计数器、预分频器、自动重装寄存器的时基单元，在72MHz计数时钟下可以实现最大59.65s的定时。不仅具备基本的定时中断功能，而且还包含内外时钟源选择、输入捕获、输出比较、编码器接口、主从触发模式等多种功能<br>配置参数：<br>计数器溢出频率：CK_CNT_OV &#x3D; CK_CNT&#x2F;(ARR+1) &#x3D; CK_PSC&#x2F;[(PSC + 1)*(ARR + 1)]<br>计数器计数频率：CK_CNT &#x3D; CK_PSC&#x2F;(PSC + 1)<br>溢出时间：1 &#x2F; CK_CNT<br>其中，CK_PSC为预分频器输出的频率，ARR为自动重装载寄存器的值，ARR+1是因为计数器从0开始计数，所以最大值是ARR，总共计数的次数是ARR+1次。</p><h4 id="定时器分类"><a href="#定时器分类" class="headerlink" title="定时器分类"></a>定时器分类</h4><p>基本定时器（TIM6    TIM7），通用定时器（TIM2，TIM3，TIM4，TIM5），高级定时器（TIM1，TIM8）<br><img src="https://raw.githubusercontent.com/JohnTino/blogImage/main/img/TIMcls.png"><br>基本定时器：16位自动重装载累加计数器，仅支持向上技术；16位可编程（可实时修改）预分频器，用于对输入的时钟按系数1~65536之间的任意分频；出发DAC的同步电路；在更新事件（计数器溢出）时产生中断&#x2F;DMA请求<br>通用定时器：向上、向下、向上&#x2F;向下自动装载计数器，支持中心对齐计数。4个独立通道：输入捕获、输出比较、PWM生成（边缘或中间对齐模式）、单脉冲模式输出<br>高级定时器：死区时间可编程的互补输出；使用外部信号控制定时器和定时器互联的同步电路；允许在指定数目的计数器周期之后更新定时器寄存器的重复计数器；刹车输入信号可以将定时器输出信号置于复位状态或者一个已知状态；</p><h4 id="PWM相关参数"><a href="#PWM相关参数" class="headerlink" title="PWM相关参数"></a>PWM相关参数</h4><p>PWM（脉宽调制，Pulse Width Modulation）是一种通过调节信号的占空比来控制功率输出的技术。通过改变信号的占空比来模拟不同的电压或功率输出。<br>PWM 的关键参数<br>周期（T）：一个完整 PWM 信号的时间长度，单位为秒（s）。<br>频率（f）：PWM 信号的频率，是周期的倒数，单位为赫兹（Hz）。<br>占空比（D）：信号高电平时间（Ton）与周期（T）的比值，用百分比表示。<br>电压平均值（Vavg）：PWM 信号的等效输出电压。<br>计算公式：PWM频率 &#x3D; 芯片主频&#x2F;(PSC + 1)(ARR + 1) ，  占空比 &#x3D; CCR&#x2F;(ARR + 1)<br>其中，CCR：比较寄存器，用于设置高电平的时间。PSC：预分频器值，调整预分频值，可以控制计数器每次增加的速度。ARR：自动重装载值，设置ARR当计数器的值达到自动重装载值时，计数器会清零并重新开始计数，用于定时中断</p><h4 id="PWM两种模式"><a href="#PWM两种模式" class="headerlink" title="PWM两种模式"></a>PWM两种模式</h4><p>PWM1模式与PWM2模式，两种模式相似却又恰恰相反。<br>PWM1模式：向上计数，当 TIMx_CNT &lt; TIMx_CCRn 时，定时器 TIMx 的通道 n 为有效电平，否则为无效电平；向下计数，当 TIMx_CNT &gt; TIMx_CCRn 时，定时器 TIMx 的通道 n 为无效电平，否则为有效电平。<br>PWM1模式的逻辑是：在 CNT &lt; CCRn 时输出有效电平，其他情况输出无效电平（无论向上还是向下计数）。<br>PWM2 模式：向上计数，当 TIMx_CNT &lt; TIMx_CCRn 时，定时器 TIMx 的通道 n 为无效电平，否则为有效电平；向下计数，当 TIMx_CNT &gt; TIMx_CCRn 时，定时器 TIMx 的通道 n 为有效电平，否则为无效电平<br>PWM2 模式的逻辑是：在 CNT &lt; CCRn 时输出无效电平，其他情况输出有效电平（无论向上还是向下计数）。<br>其中，TIMx 表示 STM32 的定时器，x 表示某个定时器，取值需要根据芯片来定；TIMx_CNT，表示定时器 TIMx 的计数器寄存器值（计数值）； TIMx_CCRn，表示捕获比较寄存器的值（比较值），其中 n 表示某个通道，取值为1、2、3、4；</p><h3 id="UART通信"><a href="#UART通信" class="headerlink" title="UART通信"></a>UART通信</h3><h4 id="UART通信特点"><a href="#UART通信特点" class="headerlink" title="UART通信特点"></a>UART通信特点</h4><p>全双工异步串行通信，TX、RX两根线，点对点通信方式，一般只连接两个设备，通信双方需要相同的波特率进行通信。波特率：每秒传送一bit的数量，每秒传输二进制代码的位数，所以单位是bits&#x2F;s；</p><h4 id="UART帧格式（时序图）"><a href="#UART帧格式（时序图）" class="headerlink" title="UART帧格式（时序图）"></a>UART帧格式（时序图）</h4><p>时序图：UART 在发送或接收过程中的一帧数据由4部分组成，起始位、数据位、奇偶校验位和停止位，其中，<br>1、起始位标志着一帧数据的开始，低电平0；<br>2、数据位是一帧数据中的有效数据，可以是5~8位；<br>3、校验位分为奇校验和偶校验，用于检验数据在传输过程中是否出错。奇校验时，发送方应使数据位中1的个数与校验位中1的个数之和为奇数；接收方在接收数据时，对1的个数进行检查，若不为奇数，则说明数据在传输过程中出了差错。同样，偶校验则检查1的个数是否为偶数。<br>4、停止位标志着一帧数据的结束，高电平1，停止位一般是1 位、1.5位、2位；<br>5、空闲位，高电平1</p><h4 id="UART与USART区别"><a href="#UART与USART区别" class="headerlink" title="UART与USART区别"></a>UART与USART区别</h4><p>USART是通用同步和异步收发器，UART是通用异步收发器，当进行异步通信时,这两者是没有区别的。区别在于USART比UART多了同步通信功能。这个同步通信功能可以把USART当做SPI来用，比如用USART来驱动SPI设备。</p><h3 id="RS232和RS485通讯接口有什么区别？"><a href="#RS232和RS485通讯接口有什么区别？" class="headerlink" title="RS232和RS485通讯接口有什么区别？"></a>RS232和RS485通讯接口有什么区别？</h3><ol><li>传输方式不同。 RS232采取不平衡传输方式，即所谓单端通讯。 而RS485则采用平衡传输，即差分传输方式。</li><li>传输距离不同。RS232适合本地设备之间的通信，传输距离一般不超过20m。而RS485的传输距离为几十米到上千米。</li><li>设备数量。RS232 只允许一对一通信，点对点。当相互通信的节点超过2个时，使用RS485，RS485 接口在总线上是允许连接多达128个收发器。</li><li>连接方式。RS232，规定用电平表示数据，因此线路就是单线路的，用两根线才能达到全双工的目的；而RS485， 使用差分电平表示数据，因此，必须用两根线才能达到传输数据的基本要求，要实现全双工，必需用4根线。</li></ol><h3 id="串口相关的硬件信号"><a href="#串口相关的硬件信号" class="headerlink" title="串口相关的硬件信号"></a>串口相关的硬件信号</h3><p>TTL：单片机引脚直接发出来的信号，0 ~ 5V。<br>USB转串口芯片：为了解决USB接口与单片机串口接口之间的兼容性问题，市场上出现了多种USB转串口芯片(如CH340、PL2303等)。这些芯片能够将USB接口转换为虚拟的串口接口(即COM口)，从而在计算机上模拟出传统的串口通信环境，CH340模块把TTL信号转为USB信号、差分信号。<br>RS232接口任何一条信号线的电压均为负逻辑关系。即：逻辑”1”为-3 ~ -15V。逻辑“0”：+3 ~ +15V，噪声容限为2V。即要求接收器能识别高于+3V的信号作为逻辑”0”，低于-3V的信号作为逻辑”1”。<br>RS485的电气特性：逻辑“1”以两线间的电压差为+2 ~ +6V表示。逻辑“0”以两线间的电压差为-6 ~ -2V表示。RS232、RS485，都是TTL转过来了的，485是差分信号。<br>RS485四种工作模式：1、点到点，四线全双工  2、点到多点，四线全双工   3、点到点，两线半双工  4、点对多点，两线半双工<br>ARM  TTL 电平 (电平转换芯片) ———-&gt; DB-9，电脑串口 RS232<br>ARM  TTL 电平 (USB串口芯片) ———–&gt; 通过USB线 连接电脑，电脑USB口  </p><h3 id="IIC通信"><a href="#IIC通信" class="headerlink" title="IIC通信"></a>IIC通信</h3><h4 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h4><p>1.总线空闲状态<br>在通信开始之前，I2C总线处于空闲状态，即SDA和SCL线都处于高电平。<br>2.发送启动信号（START）<br>主设备在SCL线为高电平时，将SDA线从高电平拉低，形成启动信号。这一过程标志着通信的开始。<br>3.发送设备地址和读写位<br>启动信号后，主设备发送目标设备的地址（通常为7位）和读写位。读写位为0表示写操作，为1表示读操作。<br>4.等待应答信号（ACK）<br>从设备接收到地址和读写位后，返回一个应答信号（ACK）。如果从设备未响应，主设备可以根据需要进行重试或处理错误。<br>5.数据传输<br>主设备根据读写位的设置，开始与从设备进行数据的读写操作。若读，则从-&gt;主，若写，则主-&gt;从。每传输一个字节后，接收方返回一个应答信号。<br>6.发送停止信号（STOP）<br>数据传输完成后，主设备在SCL线为高电平时，将SDA线从低电平拉高，形成停止信号，标志着通信的结束。<br><img src="https://raw.githubusercontent.com/JohnTino/blogImage/main/img/IIC.png"></p><h4 id="IIC读操作需要发送两次启动信号的原因是"><a href="#IIC读操作需要发送两次启动信号的原因是" class="headerlink" title="IIC读操作需要发送两次启动信号的原因是"></a>IIC读操作需要发送两次启动信号的原因是</h4><p>第一次启动信号：主机发送启动信号，然后发送从设备地址和写操作位（R&#x2F;W&#x3D;0），接着发送内部寄存器地址，用于指定要读取的数据位置。第二次启动信号：主机再次发送启动信号，然后发送从设备地址和读操作位（R&#x2F;W&#x3D;1），开始读取数据。</p><h4 id="简述IIC特点"><a href="#简述IIC特点" class="headerlink" title="简述IIC特点"></a>简述IIC特点</h4><p>1.由数据线SDA和时钟SCL构成的串行总线，可发送和接收数据，是一个多主机的同步半双工通信方式。每个挂接在总线上的器件都有个唯一的地址。<br>2.分为软件IIC和硬件IIC，软件IIC 流程清楚、占用时间多、速度慢；硬件IIC速度块、可以用DMA、用法比较复杂。51只有软件IIC，没有外设；STM32具有IIC外设，因此软件IIC和硬件IIC都可以。<br>3.IIC总线最多挂在2^7-1&#x3D;127个设备，0地址不算(广播)；在你不知道从机地址的时候，通过设备枚举，for函数，给所有设备枚举一遍<br>4.SDA 、SCL接上拉电阻4.7K-10K，   用于控制其高低电平，两条数据线开漏输出（OD）。<br>4.三种模式：标准100Kb&#x2F;s（周期10us）、快速400Kb&#x2F;s，高速3.4Mb&#x2F;s，超高速…..</p><h4 id="IIC协议中的总线仲裁是如何工作的"><a href="#IIC协议中的总线仲裁是如何工作的" class="headerlink" title="IIC协议中的总线仲裁是如何工作的?"></a>IIC协议中的总线仲裁是如何工作的?</h4><p>IICC使用总线仲裁机制来解决多个设备同时试图传输数据的冲突。所有设备都监视总线上的数据线(SDA)，如果设备检测到其他设备在发送不同的数据，它将放弃总线，优先发送低地址的设备(逻辑”0”优先)，从而实现仲裁。</p><h4 id="讲一下IIC，SPI，UART的区别"><a href="#讲一下IIC，SPI，UART的区别" class="headerlink" title="讲一下IIC，SPI，UART的区别"></a>讲一下IIC，SPI，UART的区别</h4><p>1.同步与异步：SPI和IIC是同步通信，依赖时钟信号；而UART是异步通信，使用起始位和停止位来界定数据包。<br>2.通信速度：SPI通常提供最高的数据传输速度，其次是IIC，UART相对较慢。IIC是KHz级，SPI是MHz级。<br>3.信号线数量：SPI使用四条线，IIC使用两条线，UART使用三到四条线。<br>4.多设备通信：IIC和SPI都支持多设备通信，但SPI需要为每个设备提供单独的SS（片选）信号线，而IIC通过地址识别设备。<br>5.应用范围：SPI和IIC主要用于短距离、同一电路板上的设备间通信，而UART更适用于长距离或不同设备间的通信。</p><h4 id="编写软件模拟I2C的代码。"><a href="#编写软件模拟I2C的代码。" class="headerlink" title="编写软件模拟I2C的代码。"></a>编写软件模拟I2C的代码。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 延时函数，模拟时序</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">I2C_Delay</span><span class="hljs-params">()</span> &#123;<br>    usleep(<span class="hljs-number">5</span>);  <span class="hljs-comment">// 微秒级延时，控制时钟速度</span><br>&#125;<br><span class="hljs-comment">// 产生I2C起始信号 (SDA下降，SCL保持高电平)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">I2C_Start</span><span class="hljs-params">()</span> &#123;<br>    GPIO_SetPinHigh(SDA_PIN);<br>    GPIO_SetPinHigh(SCL_PIN);<br>    I2C_Delay();<br>    GPIO_SetPinLow(SDA_PIN);<br>    I2C_Delay();<br>    GPIO_SetPinLow(SCL_PIN);<br>&#125;<br><span class="hljs-comment">// 产生I2C停止信号 (SDA上升，SCL保持高电平)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">I2C_Stop</span><span class="hljs-params">()</span> &#123;<br>    GPIO_SetPinLow(SDA_PIN);<br>    GPIO_SetPinHigh(SCL_PIN);<br>    I2C_Delay();<br>    GPIO_SetPinHigh(SDA_PIN);<br>    I2C_Delay();<br>&#125;<br><span class="hljs-comment">// 发送ACK信号</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">I2C_SendAck</span><span class="hljs-params">()</span> &#123;<br>    GPIO_SetPinLow(SDA_PIN);<br>    GPIO_SetPinHigh(SCL_PIN);<br>    I2C_Delay();<br>    GPIO_SetPinLow(SCL_PIN);<br>&#125;<br><span class="hljs-comment">// 发送NACK信号</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">I2C_SendNack</span><span class="hljs-params">()</span> &#123;<br>    GPIO_SetPinHigh(SDA_PIN);<br>    GPIO_SetPinHigh(SCL_PIN);<br>    I2C_Delay();<br>    GPIO_SetPinLow(SCL_PIN);<br>&#125;<br><span class="hljs-comment">// 读取ACK信号</span><br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">I2C_ReadAck</span><span class="hljs-params">()</span> &#123;<br>    GPIO_SetPinHigh(SDA_PIN);  <span class="hljs-comment">// 释放SDA，等待从设备响应</span><br>    GPIO_SetPinHigh(SCL_PIN);<br>    I2C_Delay();<br>    <span class="hljs-type">uint8_t</span> ack = GPIO_ReadPin(SDA_PIN);<br>    GPIO_SetPinLow(SCL_PIN);<br>    <span class="hljs-keyword">return</span> ack == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;  <span class="hljs-comment">// 0表示ACK，1表示NACK</span><br>&#125;<br><span class="hljs-comment">// 发送一个字节数据</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">I2C_WriteByte</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> data)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (data &amp; <span class="hljs-number">0x80</span>)  <span class="hljs-comment">// 判断最高位</span><br>            GPIO_SetPinHigh(SDA_PIN);<br>        <span class="hljs-keyword">else</span><br>            GPIO_SetPinLow(SDA_PIN);<br>        GPIO_SetPinHigh(SCL_PIN);<br>        I2C_Delay();<br>        GPIO_SetPinLow(SCL_PIN);<br>        data &lt;&lt;= <span class="hljs-number">1</span>;  <span class="hljs-comment">// 左移一位</span><br>    &#125;<br>    I2C_ReadAck();<br>&#125;<br><span class="hljs-comment">// 读取一个字节数据</span><br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">I2C_ReadByte</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> ack)</span> &#123;<br>    <span class="hljs-type">uint8_t</span> data = <span class="hljs-number">0</span>;<br>    GPIO_SetPinHigh(SDA_PIN);  <span class="hljs-comment">// 释放SDA，准备接收数据</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) &#123;<br>        GPIO_SetPinHigh(SCL_PIN);<br>        I2C_Delay();<br>        data = (data &lt;&lt; <span class="hljs-number">1</span>) | GPIO_ReadPin(SDA_PIN);<br>        GPIO_SetPinLow(SCL_PIN);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (ack)<br>        I2C_SendAck();<br>    <span class="hljs-keyword">else</span><br>        I2C_SendNack();<br>    <span class="hljs-keyword">return</span> data;<br>&#125;<br><span class="hljs-comment">// I2C设备写入示例</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">I2C_WriteToDevice</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> deviceAddr, <span class="hljs-type">uint8_t</span> regAddr, <span class="hljs-type">uint8_t</span> data)</span> &#123;<br>    I2C_Start();<br>    I2C_WriteByte(deviceAddr &lt;&lt; <span class="hljs-number">1</span>);  <span class="hljs-comment">// 发送设备地址 + 写位</span><br>    I2C_WriteByte(regAddr);           <span class="hljs-comment">// 发送寄存器地址</span><br>    I2C_WriteByte(data);               <span class="hljs-comment">// 发送数据</span><br>    I2C_Stop();<br>&#125;<br><span class="hljs-comment">// I2C设备读取示例</span><br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">I2C_ReadFromDevice</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> deviceAddr, <span class="hljs-type">uint8_t</span> regAddr)</span> &#123;<br>    <span class="hljs-type">uint8_t</span> data;<br>    I2C_Start();<br>    I2C_WriteByte(deviceAddr &lt;&lt; <span class="hljs-number">1</span>);  <span class="hljs-comment">// 发送设备地址 + 写位</span><br>    I2C_WriteByte(regAddr);           <span class="hljs-comment">// 发送寄存器地址</span><br>    I2C_Start();<br>    I2C_WriteByte((deviceAddr &lt;&lt; <span class="hljs-number">1</span>) | <span class="hljs-number">1</span>);  <span class="hljs-comment">// 发送设备地址 + 读位</span><br>    data = I2C_ReadByte(<span class="hljs-number">0</span>);                 <span class="hljs-comment">// 读取数据并发送NACK</span><br>    I2C_Stop();<br>    <span class="hljs-keyword">return</span> data;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="SPI通信"><a href="#SPI通信" class="headerlink" title="SPI通信"></a>SPI通信</h3><h4 id="介绍一下SPI通信"><a href="#介绍一下SPI通信" class="headerlink" title="介绍一下SPI通信"></a>介绍一下SPI通信</h4><p>一种高速、全双工、同步的通信总线（输出推挽，要求高速以及数据稳定；输入引脚配置为浮空或上拉输入）。SPI总线系统是一种同步串行外设接口，它可以使MCU与各种外围设备以串行方式进行通信以交换信息。SPI总线可直接与各个厂家生产的多种标准外围器件相连，包括FLASH、RAM、网络控制器、LCD显示驱动器、A&#x2F;D转换器和MCU等。SPI接口的读写操作同IIC一样，都是由主设备发起。当存在多个从设备时，通过各自的片选信号进行管理。</p><h4 id="SPI通信特点"><a href="#SPI通信特点" class="headerlink" title="SPI通信特点"></a>SPI通信特点</h4><p>1.四根通信线：SCLK（Serial Clock）、MOSI（Master Output Slave Input）、MISO（Master Input Slave Output）、SS（Slave Select）。 MISO：主设备输入&#x2F;从设备输出引脚。该引脚在从模式下发送数据，在主模式下接收数据。MOSI：主设备输出&#x2F;从设备输入引脚。该引脚在主模式下发送数据，在从模式下接收数据。SCLK：串行时钟信号，由主设备产生。CS&#x2F;SS：从设备片选信号，由主设备控制。它的功能是用来作为“片选引脚”，也就是选择指定的从设备，让主设备可以单独地与特定从设备通讯，避免数据线上的冲突。<br>2.SPI没有应答机制，发送就直接发送，接收就直接接收；<br>3.主从模式：一主一从；一主多从；不能多主。<br>4.没有复杂的寻址机制，使用专用的片选线选择从设备<br>5.没有应答机制，主设备无法确认从设备是否正确接收数据</p><h4 id="硬件SPI和软件模拟SPI的区别有哪些？"><a href="#硬件SPI和软件模拟SPI的区别有哪些？" class="headerlink" title="硬件SPI和软件模拟SPI的区别有哪些？"></a>硬件SPI和软件模拟SPI的区别有哪些？</h4><p>硬件SPI的效率要比软件模拟SPI高，写程序的时候只要把要发的数据写在寄存器里，硬件就会自动给你发了，软件模拟SPI则需要器实现时钟的拉高拉低，数据串行输出等等。硬件SPI必须要处理器支持才可以用，软件SPI就不需要特定的要求了，一般IO口就可用。</p><h4 id="SPI有几种工作模式？它们有什么区别？"><a href="#SPI有几种工作模式？它们有什么区别？" class="headerlink" title="SPI有几种工作模式？它们有什么区别？"></a>SPI有几种工作模式？它们有什么区别？</h4><p>SPI有4种工作模式（Mode 0-3），不同的从设备可能在出厂是就是配置为某种模式，这是不能改变的；但通信双方必须是工作在同一模式下，所以可以对主设备的SPI模式进行配置，通过CPOL（时钟极性）和CPHA（时钟相位）来控制我们主设备的通信模式。<br>时钟极性(CPOL)定义了时钟空闲状态电平。CPOL&#x3D;0，表示当SCLK&#x3D;0时总线状态时钟为空闲（低电平），所以有效状态就是SCLK处于高电平时，第一个跳变为上升沿；CPOL&#x3D;1，表示当SCLK&#x3D;1时总线状态时钟为空闲（高电平），所以有效状态就是SCLK处于低电平时，第一个跳变为下降沿。<br>时钟相位(CPHA)定义数据的采集时间。CPHA&#x3D;0，在时钟的第一个跳变沿（上升沿或下降沿）进行数据采样，数据在第一个时钟边沿采样，在第2个边沿发送数据；CPHA&#x3D;1，在时钟的第二个跳变沿（上升沿或下降沿）进行数据采样，数据在第二个时钟边沿采样，在第1个边沿发送数据。<br>模式0：CPOL&#x3D;0,CPHA&#x3D;0<br><img src="https://raw.githubusercontent.com/JohnTino/blogImage/main/img/spimode0.png"><br>模式1：CPOL&#x3D;0,CPHA&#x3D;1<br><img src="https://raw.githubusercontent.com/JohnTino/blogImage/main/img/spimode1.png"><br>模式2：CPOL&#x3D;1,CPHA&#x3D;0<br><img src="https://raw.githubusercontent.com/JohnTino/blogImage/main/img/spimode2.png"><br>模式3：CPOL&#x3D;1,CPHA&#x3D;1<br><img src="https://raw.githubusercontent.com/JohnTino/blogImage/main/img/spimode3.png"></p><h3 id="中断相关"><a href="#中断相关" class="headerlink" title="中断相关"></a>中断相关</h3><p>中断是指在主程序运行过程中，出现了特定的中断触发条件（中断源），使得CPU暂停当前正在运行的程序，转而去处理中断程序，处理完成后又返回原来被暂停的位置继续运行，CPU参与，而DMA是外设与内存进行交互（CPU不参与）。</p><h4 id="DMA方式和中断控制方式的主要区别"><a href="#DMA方式和中断控制方式的主要区别" class="headerlink" title="DMA方式和中断控制方式的主要区别"></a>DMA方式和中断控制方式的主要区别</h4><p>1.中断控制方式在每个数据传送完成之后中断CPU，而DMA控制方式则在所要求的传送的一批数据传送结束时中断CPU。<br>2.中断控制方式中的数据传送在中断处理时由CPU控制完成，而DMA控制方式则在DMA控制器下完成。不过，在DMA的控制方式中,数据的传送方向，存放数据的内存始址及传送数据的长度等信息仍然由CPU控制。<br>3.中断控制方式以CPU为核心，而DMA方式以存储器为核心，因此DMA方式可与CPU并行工作。<br>4.中断控制方式传输的数据以字节为单位，而DMA方式传送批量数据，其基本单位为数据块(通常一个数据块包含若干字节)。</p><h4 id="中断与异常有何区别？"><a href="#中断与异常有何区别？" class="headerlink" title="中断与异常有何区别？"></a>中断与异常有何区别？</h4><p>中断是指外部硬件产生的一个电信号从CPU的中断引脚进入，打断CPU的运行。异常是指软件运行过程中发生了一些必须作出处理的事件，CPU自动产生一个陷入来打断CPU的运行。异常在处理的时候必须考虑与处理器的时钟同步，实际上异常也称为同步中断，在处理器执行到因编译错误而导致的错误指令时，或者在执行期间出现特殊错误，必须靠内核处理的时候，处理器就会产生一个异常。</p><h4 id="中断服务程序能不能有参数和返回值？"><a href="#中断服务程序能不能有参数和返回值？" class="headerlink" title="中断服务程序能不能有参数和返回值？"></a>中断服务程序能不能有参数和返回值？</h4><p>（1）在单片机裸机程序中，中断服务程序既不能有参数，也不能有返回值。（2）但是在带操作系统的嵌入式系统中，中断服务程序可以有参数，也可以有返回值。  </p><h4 id="中断和轮询哪个效率高？怎样决定是采用中断方式还是采用轮询方式去实现驱动？"><a href="#中断和轮询哪个效率高？怎样决定是采用中断方式还是采用轮询方式去实现驱动？" class="headerlink" title="中断和轮询哪个效率高？怎样决定是采用中断方式还是采用轮询方式去实现驱动？"></a>中断和轮询哪个效率高？怎样决定是采用中断方式还是采用轮询方式去实现驱动？</h4><p>中断是CPU处于被动状态下来接受设备的信号，而轮询是CPU主动去查询该设备是否有请求。如果是请求设备是一个频繁请求cpu的设备，或者有大量数据请求的网络设备，那么轮询的效率是比中断高。如果是一般设备，并且该设备请求cpu的频率比较低，则用中断效率要高一些。主要是看请求频率。</p><h4 id="EXIT和NVIC的关系"><a href="#EXIT和NVIC的关系" class="headerlink" title="EXIT和NVIC的关系"></a>EXIT和NVIC的关系</h4><p>EXTI是外部中断，专注于外部中断信号的处理，配置触发方式和中断源。而NVIC负责全局中断管理，包括优先级配置、中断使能和嵌套。在实际应用中，EXTI 和 NVIC 通常需要配合使用，例如在 STM32 中，外部中断信号通过 EXTI 传递给 NVIC，由 NVIC 进行优先级管理和中断响应。</p><h4 id="其他相关概念"><a href="#其他相关概念" class="headerlink" title="其他相关概念"></a>其他相关概念</h4><p>中断优先级：当有多个中断源同时申请中断时，CPU会根据中断源的轻重缓急进行裁决，优先响应更加紧急的中断源。<br>中断向量：中断服务子程序的入口地址。<br>中断嵌套：当一个中断程序正在运行时，又有新的更高优先级的中断源申请中断，CPU再次暂停当前中断程序，转而去处理新的中断程序，处理完成后依次进行返回。<br>原子操作：在执行过程中不会被其他操作中断，在操作开始之前和操作完成之后，系统状态是稳定的，但在操作执行过程中，系统状态对其他线程或进程是不可见的。由于原子操作的不可分割性，它通常用于实现线程安全的操作，避免多线程环境下的竞态条件（Race Condition）和数据不一致问题。</p><h3 id="ADC-DAC"><a href="#ADC-DAC" class="headerlink" title="ADC&amp;DAC"></a>ADC&amp;DAC</h3><h4 id="ADC"><a href="#ADC" class="headerlink" title="ADC"></a>ADC</h4><p>ADC即模数转换器，是将连续的模拟信号转换为数字信号的电路。其输入为模拟信号，输出为数字信号。ADC的主要组成部分是模拟信号采样模块、模拟信号处理模块、模数转换模块和数字信号处理模块。其中，模拟信号采样模块负责采集模拟信号，模拟信号处理模块负责对采集的模拟信号进行滤波、放大等处理，模数转换模块则将模拟信号转换为数字信号，数字信号处理模块负责对数字信号进行处理，如滤波、放大、数字信号处理算法等。<br>DAC为数模转换器，用于将数字信号转化为模拟信号。<br>一般我们把模拟信号(Analog signal) 用A来进行简写，数字信号(digital signal) 用D来表示。   模拟信号0-3.3V。数字信号：0、1。<br>ADC模拟信号（电压）转换为数字值，ADC采样值（数字量）到电压的转换公式为：电压值&#x3D;(ADC读取值&#x2F;ADC最大值)*参考电压<br>即若ADC为12位，则其最大值为2^12-1&#x3D;4095。单片机参考电压一般为3.3V或者5V<br>DAC将数字信号值转换成模拟值（输出电压），计算公式为：输出电压&#x3D;（DAC读取值&#x2F;DAC最大值）*参考电压</p><h4 id="ADC和DAC的区别"><a href="#ADC和DAC的区别" class="headerlink" title="ADC和DAC的区别"></a>ADC和DAC的区别</h4><p>1、功能不同：ADC是模拟信号转换为数字信号的模数转换器，而DAC是数字信号转换为模拟信号的数字模拟转换器。<br>2、输入输出不同：ADC的输入是模拟信号，输出是数字信号;而DAC的输入是数字信号，输出是模拟信号。<br>3、适用范围不同：ADC通常用于从传感器和其他模拟信号源中读取数据并将其转换为数字信号。DAC则通常用于控制输出电压或电流来控制运动和其他应用。<br>4、采样率不同：ADC的采样率通常比DAC的采样率高。这是因为模拟信号变化的速度比数字信号变化的速度快，因此需要更高的采样率才能准确地转换模拟信号。<br>5、量化误差不同：ADC和DAC都存在量化误差。ADC的量化误差会导致输入信号的失真，而DAC的量化误差会导致输出信号的失真。</p><h4 id="ADC的位数？（采样精度）"><a href="#ADC的位数？（采样精度）" class="headerlink" title="ADC的位数？（采样精度）"></a>ADC的位数？（采样精度）</h4><p>F1和F4都具有3个ADC，F1可提供21个输入通道，F4可以提供24个输入通道。<br>F4的ADC支持12位，10位，8位和6位精度，F1只支持12位<br>ADC的数字存储是12位的的话，“111111111111”&#x3D;4095，转换的电压范围是0v-3.3v的话，转换器就会把0v-3.3v平均分成4096份</p><h4 id="ADC转换模式"><a href="#ADC转换模式" class="headerlink" title="ADC转换模式"></a>ADC转换模式</h4><p>1、单次转换：ADC只执行一次转换<br>2、连续转换：转换结束之后马上开始新的转换<br>3、扫描：ADC扫描被规则通道和注入通道选中的所有通道，在每个组的每个通道上执行单次转换。在每个转换结束时，这一组的下一个通道被自动转换。如果设置了CONT位（开启了连续 转换模式），转换不会在选择组的最后一个通道上停止，而是再次从选择组的第一个通道继续转换。 简单说就是对所有所选中的通道进行转换！<br>4、间断：触发一次，转换一个通道，在触发，在转换。在所选转换通道循环，由触发信号启动新一轮的转换，直到转换完成为止。</p><h4 id="ADC工作原理"><a href="#ADC工作原理" class="headerlink" title="ADC工作原理"></a>ADC工作原理</h4><p>采样：模拟信号以固定的时间间隔进行采样，获得一系列模拟信号的离散样本。<br>量化：采样得到的模拟信号样本被映射到固定数量的离散级别，这个过程叫做量化。量化级别越多，ADC的分辨率越高。<br>编码：量化后的数值需要转换为数字编码。最常见的编码方式是二进制编码。<br>采样，量化，编码，输出；给定模拟参考电压Vref，ADC_GPIOx采集外部信号，通过注入&#x2F;规则通道到模数转换器，写入数据寄存器，输出。</p><h4 id="ADC如何提升精度？"><a href="#ADC如何提升精度？" class="headerlink" title="ADC如何提升精度？"></a>ADC如何提升精度？</h4><p>提升ADC分辨率，采用滤波电路减少噪声和干扰，增加采样时间，定期校准和校正；</p><h4 id="ADC的量化噪声能否消除？"><a href="#ADC的量化噪声能否消除？" class="headerlink" title="ADC的量化噪声能否消除？"></a>ADC的量化噪声能否消除？</h4><p>不能，因为采样不是理想，而是无限逼近的概念。</p><h3 id="CAN通信"><a href="#CAN通信" class="headerlink" title="CAN通信"></a>CAN通信</h3><h4 id="简述一下CAN通信的特点"><a href="#简述一下CAN通信的特点" class="headerlink" title="简述一下CAN通信的特点"></a>简述一下CAN通信的特点</h4><p>1、CAN通信是一种串行、异步、半双工的通信方式，APB1总线。所谓异步、即没有时钟线，因此和uart一样采用波特率方式来进行通信。<br>2、CAN通信的信号为差分信号（抗干扰特性，振幅相等，相位相反），与USB、HDMI、以太网、485一样。<br>3、多个LAN，传输方式有点对点，点对多点，广播三种传送方式。<br>4、速率： 低速（10-125kbps，1000米传输距离）、高速（125kbps-1Mbps，传输距离小于40米）、CAN FD（8Mbps、64Byte）<br>5、每帧为8个有效字节<br>总线组成：<br>1、CAN控制器（片上外设）<br>2、CAN收发器<br>3、CAN High 和CAN Low两根线构成的总线结构。<br>STM32ZET6只有一个CAN外设，PA11–RX，PA12–TX，连接方式与串口通信相反，CAN通信是RX连接RX</p><h4 id="CAN总线的基本工作原理是什么？"><a href="#CAN总线的基本工作原理是什么？" class="headerlink" title="CAN总线的基本工作原理是什么？"></a>CAN总线的基本工作原理是什么？</h4><p>CAN总线是一种多主机的串行通信协议，主要用于汽车和工业控制。它通过差分信号（CAN_H和CAN_L）传输数据，具有高抗干扰能力。CAN总线采用非破坏性位仲裁机制，确保高优先级消息优先传输。节点通过发送带有标识符的消息进行通信，标识符不仅表示消息内容，还决定其优先级。    </p><h4 id="CAN通信的仲裁机制如何工作"><a href="#CAN通信的仲裁机制如何工作" class="headerlink" title="CAN通信的仲裁机制如何工作"></a>CAN通信的仲裁机制如何工作</h4><p>CAN总线采用非破坏性位仲裁机制，具体过程如下：</p><ol><li>同时发送：多个节点同时发送消息时，总线通过标识符（ID）进行仲裁。   </li><li>位比较：节点在发送ID的同时监听总线电平，若发送的位与总线电平不一致，则退出仲裁。   </li><li>优先级：ID值越小，优先级越高。优先级高的节点继续发送，低优先级的节点退出并等待总线空闲后重试。</li></ol><h4 id="CAN收发器和CAN控制器的区别"><a href="#CAN收发器和CAN控制器的区别" class="headerlink" title="CAN收发器和CAN控制器的区别"></a>CAN收发器和CAN控制器的区别</h4><p>CAN收发器是一种用于CAN总线通信的专用芯片，主要用于将CAN控制器和CAN总线物理层之间的信号进行转换和调节。它的主要作用是将CAN控制器输出的数字信号转换为CAN总线所需要的物理信号，同时将CAN总线上接收到的物理信号转换为数字信号，并将其传递给CAN控制器进行处理。<br>CAN控制器是一种硬件模块，用于实现CAN总线上的数据传输。它包括了发送和接收的功能模块，用于控制CAN总线上的数据帧的发送和接收，并且负责管理帧的错误处理。通常被集成在处理器、微控制器或嵌入式系统中。或者独立CAN控制器，独立CAN控制器与处理器之间通过总线或外设接口进行通信，可以独立地进行CAN总线数据的发送和接收，而不需要处理器的干预。</p><h4 id="CAN通信的逻辑电平"><a href="#CAN通信的逻辑电平" class="headerlink" title="CAN通信的逻辑电平"></a>CAN通信的逻辑电平</h4><p>CAN为差分信号，电平定义：显性电平 逻辑0 ；隐形电平 逻辑1。<br>高速CAN，CAN高和CAN低上的电压都为2.5V，此时两者差为0V，表示逻辑“1”，为逻辑隐性；CAN高上的电压为3.5V和CAN低上的电压为1.5V，此时两者差值为2V，表示逻辑“0”，为逻辑显性。</p><h4 id="CAN通信的帧类型"><a href="#CAN通信的帧类型" class="headerlink" title="CAN通信的帧类型"></a>CAN通信的帧类型</h4><p>数据帧  用于发送单元向接收单元传送数据的帧。<br>遥控帧  用于接收单元向具有相同ID的发送单元请求数据的帧。<br>错误帧  用于当检测出错误时向其他单元通知错误的帧。<br>过载帧  用于接收单元通知其尚未做好接收准备的帧。<br>帧间隔  用于将数据帧及遥控帧与前面的帧分离开来的帧。</p><h4 id="CAN总线中的标识符（ID）有什么作用？"><a href="#CAN总线中的标识符（ID）有什么作用？" class="headerlink" title="CAN总线中的标识符（ID）有什么作用？"></a>CAN总线中的标识符（ID）有什么作用？</h4><p>标识符（ID）在CAN总线中有两个主要作用：</p><ol><li>消息标识：唯一标识消息的内容和类型。  </li><li>优先级决定：ID值越小，优先级越高。总线仲裁时，优先级高的消息会优先传输，低优先级的节点会自动退出发送并等待总线空闲后重试。</li></ol><h4 id="CAN总线如何实现错误检测和纠正？"><a href="#CAN总线如何实现错误检测和纠正？" class="headerlink" title="CAN总线如何实现错误检测和纠正？"></a>CAN总线如何实现错误检测和纠正？</h4><ol><li>CRC校验：每个消息帧包含15位CRC校验码，接收节点会重新计算CRC并与接收到的CRC进行比较。   </li><li>帧检查：检查帧格式、位填充规则等是否符合标准。   </li><li>ACK确认：发送节点会等待接收节点的ACK确认，未收到ACK则重发。     </li><li>错误帧：检测到错误的节点会发送错误帧，通知其他节点丢弃当前消息。</li></ol><h4 id="CAN通信中的位填充是什么？为什么需要位填充？"><a href="#CAN通信中的位填充是什么？为什么需要位填充？" class="headerlink" title="CAN通信中的位填充是什么？为什么需要位填充？"></a>CAN通信中的位填充是什么？为什么需要位填充？</h4><p>位填充定义（Bit Stuffing）指当CAN节点发送逻辑电平（显性dominant或隐性recessive）为持续相同的5位时，它必须添加一位反向电平，即使连续5个相同位后本就是一个相反位，也需要添加填充位。CAN接收节点会自动删除这个新增的额外电平位。<br>位填充作用：</p><ol><li>错误检测。当某一个节点发生主动错误时，将把总线拉低6个bit宽度的显性电平“0”，及时向总线上其他单元汇报错误。      </li><li>确保发送和接收节点的时钟同步。位填充机制保证了传输过程中有足够的跳变沿。ISO 11898-1规定，发送方在传输连续5个相同位后必须传输一个相反的位。</li></ol><h4 id="CAN-FD-和CAN的-区别"><a href="#CAN-FD-和CAN的-区别" class="headerlink" title="CAN FD 和CAN的 区别"></a>CAN FD 和CAN的 区别</h4><p>CAN-FD：一帧数据最长64字节。可以理解成CAN协议的升级版，只升级了协议，物理层未改变。传输速率不同、数据长度不同、帧格式不同、ID长度不同。</p><ol><li>速率不同：CAN：最大传输速率1Mbps。CAN-FD：速率可变，最大传输速率8Mbps。</li><li>数据长度不同：CAN：一帧数据最长8字节。CAN-FD：一帧数据最长64字节。</li><li>ID长度不同：CAN标准帧ID长度最长11bit。 CAN-FD标准帧ID长度可扩展到12bit。 </li><li>帧格式不同：CAN-FD新增了FDF、BRS、ESI位，FDF表示CAN报文还是CAN-FD报文。BRS：表示位速率转换，该位隐性时，速率可变，该位为显性时，以正常的CAN-FD总线速率传输（恒定速率）。</li></ol><h4 id="CAN总线中的错误状态有哪些？它们是如何转换的？"><a href="#CAN总线中的错误状态有哪些？它们是如何转换的？" class="headerlink" title="CAN总线中的错误状态有哪些？它们是如何转换的？"></a>CAN总线中的错误状态有哪些？它们是如何转换的？</h4><ol><li>主动错误状态：节点可正常收发消息，检测到错误时会发送主动错误标志。</li><li>被动错误状态：节点错误计数较高，检测到错误时发送被动错误标志，且发送间隔增加。</li><li>总线关闭状态：节点错误计数达到上限，节点停止收发消息，需重启或复位才能恢复。<br>状态转换规则：发送或接收错误时，错误计数增加；成功发送或接收时，错误计数减少。发送错误计数超过127时，节点进入被动错误状态；超过255时，进入总线关闭状态。</li></ol><h4 id="简单讲下CAN通讯吗？"><a href="#简单讲下CAN通讯吗？" class="headerlink" title="简单讲下CAN通讯吗？"></a>简单讲下CAN通讯吗？</h4><p>第一段：需要发送的通讯设备，先发送一个显性电平0，告诉其他通讯设备，需要开始通讯。<br>第二段：就是发送仲裁段，其中包括ID帧和数据帧类型，告诉其他通讯设备，需要和哪个通讯设备进行通讯，以及帧的类型，CAN通讯设备的优先级，就是由ID号决定的，往往ID号越小优先级别越高。为标准帧还是扩展帧，由仲裁段最后一位IDE位的电平决定的，IDE为显性则为标准帧，IDE为隐性则为扩展帧。<br>第三段，为控制段，共6位，四位储存数据段长度的信息，还有两位为保留位。<br>第四段：为数据段，固定长度为8个字节，先发送高位，后发送低位。<br>第五段，为CRC，为验证段。<br>第六段，为ACK为应答段，发送机发送两个隐形电平，接收机发送一个显性电平，告诉发送机，接收完成。<br>第七段，结束段，发送7个隐形电平。</p><h4 id="什么是帧间隔？"><a href="#什么是帧间隔？" class="headerlink" title="什么是帧间隔？"></a>什么是帧间隔？</h4><p>帧间隔时间为3个显性电平，在此期间不能发送数据，发送即视为超载；之后为8个隐性电平，为延迟发送期间，如果过了这8个隐性电平时间则进入总线空闲时间。</p><h4 id="CANTP是什么？"><a href="#CANTP是什么？" class="headerlink" title="CANTP是什么？"></a>CANTP是什么？</h4><p>CAN接口模块（下文简“CanIf”）位于底层CAN驱动（CanDrv）、CAN收发器（CanTrcv）和上层通信服务层（CanSm、CanNm）、CAN传输协议（CanTp）、PDU路由器（PduR）之间。它表示上层通信层的CAN驱动程序服务接口。CAN Transport Layer Protocol，是一种用于控制器区域网络（CAN）的传输层协议。CANTP为CAN提供了大容量数据的传输，可以将较大的数据分为多个小数据帧进行传输，并在发送和接收端进行重新组装。暴力一点的理解，CANTP的作用就是组包，拆包，传输超时反馈。</p><h4 id="CAN通讯中的优先级？"><a href="#CAN通讯中的优先级？" class="headerlink" title="CAN通讯中的优先级？"></a>CAN通讯中的优先级？</h4><p>标准帧与扩展帧之间，标准帧的优先级会更高，扩展帧的优先级更低，相同帧类型中，往往ID更小的发送机，优先级别更高。</p><h4 id="扩展帧与标准帧有什么区别？"><a href="#扩展帧与标准帧有什么区别？" class="headerlink" title="扩展帧与标准帧有什么区别？"></a>扩展帧与标准帧有什么区别？</h4><p>扩展帧与标准帧的区别在于扩展帧拥有更长字节的ID，以便能够扩展更多的CAN通讯设备。</p><h4 id="什么是busoff"><a href="#什么是busoff" class="headerlink" title="什么是busoff?"></a>什么是busoff?</h4><p>Busoff就是发送错误计数器达到255次之后，CAN总线关闭的情况，CAN总线需要经过128次11个隐形电平才能恢复，或者复位。</p><h4 id="STM32的CAN外设支持哪些功能？"><a href="#STM32的CAN外设支持哪些功能？" class="headerlink" title="STM32的CAN外设支持哪些功能？"></a>STM32的CAN外设支持哪些功能？</h4><p>多邮箱支持：有3个发送邮箱和2个接收FIFO。<br>硬件过滤器：内置14个硬件过滤器，用于快速筛选感兴趣的消息，减少CPU负担。 - 支持标识符掩码模式和标识符列表模式。<br>自动重发：支持消息的自动重发功能，确保在总线错误或仲裁失败后重新发送。<br>时间触发通信：支持时间触发的CAN通信（Time Triggered Communication），用于严格时间同步的应用。<br>优先级管理：硬件支持根据标识符的优先级动态调度帧的发送顺序。</p><h4 id="STM32的CAN外设有哪些模式（如正常模式、环回模式）？"><a href="#STM32的CAN外设有哪些模式（如正常模式、环回模式）？" class="headerlink" title="STM32的CAN外设有哪些模式（如正常模式、环回模式）？"></a>STM32的CAN外设有哪些模式（如正常模式、环回模式）？</h4><p>正常模式（Normal Mode），这是CAN外设的默认工作模式，用于实际的网络通信。<br>环回模式（Loopback Mode），在此模式下，CAN外设的发送数据直接回送到接收端，而不会实际发送到总线，可以模拟总线通信，但不会影响其他节点。<br>静默模式（Silent Mode），节点只能监听总线上的数据，但不会主动发送数据或参与仲裁。<br>时间触发通信模式（Time-Triggered Communication Mode，TTCM），该模式允许时间触发的CAN帧通信，用于实现节点之间的精确时间同步</p><h4 id="CAN通讯在单片机中的设置？"><a href="#CAN通讯在单片机中的设置？" class="headerlink" title="CAN通讯在单片机中的设置？"></a>CAN通讯在单片机中的设置？</h4><p>设置引脚、开启时钟，其中最重要的是过滤器的设置：用于硬件过滤CAN通讯的ID，有两种模式，一种是列表模式，将传输的ID用列表逐一匹配，列表模式可以选择16位或32位的位宽ID，第二种就是掩码模式，掩码模式就是，共11位的代码，只按照条件识别有效的四位即可。<br>需要选择过滤器，设置过滤器ID和掩码ID，掩码ID位为1时，该位需要与过滤器进行比较。标准帧需要右移5位存储至寄存器的高11位中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">CAN_FilterTypeDef sFilterConfig;<br><br><span class="hljs-comment">// 配置过滤器参数</span><br>sFilterConfig.FilterBank = <span class="hljs-number">0</span>;                       <span class="hljs-comment">// 过滤器编号</span><br>sFilterConfig.FilterMode = CAN_FILTERMODE_IDMASK;   <span class="hljs-comment">// 屏蔽模式</span><br>sFilterConfig.FilterScale = CAN_FILTERSCALE_32BIT;  <span class="hljs-comment">// 32位过滤器</span><br>sFilterConfig.FilterIdHigh = <span class="hljs-number">0x123</span> &lt;&lt; <span class="hljs-number">5</span>;            <span class="hljs-comment">// 标识符高位（标准标识符左移5位）</span><br>sFilterConfig.FilterIdLow = <span class="hljs-number">0x0000</span>;                 <span class="hljs-comment">// 标识符低位</span><br>sFilterConfig.FilterMaskIdHigh = <span class="hljs-number">0x7FF</span> &lt;&lt; <span class="hljs-number">5</span>;        <span class="hljs-comment">// 屏蔽高位，完全匹配</span><br>sFilterConfig.FilterMaskIdLow = <span class="hljs-number">0x0000</span>;             <span class="hljs-comment">// 屏蔽低位</span><br>sFilterConfig.FilterFIFOAssignment = CAN_RX_FIFO0;  <span class="hljs-comment">// 消息存储到FIFO0</span><br>sFilterConfig.FilterActivation = ENABLE;            <span class="hljs-comment">// 启用过滤器</span><br><br><span class="hljs-comment">// 应用过滤器</span><br><span class="hljs-keyword">if</span> (HAL_CAN_ConfigFilter(&amp;hcan, &amp;sFilterConfig) != HAL_OK) &#123;<br>    <span class="hljs-comment">// 处理错误</span><br>    Error_Handler();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="can总线是如何实现时钟同步的？"><a href="#can总线是如何实现时钟同步的？" class="headerlink" title="can总线是如何实现时钟同步的？"></a>can总线是如何实现时钟同步的？</h4><ol><li>硬同步（Hard Synchronization）<br>触发条件： 仅在帧起始（SOF，Start of Frame）的下降沿触发。<br>作用： 强制将接收节点的位时间计数器重置为Sync_Seg的起点，与发送节点对齐。<br>目的： 在每帧开始时消除初始相位偏差。</li><li>再同步（Re-synchronization）<br>触发条件： 在数据帧的后续位中，检测到信号边沿（从显性电平到隐性电平的跳变）。<br>作用： 根据边沿的位置调整Phase_Seg1和Phase_Seg2的长度，补偿节点间时钟频率差异。<br>调整规则：<br>如果边沿出现在Phase_Seg1中：延长Phase_Seg1，补偿时钟偏差。<br>如果边沿出现在Phase_Seg2中：缩短Phase_Seg2，补偿时钟偏差。<br>再同步调整是临时性的，仅作用于当前帧的后续位传输。新的帧来临时会复原位时间。</li></ol><h3 id="请解释一下嵌入式系统中的看门狗定时器的作用。"><a href="#请解释一下嵌入式系统中的看门狗定时器的作用。" class="headerlink" title="请解释一下嵌入式系统中的看门狗定时器的作用。"></a>请解释一下嵌入式系统中的看门狗定时器的作用。</h3><p>看门狗定时器主要作用是监控和重置系统，以防止因软件故障（如死循环、程序跑飞等）导致的系统崩溃。看门狗定时器的工作原理如下：<br>定时监控：看门狗定时器会周期性地检查系统是否正常运行。这通常通过检查主程序是否在规定的时间内执行了特定的操作（如喂狗操作）来实现。<br>超时重置：如果系统未能在预定时间内执行喂狗操作，看门狗定时器将认为系统出现故障，并自动触发重置信号。这通常会导致系统重启，从而尝试恢复正常运行。<br>提高系统可靠性：通过及时检测和重置系统故障，看门狗定时器可以显著提高嵌入式系统的可靠性和稳定性。</p><h3 id="在嵌入式开发中，如何进行功耗管理？"><a href="#在嵌入式开发中，如何进行功耗管理？" class="headerlink" title="在嵌入式开发中，如何进行功耗管理？"></a>在嵌入式开发中，如何进行功耗管理？</h3><p>功耗管理可以从硬件设计、软件优化以及系统级优化三个方面进行。</p><h4 id="硬件设计"><a href="#硬件设计" class="headerlink" title="硬件设计"></a>硬件设计</h4><ul><li>选择低功耗硬件组件：在硬件设计阶段，应优先考虑选择低功耗的处理器、传感器、存储器等组件。</li><li>优化硬件设计：通过合理布局和布线，减少信号干扰和能量损失。</li><li>降低硬件功耗：采用低功耗工作模式，如休眠模式、待机模式等，以减少非工作状态的能耗。</li></ul><h4 id="软件优化"><a href="#软件优化" class="headerlink" title="软件优化"></a>软件优化</h4><ul><li>算法优化：通过对算法的优化，降低算法的时间复杂度和空间复杂度，从而减少CPU和内存的消耗，进而降低功耗。</li><li>数据压缩：通过数据压缩技术，减少数据传输和处理的功耗。例如，使用Huffman编码、Lempel-Ziv-Welch(LZW)编码等无失真压缩算法。</li><li>操作系统级别的功耗优化：操作系统可以提供多种功耗管理策略，如动态电源管理、CPU频率调整等，以根据系统的实际负载动态调整功耗。</li></ul><h4 id="系统级优化"><a href="#系统级优化" class="headerlink" title="系统级优化"></a>系统级优化</h4><ul><li>功耗模式管理：根据系统的需求和运行状态选择不同的功耗模式，如正常工作模式、低功耗模式、休眠模式等。</li><li>任务调度优化：通过合理的任务调度策略，如使用RTOS（实时操作系统）的抢占式调度和时间片轮询调度算法，确保高优先级任务能够及时响应，同时减少低优先级任务的能耗。</li></ul><h3 id="HEX文件和BIN文件的区别？"><a href="#HEX文件和BIN文件的区别？" class="headerlink" title="HEX文件和BIN文件的区别？"></a>HEX文件和BIN文件的区别？</h3><p>HEX文件是包括地址信息的，而BIN文件格式只包括了数据本身</p><h3 id="单片机程序与Linux的程序的区别"><a href="#单片机程序与Linux的程序的区别" class="headerlink" title="单片机程序与Linux的程序的区别"></a>单片机程序与Linux的程序的区别</h3><p>单片机的 CPU 是直接操作内存的「物理地址」，单片机是没有操作系统的，所以每次写完代码，都需要借助工具把程序烧录进去，这样程序才能跑起来。因此，要想在内存中同时运行两个程序是不可能的。<br>操作系统是如何解决这个问题呢？ 操作系统会提供一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来。如果程序要访问虚拟地址的时候，由操作系统转换成不同的物理地址，这样不同的进程运行的时候，写入的是不同的物理地址，这样就不会冲突了。我们程序所使用的内存地址叫做虚拟内存地址(Virtual Memory Address)。实际存在硬件里面的空间地址叫物理内存地址(Physical Memory Address)。<br>单片机代码运行在Flash上，而Linux代码运行在内存上。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
