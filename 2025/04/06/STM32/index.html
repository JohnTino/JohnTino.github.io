

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <meta name="referrer" content="no-referrer" />
  
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="JohnTino">
  <meta name="keywords" content="">
  
    <meta name="description" content="一个记录STM32外设通信协议知识点的博客。 STM32秋招八股通信方式分类1.同步&#x2F;异步传输同步传输是一种典型的基于字节的输入输出，数据按每次一个字节进行传输，其传输速度低，有时钟线，时钟线保证发送和接收双方的信号能够同步起来，如I2C(SDA\SCL)，SPI(SCLK\CS\MOSI\MISO)， USART。异步传输需要外界的时钟信号进行通信，是把数据字节组合起来一起发送，这种组">
<meta property="og:type" content="article">
<meta property="og:title" content="STM32笔记">
<meta property="og:url" content="http://example.com/2025/04/06/STM32/index.html">
<meta property="og:site_name" content="JohnTino&#39;s Blog">
<meta property="og:description" content="一个记录STM32外设通信协议知识点的博客。 STM32秋招八股通信方式分类1.同步&#x2F;异步传输同步传输是一种典型的基于字节的输入输出，数据按每次一个字节进行传输，其传输速度低，有时钟线，时钟线保证发送和接收双方的信号能够同步起来，如I2C(SDA\SCL)，SPI(SCLK\CS\MOSI\MISO)， USART。异步传输需要外界的时钟信号进行通信，是把数据字节组合起来一起发送，这种组">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/post/6.jpg">
<meta property="article:published_time" content="2025-04-06T13:00:00.000Z">
<meta property="article:modified_time" content="2025-05-11T05:02:42.766Z">
<meta property="article:author" content="JohnTino">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/post/6.jpg">
  
  
  
  <title>STM32笔记 - JohnTino&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/scroll.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  



  
<meta name="generator" content="Hexo 7.3.0"></head>


<body><!-- hexo injector body_begin start --><div id="web_bg"></div><!-- hexo injector body_begin end -->
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>JohnTino&#39;s Blog</strong>
      <!-- 2025-5-11 -->
      <!-- <strong class="navbar-title">JohnTino&#39;s Blog</strong> -->
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="STM32笔记"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-04-06 21:00" pubdate>
          2025年4月6日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          13k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          109 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

    <script>
      var OriginTitile = document.title;
      var titleTime;
      document.addEventListener('visibilitychange', function () {
        if (document.hidden) {
          // 离开当前页面时标签显示内容
          document.title = '青山一片云雾';
          clearTimeout(titleTime);
        } else {
          // 返回当前页面时标签显示内容
          document.title = '心安即归处';
          // 两秒后变回正常标题
          titleTime = setTimeout(function () {
            document.title = OriginTitile;
          }, 2000);
        }
      });
    </script>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">STM32笔记</h1>
            
            
              <div class="markdown-body">
                
                <p>一个记录STM32外设通信协议知识点的博客。</p>
<h2 id="STM32秋招八股"><a href="#STM32秋招八股" class="headerlink" title="STM32秋招八股"></a>STM32秋招八股</h2><h3 id="通信方式分类"><a href="#通信方式分类" class="headerlink" title="通信方式分类"></a>通信方式分类</h3><h4 id="1-同步-异步传输"><a href="#1-同步-异步传输" class="headerlink" title="1.同步&#x2F;异步传输"></a>1.同步&#x2F;异步传输</h4><p>同步传输是一种典型的基于字节的输入输出，数据按每次一个字节进行传输，其传输速度低，有时钟线，时钟线保证发送和接收双方的信号能够同步起来，如I2C(SDA\SCL)，SPI(SCLK\CS\MOSI\MISO)， USART。<br>异步传输需要外界的时钟信号进行通信，是把数据字节组合起来一起发送，这种组合称之为帧，其传输速度比异步传输快，无时钟线， 波特率作为约束条件，如UART ，传输双方统一波特率，常见波特率9600&#x2F;51，115200&#x2F;STM32。  </p>
<h4 id="2-串行-并行"><a href="#2-串行-并行" class="headerlink" title="2.串行&#x2F;并行"></a>2.串行&#x2F;并行</h4><p>外设协议如UART、IIC、SPI、RS232、RS485、CAN都是串行。<br>效率不同：并行传输效率高，一次可传输多个数据；串行传输一次可传输一个数据。<br>速度不同：大多数情况下串行速度更快     传输距离不同：并行传输适用于短距离，串行适用于长距离。  </p>
<h4 id="3-方向-时间"><a href="#3-方向-时间" class="headerlink" title="3.方向&#x2F;时间"></a>3.方向&#x2F;时间</h4><p>全双工：在通信的任意时刻，线路上存在A到B和B到A的双向信号传输，如UART和SPI。<br>半双工：可以实现双向的通信，但不能在两个方向同时进行，必须轮流交替进行，如I2C。<br>单工：发送端只能发送信息，不能接收信息；接收端只能接收信息，不能发送信息。  </p>
<h3 id="计算机三大总线"><a href="#计算机三大总线" class="headerlink" title="计算机三大总线"></a>计算机三大总线</h3><h4 id="数据总线DB"><a href="#数据总线DB" class="headerlink" title="数据总线DB"></a>数据总线DB</h4><p>数据总线DB用来传送数据信息，是双向的。CPU既可通过DB从内存或输入设备读入数据，又可通过DB将内部数据送至内存或输出设备。DB的宽度决定了CPU和计算机其他设备之间每次交换数据的位数。数据总线的位数是微型计算机的一个重要指标，通常与微处理的字长相一致。需要指出的是，数据的含义是广义的，它可以是真正的数据，也可以是指令代码或状态信息，有时甚至是一个控制信息，因此，在实际工作中，数据总线上传送的并不一定仅仅是真正意义上的数据。</p>
<h4 id="地址总线AB"><a href="#地址总线AB" class="headerlink" title="地址总线AB"></a>地址总线AB</h4><p>地址总线AB用于传送CPU发出的地址信息，是单向的。传送地址信息的目的是指明与CPU交换信息的内存单元或I&#x2F;O设备。存储器是按地址访问的，所以每个存储单元都有一个固定地址，要访问1MB存储器中的任一单元，需要给出1M个地址，即需要20位地址（2^20&#x3D;1M）。一般来说，若地址总线为n位，则可寻址空间为2^n字节。因此，地址总线的宽度决定了CPU 的最大寻址能力。</p>
<h4 id="控制总线CB"><a href="#控制总线CB" class="headerlink" title="控制总线CB"></a>控制总线CB</h4><p>控制总线CB用来传送控制信号、时序信号和状态信息等，是双向的。其中有的是CPU向内存或外部设备发出的信息，如读&#x2F;写信号，片选信号、中断响应信号等；有的是内存或外部设备向CPU发出的信息，中断申请信号、复位信号、总线请求信号、设备就绪信号等。显然，CB中的每一条线的信息传送方向是一定的、单向的，但作为一个整体则是双向的。所以，凡涉及到控制总线CB，均是以双向线表示。</p>
<h4 id="单片机总线及挂载外设"><a href="#单片机总线及挂载外设" class="headerlink" title="单片机总线及挂载外设"></a>单片机总线及挂载外设</h4><p>AHB：高级高性能总线（Advanced High Performance Bus），主要用于连接高性能模块，如CPU、DMA和DSP等。<br>APB1：高级外设总线1（Advanced Peripheral Bus 1），属于低速外设总线, 时钟频率通常为系统时钟的一半，STM32F103为72MHz的一半。连接低速外设，如定时器TIM2到TIM7、RTC、WDT看门狗、SPI2、SPI3、USART2、USART3、UART4、UART5、I2C1、I2C2、USB&#x2F;CAN共享的512字节SRAM、bXCAN1、bXCAN2、后备寄存器、电源控制PWR、DAC等<br>APB2：高级外设总线2（Advanced Peripheral Bus 2），属于高速外设总线。连接如USART1、高级控制定时器TIM1和TIM8、模数转换器ADC1、ADC2、ADC3、SPI1、外部中断EXTI、复用IO:AFIO、通用IO:GPIOA-G等<br><img src="https://raw.githubusercontent.com/JohnTino/blogImage/main/img/F103Bridge.png" srcset="/img/loading.gif" lazyload><br>分频器：对频率做除法<br>锁相环：对频率做乘法<br>复用器：对频率做选择 </p>
<h3 id="复用与映射"><a href="#复用与映射" class="headerlink" title="复用与映射"></a>复用与映射</h3><p>复用指Pin脚本身除了支持普通GPIO功能之外，还支持别的功能，使用别的功能就叫复用。AFIO复用IO口指AFIO主要用于引脚复用功能的选择和重定义。在STM32中，AFIO主要完成两个任务：复用功能引脚重映射、中断引脚选择。重映射指Pin脚本身不支持这些功能，配置重映射寄存器，使其具备别的功能。</p>
<h3 id="标准库和HAL库的区别"><a href="#标准库和HAL库的区别" class="headerlink" title="标准库和HAL库的区别"></a>标准库和HAL库的区别</h3><p>标准库：1、直接操作寄存器，代码较为底层。2、配置灵活但代码复杂，容易出错。3、不同 STM32 系列的代码兼容性较差。<br>HAL 库：1、提供统一的 API，代码更简洁。 2、支持跨平台和跨系列移植。3、功能更强大，但运行时效率稍低（因增加了抽象层）。</p>
<h3 id="STM32F1和F4的区别？"><a href="#STM32F1和F4的区别？" class="headerlink" title="STM32F1和F4的区别？"></a>STM32F1和F4的区别？</h3><p>内核不同：F1是Cortex-M3内核，F4是Cortex-M4内核；<br>主频不同：F1主频72MHz，F4主频168MHz；<br>浮点运算：F1无浮点运算单位，F4有；<br>功能性能：F4外设比F1丰富且功能更强大，比如GPIO翻转速率、上下拉电阻配置、ADC精度等；<br>内存大小：F1内部SRAM最大64K，F4有192K(112+64+16)。</p>
<h3 id="介绍以下STM32启动过程？"><a href="#介绍以下STM32启动过程？" class="headerlink" title="介绍以下STM32启动过程？"></a>介绍以下STM32启动过程？</h3><p>通过Boot引脚设定,寻找初始地址<br>初始化栈指针 __initial_sp<br>指向复位程序 Reset_Hander<br>设置异常中断 HardFault_Handler<br>设置系统时钟 SystemInit<br>调用C库函数 _main</p>
<h3 id="时钟树"><a href="#时钟树" class="headerlink" title="时钟树"></a>时钟树</h3><p>时钟RCC，Reset and Clock Control（复位和时钟控制），在绝大部分MCU芯片中都包含复位和时钟控制模块，也是MCU重要的组成部分。51单片机，11.0592Mhz晶振；stm32F103，8Mh晶振，主频72Mhz；stm32F407，12Mhz，主频168Mhz<br>时钟树：一种树状的电路结构，用于将主时钟信号（通常来自晶体振荡器或PLL）分配到芯片上的各个逻辑单元和模块。<br>时钟源：STM32的时钟源分为高速、低速两类时钟，同时也分内部和外部。<br>HSE：High Speed External，高速外部时钟，可接石英&#x2F;陶瓷谐振器，或者接外部时钟源，频率范围为4MHz~16MHz，c8t6是接的8Mhz。<br>HSI：High Speed Internal，高速内部时钟，RC振荡器，频率为8MHz，精度不高。<br>LSE：Low Speed External ，低速外部时钟 ，接频率为32.768kHz的石英晶体。<br>LSI：Low Speed Internal，低速内部时钟，RC振荡器，频率为40kHz，提供低功耗时钟。</p>
<h3 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h3><p><img src="https://raw.githubusercontent.com/JohnTino/blogImage/main/img/GPIO.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="输入模式"><a href="#输入模式" class="headerlink" title="输入模式"></a>输入模式</h4><p>浮空输入（IN_FLOATING），（IPU）上拉输入（TTL）、（IPD）下拉输入、（AIN）模拟输入(ADC)。<br>区别：<br>1.浮空输入没有上拉和下拉电阻，引脚的电平完全由外部电路决定（外部电路需要提供稳定电平），电平不稳定容易收到外界干扰，如按键输入、传感器信号；<br>2.上拉输入，接上拉电阻当没有外部信号作用时，默认电平为高电平，3.3v或者5v，当外部信号为低电平并产生作用时，引脚会被拉低。<br>3.下拉输入：接下拉电阻，默认电平为0V，如数字信号输入等；<br>4.模拟输入：用以接受模拟信号如（电压值），通常连接一个模数转换器（ADC），如传感器信号输入（如温度、光照、压力等）、音频信号输入（高精度）等。</p>
<h4 id="输出模式"><a href="#输出模式" class="headerlink" title="输出模式"></a>输出模式</h4><p>开漏输出（Out_OD、没有P-MOS，只能输出低电平）、推挽输出（Out_PP、高低电平都可）、推挽复用输出（AF_PP）、开漏复用输出（AF_OD）。GPIO输出速率有四种，分别是低速（2MHz）、中速（10MHz）和高速（50MHz）。<br>区别：<br>1.开漏输出只有 N-MOS 管，没有 P-MOS 管，因此只能输出低电平或高阻态（浮空），高电平需要通过外部上拉电阻才能进行输出，允许多个设备共享同一条总线（如 I²C 总线），应用在IIC、电平转换线路、总线共享的场景；<br>2.推挽输出包含 P-MOS 和 N-MOS 管，可以主动输出高电平和低电平，高电平时 P-MOS 导通，低电平时 N-MOS 导通，输出速度快，电平稳定，不支持多设备共享同一信号线（可能引起短路），应用在适合驱动较高负载（如 LED、电机等）、继电器等场景，以及SPI、UART等通信接口；复用不是让CPU直接写输出数据寄存器，而是利用片上外设模块的复用功能输出来决定的。<br>其中，I²C 总线：使用开漏输出或开漏复用输出，允许多个设备共享同一条总线。需要外部上拉电阻提供高电平。SPI 通信：使用推挽输出或推挽复用输出，确保高速、稳定的信号传输。GPIO 控制：如果需要驱动 LED 或继电器，使用推挽输出。如果用于按键检测，多个按键，无需驱动能力，可以选择开漏输出。  </p>
<h3 id="定时器-PWM"><a href="#定时器-PWM" class="headerlink" title="定时器&amp;PWM"></a>定时器&amp;PWM</h3><p>定时器可以对输入的时钟进行计数，并在计数值达到设定值时触发中断。16位计数器、预分频器、自动重装寄存器的时基单元，在72MHz计数时钟下可以实现最大59.65s的定时。不仅具备基本的定时中断功能，而且还包含内外时钟源选择、输入捕获、输出比较、编码器接口、主从触发模式等多种功能<br>配置参数：<br>计数器溢出频率：CK_CNT_OV &#x3D; CK_CNT&#x2F;(ARR+1) &#x3D; CK_PSC&#x2F;[(PSC + 1)*(ARR + 1)]<br>计数器计数频率：CK_CNT &#x3D; CK_PSC&#x2F;(PSC + 1)<br>溢出时间：1 &#x2F; CK_CNT<br>其中，CK_PSC为预分频器输出的频率，ARR为自动重装载寄存器的值，ARR+1是因为计数器从0开始计数，所以最大值是ARR，总共计数的次数是ARR+1次。</p>
<h4 id="定时器分类"><a href="#定时器分类" class="headerlink" title="定时器分类"></a>定时器分类</h4><p>基本定时器（TIM6    TIM7），通用定时器（TIM2，TIM3，TIM4，TIM5），高级定时器（TIM1，TIM8）<br><img src="https://raw.githubusercontent.com/JohnTino/blogImage/main/img/TIMcls.png" srcset="/img/loading.gif" lazyload><br>基本定时器：16位自动重装载累加计数器，仅支持向上技术；16位可编程（可实时修改）预分频器，用于对输入的时钟按系数1~65536之间的任意分频；出发DAC的同步电路；在更新事件（计数器溢出）时产生中断&#x2F;DMA请求<br>通用定时器：向上、向下、向上&#x2F;向下自动装载计数器，支持中心对齐计数。4个独立通道：输入捕获、输出比较、PWM生成（边缘或中间对齐模式）、单脉冲模式输出<br>高级定时器：死区时间可编程的互补输出；使用外部信号控制定时器和定时器互联的同步电路；允许在指定数目的计数器周期之后更新定时器寄存器的重复计数器；刹车输入信号可以将定时器输出信号置于复位状态或者一个已知状态；</p>
<h4 id="PWM相关参数"><a href="#PWM相关参数" class="headerlink" title="PWM相关参数"></a>PWM相关参数</h4><p>PWM（脉宽调制，Pulse Width Modulation）是一种通过调节信号的占空比来控制功率输出的技术。通过改变信号的占空比来模拟不同的电压或功率输出。<br>PWM 的关键参数<br>周期（T）：一个完整 PWM 信号的时间长度，单位为秒（s）。<br>频率（f）：PWM 信号的频率，是周期的倒数，单位为赫兹（Hz）。<br>占空比（D）：信号高电平时间（Ton）与周期（T）的比值，用百分比表示。<br>电压平均值（Vavg）：PWM 信号的等效输出电压。<br>计算公式：PWM频率 &#x3D; 芯片主频&#x2F;(PSC + 1)(ARR + 1) ，  占空比 &#x3D; CCR&#x2F;(ARR + 1)<br>其中，CCR：比较寄存器，用于设置高电平的时间。PSC：预分频器值，调整预分频值，可以控制计数器每次增加的速度。ARR：自动重装载值，设置ARR当计数器的值达到自动重装载值时，计数器会清零并重新开始计数，用于定时中断</p>
<h4 id="PWM两种模式"><a href="#PWM两种模式" class="headerlink" title="PWM两种模式"></a>PWM两种模式</h4><p>PWM1模式与PWM2模式，两种模式相似却又恰恰相反。<br>PWM1模式：向上计数，当 TIMx_CNT &lt; TIMx_CCRn 时，定时器 TIMx 的通道 n 为有效电平，否则为无效电平；向下计数，当 TIMx_CNT &gt; TIMx_CCRn 时，定时器 TIMx 的通道 n 为无效电平，否则为有效电平。<br>PWM1模式的逻辑是：在 CNT &lt; CCRn 时输出有效电平，其他情况输出无效电平（无论向上还是向下计数）。<br>PWM2 模式：向上计数，当 TIMx_CNT &lt; TIMx_CCRn 时，定时器 TIMx 的通道 n 为无效电平，否则为有效电平；向下计数，当 TIMx_CNT &gt; TIMx_CCRn 时，定时器 TIMx 的通道 n 为有效电平，否则为无效电平<br>PWM2 模式的逻辑是：在 CNT &lt; CCRn 时输出无效电平，其他情况输出有效电平（无论向上还是向下计数）。<br>其中，TIMx 表示 STM32 的定时器，x 表示某个定时器，取值需要根据芯片来定；TIMx_CNT，表示定时器 TIMx 的计数器寄存器值（计数值）； TIMx_CCRn，表示捕获比较寄存器的值（比较值），其中 n 表示某个通道，取值为1、2、3、4；</p>
<h3 id="UART通信"><a href="#UART通信" class="headerlink" title="UART通信"></a>UART通信</h3><h4 id="UART通信特点"><a href="#UART通信特点" class="headerlink" title="UART通信特点"></a>UART通信特点</h4><p>全双工异步串行通信，TX、RX两根线，点对点通信方式，一般只连接两个设备，通信双方需要相同的波特率进行通信。波特率：每秒传送一bit的数量，每秒传输二进制代码的位数，所以单位是bits&#x2F;s；</p>
<h4 id="UART帧格式（时序图）"><a href="#UART帧格式（时序图）" class="headerlink" title="UART帧格式（时序图）"></a>UART帧格式（时序图）</h4><p>时序图：UART 在发送或接收过程中的一帧数据由4部分组成，起始位、数据位、奇偶校验位和停止位，其中，<br>1、起始位标志着一帧数据的开始，低电平0；<br>2、数据位是一帧数据中的有效数据，可以是5~8位；<br>3、校验位分为奇校验和偶校验，用于检验数据在传输过程中是否出错。奇校验时，发送方应使数据位中1的个数与校验位中1的个数之和为奇数；接收方在接收数据时，对1的个数进行检查，若不为奇数，则说明数据在传输过程中出了差错。同样，偶校验则检查1的个数是否为偶数。<br>4、停止位标志着一帧数据的结束，高电平1，停止位一般是1 位、1.5位、2位；<br>5、空闲位，高电平1</p>
<h4 id="UART与USART区别"><a href="#UART与USART区别" class="headerlink" title="UART与USART区别"></a>UART与USART区别</h4><p>USART是通用同步和异步收发器，UART是通用异步收发器，当进行异步通信时,这两者是没有区别的。区别在于USART比UART多了同步通信功能。这个同步通信功能可以把USART当做SPI来用，比如用USART来驱动SPI设备。</p>
<h3 id="RS232和RS485通讯接口有什么区别？"><a href="#RS232和RS485通讯接口有什么区别？" class="headerlink" title="RS232和RS485通讯接口有什么区别？"></a>RS232和RS485通讯接口有什么区别？</h3><ol>
<li>传输方式不同。 RS232采取不平衡传输方式，即所谓单端通讯。 而RS485则采用平衡传输，即差分传输方式。</li>
<li>传输距离不同。RS232适合本地设备之间的通信，传输距离一般不超过20m。而RS485的传输距离为几十米到上千米。</li>
<li>设备数量。RS232 只允许一对一通信，点对点。当相互通信的节点超过2个时，使用RS485，RS485 接口在总线上是允许连接多达128个收发器。</li>
<li>连接方式。RS232，规定用电平表示数据，因此线路就是单线路的，用两根线才能达到全双工的目的；而RS485， 使用差分电平表示数据，因此，必须用两根线才能达到传输数据的基本要求，要实现全双工，必需用4根线。</li>
</ol>
<h3 id="串口相关的硬件信号"><a href="#串口相关的硬件信号" class="headerlink" title="串口相关的硬件信号"></a>串口相关的硬件信号</h3><p>TTL：单片机引脚直接发出来的信号，0 ~ 5V。<br>USB转串口芯片：为了解决USB接口与单片机串口接口之间的兼容性问题，市场上出现了多种USB转串口芯片(如CH340、PL2303等)。这些芯片能够将USB接口转换为虚拟的串口接口(即COM口)，从而在计算机上模拟出传统的串口通信环境，CH340模块把TTL信号转为USB信号、差分信号。<br>RS232接口任何一条信号线的电压均为负逻辑关系。即：逻辑”1”为-3 ~ -15V。逻辑“0”：+3 ~ +15V，噪声容限为2V。即要求接收器能识别高于+3V的信号作为逻辑”0”，低于-3V的信号作为逻辑”1”。<br>RS485的电气特性：逻辑“1”以两线间的电压差为+2 ~ +6V表示。逻辑“0”以两线间的电压差为-6 ~ -2V表示。RS232、RS485，都是TTL转过来了的，485是差分信号。<br>RS485四种工作模式：1、点到点，四线全双工  2、点到多点，四线全双工   3、点到点，两线半双工  4、点对多点，两线半双工<br>ARM  TTL 电平 (电平转换芯片) ———-&gt; DB-9，电脑串口 RS232<br>ARM  TTL 电平 (USB串口芯片) ———–&gt; 通过USB线 连接电脑，电脑USB口  </p>
<h3 id="IIC通信"><a href="#IIC通信" class="headerlink" title="IIC通信"></a>IIC通信</h3><h4 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h4><p>1.总线空闲状态<br>在通信开始之前，I2C总线处于空闲状态，即SDA和SCL线都处于高电平。<br>2.发送启动信号（START）<br>主设备在SCL线为高电平时，将SDA线从高电平拉低，形成启动信号。这一过程标志着通信的开始。<br>3.发送设备地址和读写位<br>启动信号后，主设备发送目标设备的地址（通常为7位）和读写位。读写位为0表示写操作，为1表示读操作。<br>4.等待应答信号（ACK）<br>从设备接收到地址和读写位后，返回一个应答信号（ACK）。如果从设备未响应，主设备可以根据需要进行重试或处理错误。<br>5.数据传输<br>主设备根据读写位的设置，开始与从设备进行数据的读写操作。若读，则从-&gt;主，若写，则主-&gt;从。每传输一个字节后，接收方返回一个应答信号。<br>6.发送停止信号（STOP）<br>数据传输完成后，主设备在SCL线为高电平时，将SDA线从低电平拉高，形成停止信号，标志着通信的结束。<br><img src="https://raw.githubusercontent.com/JohnTino/blogImage/main/img/IIC.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="IIC读操作需要发送两次启动信号的原因是"><a href="#IIC读操作需要发送两次启动信号的原因是" class="headerlink" title="IIC读操作需要发送两次启动信号的原因是"></a>IIC读操作需要发送两次启动信号的原因是</h4><p>第一次启动信号：主机发送启动信号，然后发送从设备地址和写操作位（R&#x2F;W&#x3D;0），接着发送内部寄存器地址，用于指定要读取的数据位置。第二次启动信号：主机再次发送启动信号，然后发送从设备地址和读操作位（R&#x2F;W&#x3D;1），开始读取数据。</p>
<h4 id="简述IIC特点"><a href="#简述IIC特点" class="headerlink" title="简述IIC特点"></a>简述IIC特点</h4><p>1.由数据线SDA和时钟SCL构成的串行总线，可发送和接收数据，是一个多主机的同步半双工通信方式。每个挂接在总线上的器件都有个唯一的地址。<br>2.分为软件IIC和硬件IIC，软件IIC 流程清楚、占用时间多、速度慢；硬件IIC速度块、可以用DMA、用法比较复杂。51只有软件IIC，没有外设；STM32具有IIC外设，因此软件IIC和硬件IIC都可以。<br>3.IIC总线最多挂在2^7-1&#x3D;127个设备，0地址不算(广播)；在你不知道从机地址的时候，通过设备枚举，for函数，给所有设备枚举一遍<br>4.SDA 、SCL接上拉电阻4.7K-10K，   用于控制其高低电平，两条数据线开漏输出（OD）。<br>4.三种模式：标准100Kb&#x2F;s（周期10us）、快速400Kb&#x2F;s，高速3.4Mb&#x2F;s，超高速…..</p>
<h4 id="IIC协议中的总线仲裁是如何工作的"><a href="#IIC协议中的总线仲裁是如何工作的" class="headerlink" title="IIC协议中的总线仲裁是如何工作的?"></a>IIC协议中的总线仲裁是如何工作的?</h4><p>IICC使用总线仲裁机制来解决多个设备同时试图传输数据的冲突。所有设备都监视总线上的数据线(SDA)，如果设备检测到其他设备在发送不同的数据，它将放弃总线，优先发送低地址的设备(逻辑”0”优先)，从而实现仲裁。</p>
<h4 id="讲一下IIC，SPI，UART的区别"><a href="#讲一下IIC，SPI，UART的区别" class="headerlink" title="讲一下IIC，SPI，UART的区别"></a>讲一下IIC，SPI，UART的区别</h4><p>1.同步与异步：SPI和IIC是同步通信，依赖时钟信号；而UART是异步通信，使用起始位和停止位来界定数据包。<br>2.通信速度：SPI通常提供最高的数据传输速度，其次是IIC，UART相对较慢。IIC是KHz级，SPI是MHz级。<br>3.信号线数量：SPI使用四条线，IIC使用两条线，UART使用三到四条线。<br>4.多设备通信：IIC和SPI都支持多设备通信，但SPI需要为每个设备提供单独的SS（片选）信号线，而IIC通过地址识别设备。<br>5.应用范围：SPI和IIC主要用于短距离、同一电路板上的设备间通信，而UART更适用于长距离或不同设备间的通信。</p>
<h4 id="编写软件模拟I2C的代码。"><a href="#编写软件模拟I2C的代码。" class="headerlink" title="编写软件模拟I2C的代码。"></a>编写软件模拟I2C的代码。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 延时函数，模拟时序</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">I2C_Delay</span><span class="hljs-params">()</span> &#123;<br>    usleep(<span class="hljs-number">5</span>);  <span class="hljs-comment">// 微秒级延时，控制时钟速度</span><br>&#125;<br><span class="hljs-comment">// 产生I2C起始信号 (SDA下降，SCL保持高电平)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">I2C_Start</span><span class="hljs-params">()</span> &#123;<br>    GPIO_SetPinHigh(SDA_PIN);<br>    GPIO_SetPinHigh(SCL_PIN);<br>    I2C_Delay();<br>    GPIO_SetPinLow(SDA_PIN);<br>    I2C_Delay();<br>    GPIO_SetPinLow(SCL_PIN);<br>&#125;<br><span class="hljs-comment">// 产生I2C停止信号 (SDA上升，SCL保持高电平)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">I2C_Stop</span><span class="hljs-params">()</span> &#123;<br>    GPIO_SetPinLow(SDA_PIN);<br>    GPIO_SetPinHigh(SCL_PIN);<br>    I2C_Delay();<br>    GPIO_SetPinHigh(SDA_PIN);<br>    I2C_Delay();<br>&#125;<br><span class="hljs-comment">// 发送ACK信号</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">I2C_SendAck</span><span class="hljs-params">()</span> &#123;<br>    GPIO_SetPinLow(SDA_PIN);<br>    GPIO_SetPinHigh(SCL_PIN);<br>    I2C_Delay();<br>    GPIO_SetPinLow(SCL_PIN);<br>&#125;<br><span class="hljs-comment">// 发送NACK信号</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">I2C_SendNack</span><span class="hljs-params">()</span> &#123;<br>    GPIO_SetPinHigh(SDA_PIN);<br>    GPIO_SetPinHigh(SCL_PIN);<br>    I2C_Delay();<br>    GPIO_SetPinLow(SCL_PIN);<br>&#125;<br><span class="hljs-comment">// 读取ACK信号</span><br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">I2C_ReadAck</span><span class="hljs-params">()</span> &#123;<br>    GPIO_SetPinHigh(SDA_PIN);  <span class="hljs-comment">// 释放SDA，等待从设备响应</span><br>    GPIO_SetPinHigh(SCL_PIN);<br>    I2C_Delay();<br>    <span class="hljs-type">uint8_t</span> ack = GPIO_ReadPin(SDA_PIN);<br>    GPIO_SetPinLow(SCL_PIN);<br>    <span class="hljs-keyword">return</span> ack == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;  <span class="hljs-comment">// 0表示ACK，1表示NACK</span><br>&#125;<br><span class="hljs-comment">// 发送一个字节数据</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">I2C_WriteByte</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> data)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (data &amp; <span class="hljs-number">0x80</span>)  <span class="hljs-comment">// 判断最高位</span><br>            GPIO_SetPinHigh(SDA_PIN);<br>        <span class="hljs-keyword">else</span><br>            GPIO_SetPinLow(SDA_PIN);<br>        GPIO_SetPinHigh(SCL_PIN);<br>        I2C_Delay();<br>        GPIO_SetPinLow(SCL_PIN);<br>        data &lt;&lt;= <span class="hljs-number">1</span>;  <span class="hljs-comment">// 左移一位</span><br>    &#125;<br>    I2C_ReadAck();<br>&#125;<br><span class="hljs-comment">// 读取一个字节数据</span><br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">I2C_ReadByte</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> ack)</span> &#123;<br>    <span class="hljs-type">uint8_t</span> data = <span class="hljs-number">0</span>;<br>    GPIO_SetPinHigh(SDA_PIN);  <span class="hljs-comment">// 释放SDA，准备接收数据</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) &#123;<br>        GPIO_SetPinHigh(SCL_PIN);<br>        I2C_Delay();<br>        data = (data &lt;&lt; <span class="hljs-number">1</span>) | GPIO_ReadPin(SDA_PIN);<br>        GPIO_SetPinLow(SCL_PIN);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (ack)<br>        I2C_SendAck();<br>    <span class="hljs-keyword">else</span><br>        I2C_SendNack();<br>    <span class="hljs-keyword">return</span> data;<br>&#125;<br><span class="hljs-comment">// I2C设备写入示例</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">I2C_WriteToDevice</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> deviceAddr, <span class="hljs-type">uint8_t</span> regAddr, <span class="hljs-type">uint8_t</span> data)</span> &#123;<br>    I2C_Start();<br>    I2C_WriteByte(deviceAddr &lt;&lt; <span class="hljs-number">1</span>);  <span class="hljs-comment">// 发送设备地址 + 写位</span><br>    I2C_WriteByte(regAddr);           <span class="hljs-comment">// 发送寄存器地址</span><br>    I2C_WriteByte(data);               <span class="hljs-comment">// 发送数据</span><br>    I2C_Stop();<br>&#125;<br><span class="hljs-comment">// I2C设备读取示例</span><br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">I2C_ReadFromDevice</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> deviceAddr, <span class="hljs-type">uint8_t</span> regAddr)</span> &#123;<br>    <span class="hljs-type">uint8_t</span> data;<br>    I2C_Start();<br>    I2C_WriteByte(deviceAddr &lt;&lt; <span class="hljs-number">1</span>);  <span class="hljs-comment">// 发送设备地址 + 写位</span><br>    I2C_WriteByte(regAddr);           <span class="hljs-comment">// 发送寄存器地址</span><br>    I2C_Start();<br>    I2C_WriteByte((deviceAddr &lt;&lt; <span class="hljs-number">1</span>) | <span class="hljs-number">1</span>);  <span class="hljs-comment">// 发送设备地址 + 读位</span><br>    data = I2C_ReadByte(<span class="hljs-number">0</span>);                 <span class="hljs-comment">// 读取数据并发送NACK</span><br>    I2C_Stop();<br>    <span class="hljs-keyword">return</span> data;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="SPI通信"><a href="#SPI通信" class="headerlink" title="SPI通信"></a>SPI通信</h3><h4 id="介绍一下SPI通信"><a href="#介绍一下SPI通信" class="headerlink" title="介绍一下SPI通信"></a>介绍一下SPI通信</h4><p>一种高速、全双工、同步的通信总线（输出推挽，要求高速以及数据稳定；输入引脚配置为浮空或上拉输入）。SPI总线系统是一种同步串行外设接口，它可以使MCU与各种外围设备以串行方式进行通信以交换信息。SPI总线可直接与各个厂家生产的多种标准外围器件相连，包括FLASH、RAM、网络控制器、LCD显示驱动器、A&#x2F;D转换器和MCU等。SPI接口的读写操作同IIC一样，都是由主设备发起。当存在多个从设备时，通过各自的片选信号进行管理。</p>
<h4 id="SPI通信特点"><a href="#SPI通信特点" class="headerlink" title="SPI通信特点"></a>SPI通信特点</h4><p>1.四根通信线：SCLK（Serial Clock）、MOSI（Master Output Slave Input）、MISO（Master Input Slave Output）、SS（Slave Select）。 MISO：主设备输入&#x2F;从设备输出引脚。该引脚在从模式下发送数据，在主模式下接收数据。MOSI：主设备输出&#x2F;从设备输入引脚。该引脚在主模式下发送数据，在从模式下接收数据。SCLK：串行时钟信号，由主设备产生。CS&#x2F;SS：从设备片选信号，由主设备控制。它的功能是用来作为“片选引脚”，也就是选择指定的从设备，让主设备可以单独地与特定从设备通讯，避免数据线上的冲突。<br>2.SPI没有应答机制，发送就直接发送，接收就直接接收；<br>3.主从模式：一主一从；一主多从；不能多主。<br>4.没有复杂的寻址机制，使用专用的片选线选择从设备<br>5.没有应答机制，主设备无法确认从设备是否正确接收数据</p>
<h4 id="硬件SPI和软件模拟SPI的区别有哪些？"><a href="#硬件SPI和软件模拟SPI的区别有哪些？" class="headerlink" title="硬件SPI和软件模拟SPI的区别有哪些？"></a>硬件SPI和软件模拟SPI的区别有哪些？</h4><p>硬件SPI的效率要比软件模拟SPI高，写程序的时候只要把要发的数据写在寄存器里，硬件就会自动给你发了，软件模拟SPI则需要器实现时钟的拉高拉低，数据串行输出等等。硬件SPI必须要处理器支持才可以用，软件SPI就不需要特定的要求了，一般IO口就可用。</p>
<h4 id="SPI有几种工作模式？它们有什么区别？"><a href="#SPI有几种工作模式？它们有什么区别？" class="headerlink" title="SPI有几种工作模式？它们有什么区别？"></a>SPI有几种工作模式？它们有什么区别？</h4><p>SPI有4种工作模式（Mode 0-3），不同的从设备可能在出厂是就是配置为某种模式，这是不能改变的；但通信双方必须是工作在同一模式下，所以可以对主设备的SPI模式进行配置，通过CPOL（时钟极性）和CPHA（时钟相位）来控制我们主设备的通信模式。<br>时钟极性(CPOL)定义了时钟空闲状态电平。CPOL&#x3D;0，表示当SCLK&#x3D;0时总线状态时钟为空闲（低电平），所以有效状态就是SCLK处于高电平时，第一个跳变为上升沿；CPOL&#x3D;1，表示当SCLK&#x3D;1时总线状态时钟为空闲（高电平），所以有效状态就是SCLK处于低电平时，第一个跳变为下降沿。<br>时钟相位(CPHA)定义数据的采集时间。CPHA&#x3D;0，在时钟的第一个跳变沿（上升沿或下降沿）进行数据采样，数据在第一个时钟边沿采样，在第2个边沿发送数据；CPHA&#x3D;1，在时钟的第二个跳变沿（上升沿或下降沿）进行数据采样，数据在第二个时钟边沿采样，在第1个边沿发送数据。<br>模式0：CPOL&#x3D;0,CPHA&#x3D;0<br><img src="https://raw.githubusercontent.com/JohnTino/blogImage/main/img/spimode0.png" srcset="/img/loading.gif" lazyload><br>模式1：CPOL&#x3D;0,CPHA&#x3D;1<br><img src="https://raw.githubusercontent.com/JohnTino/blogImage/main/img/spimode1.png" srcset="/img/loading.gif" lazyload><br>模式2：CPOL&#x3D;1,CPHA&#x3D;0<br><img src="https://raw.githubusercontent.com/JohnTino/blogImage/main/img/spimode2.png" srcset="/img/loading.gif" lazyload><br>模式3：CPOL&#x3D;1,CPHA&#x3D;1<br><img src="https://raw.githubusercontent.com/JohnTino/blogImage/main/img/spimode3.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="中断相关"><a href="#中断相关" class="headerlink" title="中断相关"></a>中断相关</h3><p>中断是指在主程序运行过程中，出现了特定的中断触发条件（中断源），使得CPU暂停当前正在运行的程序，转而去处理中断程序，处理完成后又返回原来被暂停的位置继续运行，CPU参与，而DMA是外设与内存进行交互（CPU不参与）。</p>
<h4 id="DMA方式和中断控制方式的主要区别"><a href="#DMA方式和中断控制方式的主要区别" class="headerlink" title="DMA方式和中断控制方式的主要区别"></a>DMA方式和中断控制方式的主要区别</h4><p>1.中断控制方式在每个数据传送完成之后中断CPU，而DMA控制方式则在所要求的传送的一批数据传送结束时中断CPU。<br>2.中断控制方式中的数据传送在中断处理时由CPU控制完成，而DMA控制方式则在DMA控制器下完成。不过，在DMA的控制方式中,数据的传送方向，存放数据的内存始址及传送数据的长度等信息仍然由CPU控制。<br>3.中断控制方式以CPU为核心，而DMA方式以存储器为核心，因此DMA方式可与CPU并行工作。<br>4.中断控制方式传输的数据以字节为单位，而DMA方式传送批量数据，其基本单位为数据块(通常一个数据块包含若干字节)。</p>
<h4 id="中断与异常有何区别？"><a href="#中断与异常有何区别？" class="headerlink" title="中断与异常有何区别？"></a>中断与异常有何区别？</h4><p>中断是指外部硬件产生的一个电信号从CPU的中断引脚进入，打断CPU的运行。异常是指软件运行过程中发生了一些必须作出处理的事件，CPU自动产生一个陷入来打断CPU的运行。异常在处理的时候必须考虑与处理器的时钟同步，实际上异常也称为同步中断，在处理器执行到因编译错误而导致的错误指令时，或者在执行期间出现特殊错误，必须靠内核处理的时候，处理器就会产生一个异常。</p>
<h4 id="中断服务程序能不能有参数和返回值？"><a href="#中断服务程序能不能有参数和返回值？" class="headerlink" title="中断服务程序能不能有参数和返回值？"></a>中断服务程序能不能有参数和返回值？</h4><p>（1）在单片机裸机程序中，中断服务程序既不能有参数，也不能有返回值。（2）但是在带操作系统的嵌入式系统中，中断服务程序可以有参数，也可以有返回值。  </p>
<h4 id="中断和轮询哪个效率高？怎样决定是采用中断方式还是采用轮询方式去实现驱动？"><a href="#中断和轮询哪个效率高？怎样决定是采用中断方式还是采用轮询方式去实现驱动？" class="headerlink" title="中断和轮询哪个效率高？怎样决定是采用中断方式还是采用轮询方式去实现驱动？"></a>中断和轮询哪个效率高？怎样决定是采用中断方式还是采用轮询方式去实现驱动？</h4><p>中断是CPU处于被动状态下来接受设备的信号，而轮询是CPU主动去查询该设备是否有请求。如果是请求设备是一个频繁请求cpu的设备，或者有大量数据请求的网络设备，那么轮询的效率是比中断高。如果是一般设备，并且该设备请求cpu的频率比较低，则用中断效率要高一些。主要是看请求频率。</p>
<h4 id="EXIT和NVIC的关系"><a href="#EXIT和NVIC的关系" class="headerlink" title="EXIT和NVIC的关系"></a>EXIT和NVIC的关系</h4><p>EXTI是外部中断，专注于外部中断信号的处理，配置触发方式和中断源。而NVIC负责全局中断管理，包括优先级配置、中断使能和嵌套。在实际应用中，EXTI 和 NVIC 通常需要配合使用，例如在 STM32 中，外部中断信号通过 EXTI 传递给 NVIC，由 NVIC 进行优先级管理和中断响应。</p>
<h4 id="其他相关概念"><a href="#其他相关概念" class="headerlink" title="其他相关概念"></a>其他相关概念</h4><p>中断优先级：当有多个中断源同时申请中断时，CPU会根据中断源的轻重缓急进行裁决，优先响应更加紧急的中断源。<br>中断向量：中断服务子程序的入口地址。<br>中断嵌套：当一个中断程序正在运行时，又有新的更高优先级的中断源申请中断，CPU再次暂停当前中断程序，转而去处理新的中断程序，处理完成后依次进行返回。<br>原子操作：在执行过程中不会被其他操作中断，在操作开始之前和操作完成之后，系统状态是稳定的，但在操作执行过程中，系统状态对其他线程或进程是不可见的。由于原子操作的不可分割性，它通常用于实现线程安全的操作，避免多线程环境下的竞态条件（Race Condition）和数据不一致问题。</p>
<h3 id="ADC-DAC"><a href="#ADC-DAC" class="headerlink" title="ADC&amp;DAC"></a>ADC&amp;DAC</h3><h4 id="ADC"><a href="#ADC" class="headerlink" title="ADC"></a>ADC</h4><p>ADC即模数转换器，是将连续的模拟信号转换为数字信号的电路。其输入为模拟信号，输出为数字信号。ADC的主要组成部分是模拟信号采样模块、模拟信号处理模块、模数转换模块和数字信号处理模块。其中，模拟信号采样模块负责采集模拟信号，模拟信号处理模块负责对采集的模拟信号进行滤波、放大等处理，模数转换模块则将模拟信号转换为数字信号，数字信号处理模块负责对数字信号进行处理，如滤波、放大、数字信号处理算法等。<br>DAC为数模转换器，用于将数字信号转化为模拟信号。<br>一般我们把模拟信号(Analog signal) 用A来进行简写，数字信号(digital signal) 用D来表示。   模拟信号0-3.3V。数字信号：0、1。<br>ADC模拟信号（电压）转换为数字值，ADC采样值（数字量）到电压的转换公式为：电压值&#x3D;(ADC读取值&#x2F;ADC最大值)*参考电压<br>即若ADC为12位，则其最大值为2^12-1&#x3D;4095。单片机参考电压一般为3.3V或者5V<br>DAC将数字信号值转换成模拟值（输出电压），计算公式为：输出电压&#x3D;（DAC读取值&#x2F;DAC最大值）*参考电压</p>
<h4 id="ADC和DAC的区别"><a href="#ADC和DAC的区别" class="headerlink" title="ADC和DAC的区别"></a>ADC和DAC的区别</h4><p>1、功能不同：ADC是模拟信号转换为数字信号的模数转换器，而DAC是数字信号转换为模拟信号的数字模拟转换器。<br>2、输入输出不同：ADC的输入是模拟信号，输出是数字信号;而DAC的输入是数字信号，输出是模拟信号。<br>3、适用范围不同：ADC通常用于从传感器和其他模拟信号源中读取数据并将其转换为数字信号。DAC则通常用于控制输出电压或电流来控制运动和其他应用。<br>4、采样率不同：ADC的采样率通常比DAC的采样率高。这是因为模拟信号变化的速度比数字信号变化的速度快，因此需要更高的采样率才能准确地转换模拟信号。<br>5、量化误差不同：ADC和DAC都存在量化误差。ADC的量化误差会导致输入信号的失真，而DAC的量化误差会导致输出信号的失真。</p>
<h4 id="ADC的位数？（采样精度）"><a href="#ADC的位数？（采样精度）" class="headerlink" title="ADC的位数？（采样精度）"></a>ADC的位数？（采样精度）</h4><p>F1和F4都具有3个ADC，F1可提供21个输入通道，F4可以提供24个输入通道。<br>F4的ADC支持12位，10位，8位和6位精度，F1只支持12位<br>ADC的数字存储是12位的的话，“111111111111”&#x3D;4095，转换的电压范围是0v-3.3v的话，转换器就会把0v-3.3v平均分成4096份</p>
<h4 id="ADC转换模式"><a href="#ADC转换模式" class="headerlink" title="ADC转换模式"></a>ADC转换模式</h4><p>1、单次转换：ADC只执行一次转换<br>2、连续转换：转换结束之后马上开始新的转换<br>3、扫描：ADC扫描被规则通道和注入通道选中的所有通道，在每个组的每个通道上执行单次转换。在每个转换结束时，这一组的下一个通道被自动转换。如果设置了CONT位（开启了连续 转换模式），转换不会在选择组的最后一个通道上停止，而是再次从选择组的第一个通道继续转换。 简单说就是对所有所选中的通道进行转换！<br>4、间断：触发一次，转换一个通道，在触发，在转换。在所选转换通道循环，由触发信号启动新一轮的转换，直到转换完成为止。</p>
<h4 id="ADC工作原理"><a href="#ADC工作原理" class="headerlink" title="ADC工作原理"></a>ADC工作原理</h4><p>采样：模拟信号以固定的时间间隔进行采样，获得一系列模拟信号的离散样本。<br>量化：采样得到的模拟信号样本被映射到固定数量的离散级别，这个过程叫做量化。量化级别越多，ADC的分辨率越高。<br>编码：量化后的数值需要转换为数字编码。最常见的编码方式是二进制编码。<br>采样，量化，编码，输出；给定模拟参考电压Vref，ADC_GPIOx采集外部信号，通过注入&#x2F;规则通道到模数转换器，写入数据寄存器，输出。</p>
<h4 id="ADC如何提升精度？"><a href="#ADC如何提升精度？" class="headerlink" title="ADC如何提升精度？"></a>ADC如何提升精度？</h4><p>提升ADC分辨率，采用滤波电路减少噪声和干扰，增加采样时间，定期校准和校正；</p>
<h4 id="ADC的量化噪声能否消除？"><a href="#ADC的量化噪声能否消除？" class="headerlink" title="ADC的量化噪声能否消除？"></a>ADC的量化噪声能否消除？</h4><p>不能，因为采样不是理想，而是无限逼近的概念。</p>
<h3 id="CAN通信"><a href="#CAN通信" class="headerlink" title="CAN通信"></a>CAN通信</h3><h4 id="简述一下CAN通信的特点"><a href="#简述一下CAN通信的特点" class="headerlink" title="简述一下CAN通信的特点"></a>简述一下CAN通信的特点</h4><p>1、CAN通信是一种串行、异步、半双工的通信方式，APB1总线。所谓异步、即没有时钟线，因此和uart一样采用波特率方式来进行通信。<br>2、CAN通信的信号为差分信号（抗干扰特性，振幅相等，相位相反），与USB、HDMI、以太网、485一样。<br>3、多个LAN，传输方式有点对点，点对多点，广播三种传送方式。<br>4、速率： 低速（10-125kbps，1000米传输距离）、高速（125kbps-1Mbps，传输距离小于40米）、CAN FD（8Mbps、64Byte）<br>5、每帧为8个有效字节<br>总线组成：<br>1、CAN控制器（片上外设）<br>2、CAN收发器<br>3、CAN High 和CAN Low两根线构成的总线结构。<br>STM32ZET6只有一个CAN外设，PA11–RX，PA12–TX，连接方式与串口通信相反，CAN通信是RX连接RX</p>
<h4 id="CAN总线的基本工作原理是什么？"><a href="#CAN总线的基本工作原理是什么？" class="headerlink" title="CAN总线的基本工作原理是什么？"></a>CAN总线的基本工作原理是什么？</h4><p>CAN总线是一种多主机的串行通信协议，主要用于汽车和工业控制。它通过差分信号（CAN_H和CAN_L）传输数据，具有高抗干扰能力。CAN总线采用非破坏性位仲裁机制，确保高优先级消息优先传输。节点通过发送带有标识符的消息进行通信，标识符不仅表示消息内容，还决定其优先级。    </p>
<h4 id="CAN通信的仲裁机制如何工作"><a href="#CAN通信的仲裁机制如何工作" class="headerlink" title="CAN通信的仲裁机制如何工作"></a>CAN通信的仲裁机制如何工作</h4><p>CAN总线采用非破坏性位仲裁机制，具体过程如下：</p>
<ol>
<li>同时发送：多个节点同时发送消息时，总线通过标识符（ID）进行仲裁。   </li>
<li>位比较：节点在发送ID的同时监听总线电平，若发送的位与总线电平不一致，则退出仲裁。   </li>
<li>优先级：ID值越小，优先级越高。优先级高的节点继续发送，低优先级的节点退出并等待总线空闲后重试。</li>
</ol>
<h4 id="CAN收发器和CAN控制器的区别"><a href="#CAN收发器和CAN控制器的区别" class="headerlink" title="CAN收发器和CAN控制器的区别"></a>CAN收发器和CAN控制器的区别</h4><p>CAN收发器是一种用于CAN总线通信的专用芯片，主要用于将CAN控制器和CAN总线物理层之间的信号进行转换和调节。它的主要作用是将CAN控制器输出的数字信号转换为CAN总线所需要的物理信号，同时将CAN总线上接收到的物理信号转换为数字信号，并将其传递给CAN控制器进行处理。<br>CAN控制器是一种硬件模块，用于实现CAN总线上的数据传输。它包括了发送和接收的功能模块，用于控制CAN总线上的数据帧的发送和接收，并且负责管理帧的错误处理。通常被集成在处理器、微控制器或嵌入式系统中。或者独立CAN控制器，独立CAN控制器与处理器之间通过总线或外设接口进行通信，可以独立地进行CAN总线数据的发送和接收，而不需要处理器的干预。</p>
<h4 id="CAN通信的逻辑电平"><a href="#CAN通信的逻辑电平" class="headerlink" title="CAN通信的逻辑电平"></a>CAN通信的逻辑电平</h4><p>CAN为差分信号，电平定义：显性电平 逻辑0 ；隐形电平 逻辑1。<br>高速CAN，CAN高和CAN低上的电压都为2.5V，此时两者差为0V，表示逻辑“1”，为逻辑隐性；CAN高上的电压为3.5V和CAN低上的电压为1.5V，此时两者差值为2V，表示逻辑“0”，为逻辑显性。</p>
<h4 id="CAN通信的帧类型"><a href="#CAN通信的帧类型" class="headerlink" title="CAN通信的帧类型"></a>CAN通信的帧类型</h4><p>数据帧  用于发送单元向接收单元传送数据的帧。<br>遥控帧  用于接收单元向具有相同ID的发送单元请求数据的帧。<br>错误帧  用于当检测出错误时向其他单元通知错误的帧。<br>过载帧  用于接收单元通知其尚未做好接收准备的帧。<br>帧间隔  用于将数据帧及遥控帧与前面的帧分离开来的帧。</p>
<h4 id="CAN总线中的标识符（ID）有什么作用？"><a href="#CAN总线中的标识符（ID）有什么作用？" class="headerlink" title="CAN总线中的标识符（ID）有什么作用？"></a>CAN总线中的标识符（ID）有什么作用？</h4><p>标识符（ID）在CAN总线中有两个主要作用：</p>
<ol>
<li>消息标识：唯一标识消息的内容和类型。  </li>
<li>优先级决定：ID值越小，优先级越高。总线仲裁时，优先级高的消息会优先传输，低优先级的节点会自动退出发送并等待总线空闲后重试。</li>
</ol>
<h4 id="CAN总线如何实现错误检测和纠正？"><a href="#CAN总线如何实现错误检测和纠正？" class="headerlink" title="CAN总线如何实现错误检测和纠正？"></a>CAN总线如何实现错误检测和纠正？</h4><ol>
<li>CRC校验：每个消息帧包含15位CRC校验码，接收节点会重新计算CRC并与接收到的CRC进行比较。   </li>
<li>帧检查：检查帧格式、位填充规则等是否符合标准。   </li>
<li>ACK确认：发送节点会等待接收节点的ACK确认，未收到ACK则重发。     </li>
<li>错误帧：检测到错误的节点会发送错误帧，通知其他节点丢弃当前消息。</li>
</ol>
<h4 id="CAN通信中的位填充是什么？为什么需要位填充？"><a href="#CAN通信中的位填充是什么？为什么需要位填充？" class="headerlink" title="CAN通信中的位填充是什么？为什么需要位填充？"></a>CAN通信中的位填充是什么？为什么需要位填充？</h4><p>位填充定义（Bit Stuffing）指当CAN节点发送逻辑电平（显性dominant或隐性recessive）为持续相同的5位时，它必须添加一位反向电平，即使连续5个相同位后本就是一个相反位，也需要添加填充位。CAN接收节点会自动删除这个新增的额外电平位。<br>位填充作用：</p>
<ol>
<li>错误检测。当某一个节点发生主动错误时，将把总线拉低6个bit宽度的显性电平“0”，及时向总线上其他单元汇报错误。      </li>
<li>确保发送和接收节点的时钟同步。位填充机制保证了传输过程中有足够的跳变沿。ISO 11898-1规定，发送方在传输连续5个相同位后必须传输一个相反的位。</li>
</ol>
<h4 id="CAN-FD-和CAN的-区别"><a href="#CAN-FD-和CAN的-区别" class="headerlink" title="CAN FD 和CAN的 区别"></a>CAN FD 和CAN的 区别</h4><p>CAN-FD：一帧数据最长64字节。可以理解成CAN协议的升级版，只升级了协议，物理层未改变。传输速率不同、数据长度不同、帧格式不同、ID长度不同。</p>
<ol>
<li>速率不同：CAN：最大传输速率1Mbps。CAN-FD：速率可变，最大传输速率8Mbps。</li>
<li>数据长度不同：CAN：一帧数据最长8字节。CAN-FD：一帧数据最长64字节。</li>
<li>ID长度不同：CAN标准帧ID长度最长11bit。 CAN-FD标准帧ID长度可扩展到12bit。 </li>
<li>帧格式不同：CAN-FD新增了FDF、BRS、ESI位，FDF表示CAN报文还是CAN-FD报文。BRS：表示位速率转换，该位隐性时，速率可变，该位为显性时，以正常的CAN-FD总线速率传输（恒定速率）。</li>
</ol>
<h4 id="CAN总线中的错误状态有哪些？它们是如何转换的？"><a href="#CAN总线中的错误状态有哪些？它们是如何转换的？" class="headerlink" title="CAN总线中的错误状态有哪些？它们是如何转换的？"></a>CAN总线中的错误状态有哪些？它们是如何转换的？</h4><ol>
<li>主动错误状态：节点可正常收发消息，检测到错误时会发送主动错误标志。</li>
<li>被动错误状态：节点错误计数较高，检测到错误时发送被动错误标志，且发送间隔增加。</li>
<li>总线关闭状态：节点错误计数达到上限，节点停止收发消息，需重启或复位才能恢复。<br>状态转换规则：发送或接收错误时，错误计数增加；成功发送或接收时，错误计数减少。发送错误计数超过127时，节点进入被动错误状态；超过255时，进入总线关闭状态。</li>
</ol>
<h4 id="简单讲下CAN通讯吗？"><a href="#简单讲下CAN通讯吗？" class="headerlink" title="简单讲下CAN通讯吗？"></a>简单讲下CAN通讯吗？</h4><p>第一段：需要发送的通讯设备，先发送一个显性电平0，告诉其他通讯设备，需要开始通讯。<br>第二段：就是发送仲裁段，其中包括ID帧和数据帧类型，告诉其他通讯设备，需要和哪个通讯设备进行通讯，以及帧的类型，CAN通讯设备的优先级，就是由ID号决定的，往往ID号越小优先级别越高。为标准帧还是扩展帧，由仲裁段最后一位IDE位的电平决定的，IDE为显性则为标准帧，IDE为隐性则为扩展帧。<br>第三段，为控制段，共6位，四位储存数据段长度的信息，还有两位为保留位。<br>第四段：为数据段，固定长度为8个字节，先发送高位，后发送低位。<br>第五段，为CRC，为验证段。<br>第六段，为ACK为应答段，发送机发送两个隐形电平，接收机发送一个显性电平，告诉发送机，接收完成。<br>第七段，结束段，发送7个隐形电平。</p>
<h4 id="什么是帧间隔？"><a href="#什么是帧间隔？" class="headerlink" title="什么是帧间隔？"></a>什么是帧间隔？</h4><p>帧间隔时间为3个显性电平，在此期间不能发送数据，发送即视为超载；之后为8个隐性电平，为延迟发送期间，如果过了这8个隐性电平时间则进入总线空闲时间。</p>
<h4 id="CANTP是什么？"><a href="#CANTP是什么？" class="headerlink" title="CANTP是什么？"></a>CANTP是什么？</h4><p>CAN接口模块（下文简“CanIf”）位于底层CAN驱动（CanDrv）、CAN收发器（CanTrcv）和上层通信服务层（CanSm、CanNm）、CAN传输协议（CanTp）、PDU路由器（PduR）之间。它表示上层通信层的CAN驱动程序服务接口。CAN Transport Layer Protocol，是一种用于控制器区域网络（CAN）的传输层协议。CANTP为CAN提供了大容量数据的传输，可以将较大的数据分为多个小数据帧进行传输，并在发送和接收端进行重新组装。暴力一点的理解，CANTP的作用就是组包，拆包，传输超时反馈。</p>
<h4 id="CAN通讯中的优先级？"><a href="#CAN通讯中的优先级？" class="headerlink" title="CAN通讯中的优先级？"></a>CAN通讯中的优先级？</h4><p>标准帧与扩展帧之间，标准帧的优先级会更高，扩展帧的优先级更低，相同帧类型中，往往ID更小的发送机，优先级别更高。</p>
<h4 id="扩展帧与标准帧有什么区别？"><a href="#扩展帧与标准帧有什么区别？" class="headerlink" title="扩展帧与标准帧有什么区别？"></a>扩展帧与标准帧有什么区别？</h4><p>扩展帧与标准帧的区别在于扩展帧拥有更长字节的ID，以便能够扩展更多的CAN通讯设备。</p>
<h4 id="什么是busoff"><a href="#什么是busoff" class="headerlink" title="什么是busoff?"></a>什么是busoff?</h4><p>Busoff就是发送错误计数器达到255次之后，CAN总线关闭的情况，CAN总线需要经过128次11个隐形电平才能恢复，或者复位。</p>
<h4 id="STM32的CAN外设支持哪些功能？"><a href="#STM32的CAN外设支持哪些功能？" class="headerlink" title="STM32的CAN外设支持哪些功能？"></a>STM32的CAN外设支持哪些功能？</h4><p>多邮箱支持：有3个发送邮箱和2个接收FIFO。<br>硬件过滤器：内置14个硬件过滤器，用于快速筛选感兴趣的消息，减少CPU负担。 - 支持标识符掩码模式和标识符列表模式。<br>自动重发：支持消息的自动重发功能，确保在总线错误或仲裁失败后重新发送。<br>时间触发通信：支持时间触发的CAN通信（Time Triggered Communication），用于严格时间同步的应用。<br>优先级管理：硬件支持根据标识符的优先级动态调度帧的发送顺序。</p>
<h4 id="STM32的CAN外设有哪些模式（如正常模式、环回模式）？"><a href="#STM32的CAN外设有哪些模式（如正常模式、环回模式）？" class="headerlink" title="STM32的CAN外设有哪些模式（如正常模式、环回模式）？"></a>STM32的CAN外设有哪些模式（如正常模式、环回模式）？</h4><p>正常模式（Normal Mode），这是CAN外设的默认工作模式，用于实际的网络通信。<br>环回模式（Loopback Mode），在此模式下，CAN外设的发送数据直接回送到接收端，而不会实际发送到总线，可以模拟总线通信，但不会影响其他节点。<br>静默模式（Silent Mode），节点只能监听总线上的数据，但不会主动发送数据或参与仲裁。<br>时间触发通信模式（Time-Triggered Communication Mode，TTCM），该模式允许时间触发的CAN帧通信，用于实现节点之间的精确时间同步</p>
<h4 id="CAN通讯在单片机中的设置？"><a href="#CAN通讯在单片机中的设置？" class="headerlink" title="CAN通讯在单片机中的设置？"></a>CAN通讯在单片机中的设置？</h4><p>设置引脚、开启时钟，其中最重要的是过滤器的设置：用于硬件过滤CAN通讯的ID，有两种模式，一种是列表模式，将传输的ID用列表逐一匹配，列表模式可以选择16位或32位的位宽ID，第二种就是掩码模式，掩码模式就是，共11位的代码，只按照条件识别有效的四位即可。<br>需要选择过滤器，设置过滤器ID和掩码ID，掩码ID位为1时，该位需要与过滤器进行比较。标准帧需要右移5位存储至寄存器的高11位中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">CAN_FilterTypeDef sFilterConfig;<br><br><span class="hljs-comment">// 配置过滤器参数</span><br>sFilterConfig.FilterBank = <span class="hljs-number">0</span>;                       <span class="hljs-comment">// 过滤器编号</span><br>sFilterConfig.FilterMode = CAN_FILTERMODE_IDMASK;   <span class="hljs-comment">// 屏蔽模式</span><br>sFilterConfig.FilterScale = CAN_FILTERSCALE_32BIT;  <span class="hljs-comment">// 32位过滤器</span><br>sFilterConfig.FilterIdHigh = <span class="hljs-number">0x123</span> &lt;&lt; <span class="hljs-number">5</span>;            <span class="hljs-comment">// 标识符高位（标准标识符左移5位）</span><br>sFilterConfig.FilterIdLow = <span class="hljs-number">0x0000</span>;                 <span class="hljs-comment">// 标识符低位</span><br>sFilterConfig.FilterMaskIdHigh = <span class="hljs-number">0x7FF</span> &lt;&lt; <span class="hljs-number">5</span>;        <span class="hljs-comment">// 屏蔽高位，完全匹配</span><br>sFilterConfig.FilterMaskIdLow = <span class="hljs-number">0x0000</span>;             <span class="hljs-comment">// 屏蔽低位</span><br>sFilterConfig.FilterFIFOAssignment = CAN_RX_FIFO0;  <span class="hljs-comment">// 消息存储到FIFO0</span><br>sFilterConfig.FilterActivation = ENABLE;            <span class="hljs-comment">// 启用过滤器</span><br><br><span class="hljs-comment">// 应用过滤器</span><br><span class="hljs-keyword">if</span> (HAL_CAN_ConfigFilter(&amp;hcan, &amp;sFilterConfig) != HAL_OK) &#123;<br>    <span class="hljs-comment">// 处理错误</span><br>    Error_Handler();<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="can总线是如何实现时钟同步的？"><a href="#can总线是如何实现时钟同步的？" class="headerlink" title="can总线是如何实现时钟同步的？"></a>can总线是如何实现时钟同步的？</h4><ol>
<li>硬同步（Hard Synchronization）<br>触发条件： 仅在帧起始（SOF，Start of Frame）的下降沿触发。<br>作用： 强制将接收节点的位时间计数器重置为Sync_Seg的起点，与发送节点对齐。<br>目的： 在每帧开始时消除初始相位偏差。</li>
<li>再同步（Re-synchronization）<br>触发条件： 在数据帧的后续位中，检测到信号边沿（从显性电平到隐性电平的跳变）。<br>作用： 根据边沿的位置调整Phase_Seg1和Phase_Seg2的长度，补偿节点间时钟频率差异。<br>调整规则：<br>如果边沿出现在Phase_Seg1中：延长Phase_Seg1，补偿时钟偏差。<br>如果边沿出现在Phase_Seg2中：缩短Phase_Seg2，补偿时钟偏差。<br>再同步调整是临时性的，仅作用于当前帧的后续位传输。新的帧来临时会复原位时间。</li>
</ol>
<h3 id="请解释一下嵌入式系统中的看门狗定时器的作用。"><a href="#请解释一下嵌入式系统中的看门狗定时器的作用。" class="headerlink" title="请解释一下嵌入式系统中的看门狗定时器的作用。"></a>请解释一下嵌入式系统中的看门狗定时器的作用。</h3><p>看门狗定时器主要作用是监控和重置系统，以防止因软件故障（如死循环、程序跑飞等）导致的系统崩溃。看门狗定时器的工作原理如下：<br>定时监控：看门狗定时器会周期性地检查系统是否正常运行。这通常通过检查主程序是否在规定的时间内执行了特定的操作（如喂狗操作）来实现。<br>超时重置：如果系统未能在预定时间内执行喂狗操作，看门狗定时器将认为系统出现故障，并自动触发重置信号。这通常会导致系统重启，从而尝试恢复正常运行。<br>提高系统可靠性：通过及时检测和重置系统故障，看门狗定时器可以显著提高嵌入式系统的可靠性和稳定性。</p>
<h3 id="在嵌入式开发中，如何进行功耗管理？"><a href="#在嵌入式开发中，如何进行功耗管理？" class="headerlink" title="在嵌入式开发中，如何进行功耗管理？"></a>在嵌入式开发中，如何进行功耗管理？</h3><p>功耗管理可以从硬件设计、软件优化以及系统级优化三个方面进行。</p>
<h4 id="硬件设计"><a href="#硬件设计" class="headerlink" title="硬件设计"></a>硬件设计</h4><ul>
<li>选择低功耗硬件组件：在硬件设计阶段，应优先考虑选择低功耗的处理器、传感器、存储器等组件。</li>
<li>优化硬件设计：通过合理布局和布线，减少信号干扰和能量损失。</li>
<li>降低硬件功耗：采用低功耗工作模式，如休眠模式、待机模式等，以减少非工作状态的能耗。</li>
</ul>
<h4 id="软件优化"><a href="#软件优化" class="headerlink" title="软件优化"></a>软件优化</h4><ul>
<li>算法优化：通过对算法的优化，降低算法的时间复杂度和空间复杂度，从而减少CPU和内存的消耗，进而降低功耗。</li>
<li>数据压缩：通过数据压缩技术，减少数据传输和处理的功耗。例如，使用Huffman编码、Lempel-Ziv-Welch(LZW)编码等无失真压缩算法。</li>
<li>操作系统级别的功耗优化：操作系统可以提供多种功耗管理策略，如动态电源管理、CPU频率调整等，以根据系统的实际负载动态调整功耗。</li>
</ul>
<h4 id="系统级优化"><a href="#系统级优化" class="headerlink" title="系统级优化"></a>系统级优化</h4><ul>
<li>功耗模式管理：根据系统的需求和运行状态选择不同的功耗模式，如正常工作模式、低功耗模式、休眠模式等。</li>
<li>任务调度优化：通过合理的任务调度策略，如使用RTOS（实时操作系统）的抢占式调度和时间片轮询调度算法，确保高优先级任务能够及时响应，同时减少低优先级任务的能耗。</li>
</ul>
<h3 id="HEX文件和BIN文件的区别？"><a href="#HEX文件和BIN文件的区别？" class="headerlink" title="HEX文件和BIN文件的区别？"></a>HEX文件和BIN文件的区别？</h3><p>HEX文件是包括地址信息的，而BIN文件格式只包括了数据本身</p>
<h3 id="单片机程序与Linux的程序的区别"><a href="#单片机程序与Linux的程序的区别" class="headerlink" title="单片机程序与Linux的程序的区别"></a>单片机程序与Linux的程序的区别</h3><p>单片机的 CPU 是直接操作内存的「物理地址」，单片机是没有操作系统的，所以每次写完代码，都需要借助工具把程序烧录进去，这样程序才能跑起来。因此，要想在内存中同时运行两个程序是不可能的。<br>操作系统是如何解决这个问题呢？ 操作系统会提供一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来。如果程序要访问虚拟地址的时候，由操作系统转换成不同的物理地址，这样不同的进程运行的时候，写入的是不同的物理地址，这样就不会冲突了。我们程序所使用的内存地址叫做虚拟内存地址(Virtual Memory Address)。实际存在硬件里面的空间地址叫物理内存地址(Physical Memory Address)。<br>单片机代码运行在Flash上，而Linux代码运行在内存上。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>STM32笔记</div>
      <div>http://example.com/2025/04/06/STM32/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>JohnTino</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年4月6日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/04/20/leetcode/" title="Leetcode">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Leetcode</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>




  
<script src="//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/runtime.min.js"></script>
<script src="//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/DynamicLine.min.js"></script>
<script src="//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/snowflake.min.js"></script>
<script src="//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/Cherry.min.js"></script>
<script src="//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/star.min.js"></script>
<script src="//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/containsWord.min.js"></script>
<script src="//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/love.min.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<!-- hexo injector body_end start --><script src="/js/backgroundize.js"></script>
  <link defer rel="stylesheet" href="/css/backgroundize.css" />
  <!-- hexo injector body_end end --></body>
</html>
